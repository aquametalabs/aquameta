\\x1f679d9ba17102fe3711460718f55034c97376a18a0e4d366fe24b1fc693da06	datum-plv8
\\x35d2d864c15f9825dd5b09c372d1b9e518f7d5e53ad86e96d202452bf14cb6bf	/*******************************************************************************\n * Widget.js\n *\n * Created by Aquameta Labs, an open source company in Portland Oregon, USA.\n * Project: http://aquameta.com/\n ******************************************************************************/\n/* eslint-env browser */\n/* globals jQuery define */\ndefine(['/doT.js', '/jQuery.min.js', '/datum.js'], function (\n  doT,\n  $,\n  AQ,\n  undefined // eslint-disable-line\n) {\n  'use strict';\n\n  doT.templateSettings.strip = false;\n\n  var widget_promises = {};\n  var containers = {};\n  var namespaces = {};\n\n  AQ.Widget = {};\n\n  AQ.Widget.widget = function (selector, input, extra) {\n    if (!selector || typeof selector != 'string') {\n      throw 'Widget - Selector argument is invalid or missing';\n    }\n\n    // Same namespace as calling widget, instead of global '' namespace\n    var default_namespace =\n      typeof this != 'undefined' && typeof this.namespace != 'undefined'\n        ? this.namespace\n        : '';\n\n    var is_semantic_dsl_lookup = selector.indexOf('/') != -1;\n\n    // For semantic lookup\n    // * selector is 'semantics/purpose/default_bundle'\n    // * input is AQ.* object\n    // * extra is {} to send to widget\n    if (is_semantic_dsl_lookup) {\n      if (!input) {\n        throw 'Semantics requires an AQ.* to be passed in';\n      }\n\n      var context = extra || {};\n      var semantics = selector.split('/');\n      var args_object = {};\n\n      // If input is a promise (that will resolve as a Rowset or a Row), resolve it first\n      if (input instanceof Promise) {\n        var url_id;\n        var widget_getter = input.then(function (input) {\n          context.datum = input;\n\n          // These are the same for both Rowset and Row\n          var endpoint = input.relation.schema.database;\n          var fn = 'relation_widget';\n          var type = 'meta.relation_id';\n          console.log('promise');\n          args_object.relation_id = {\n              name: input.relation.id.name,\n              schema_name: input.relation.id.schema_id.name,\n          };\n          console.log(args_object);\n\n          if (input instanceof AQ.Rowset) {\n            context.rows = input;\n            url_id = input.relation.to_url(true);\n          } else if (input instanceof AQ.Row) {\n            context.row = input;\n            url_id = input.to_url(true);\n          }\n          args_object.widget_purpose = semantics[1];\n          args_object.default_bundle =\n            semantics.length >= 3\n              ? semantics[2]\n              : 'org.aquameta.core.semantics';\n\n          return endpoint.schema('semantics').function(\n            {\n              name: fn,\n              parameters: [type, 'text', 'text'],\n            },\n            args_object,\n            {use_cache: true, meta_data: false}\n          );\n        });\n      }\n      // Else, check which type it is\n      else {\n        context.datum = input;\n\n        if (\n          input instanceof AQ.Relation ||\n          input instanceof AQ.Table ||\n          input instanceof AQ.View\n        ) {\n          var endpoint = input.schema.database;\n          var fn = 'relation_widget';\n          var type = 'meta.relation_id';\n          console.log(input, 'rel');\n          args_object.relation_id = {\n              name: input.id.name,\n              schema_name: input.id.schema_id.name,\n          };\n          var url_id = input.to_url(true);\n          context.relation = input;\n        } else if (input instanceof AQ.Row) {\n          var endpoint = input.relation.schema.database;\n          var fn = 'relation_widget';\n          var type = 'meta.relation_id';\n          console.log(input, 'row');\n          args_object.relation_id = {\n              name: input.relation.id.name,\n              schema_name: input.relation.id.schema_id.name,\n          };\n          console.log(args_object);\n          var url_id = input.to_url(true);\n          context.row = input;\n        } else if (input instanceof AQ.Rowset) {\n          var endpoint = input.relation.schema.database;\n          var fn = 'relation_widget';\n          var type = 'meta.relation_id';\n          console.log(input, 'rowset');\n          args_object.relation_id = {\n              name: input.relation.id.name,\n              schema_name: input.relation.id.schema_id.name,\n          };\n          var url_id = input.relation.to_url(true);\n          context.rows = input;\n        } else if (input instanceof AQ.Column) {\n          var endpoint = input.relation.schema.database;\n          var fn = 'column_widget';\n          var type = 'meta.column_id';\n          args_object.column_id = {\n              name: input.id.name,\n              relation_name: input.id.relation_id.name,\n              schema_name: input.id.relation_id.schema_id.name,\n          };\n          var url_id = input.relation.to_url(true);\n          context.column = input;\n        } else if (input instanceof AQ.Field) {\n          var endpoint = input.row.relation.schema.database;\n          var fn = 'column_widget';\n          var type = 'meta.column_id';\n          args_object.column_id = {\n              name: input.id.column_id.name,\n              relation_name: input.id.column_id.relation_id.name,\n              schema_name: input.id.column_id.relation_id.schema_id.name,\n          };\n          var url_id = input.to_url(true);\n          context.field = input;\n        }\n\n        args_object.widget_purpose = semantics[1];\n        args_object.default_bundle =\n          semantics.length >= 3 ? semantics[2] : 'org.aquameta.core.semantics';\n\n        var widget_getter = endpoint.schema('semantics').function(\n          {\n            name: fn,\n            parameters: [type, 'text', 'text'],\n          },\n          args_object,\n          {use_cache: true, meta_data: false}\n        );\n      }\n\n      // Go get this widget - retrieve_promises don't change for calls to the same widget - they are cached by the widget name\n      var widget_retrieve_promise = retrieve(widget_getter, {\n        semantic_selector: selector,\n        url_id: url_id,\n      });\n    }\n\n    // For regular widget lookup\n    // * selector is '[namespace:]widget_name'\n    // * input is {} to send to widget\n    // * extra is ignored\n    else {\n      //var context = typeof input != 'undefined' ? Object.assign({}, input) : {};\n      var context = input || {};\n\n      var name_parts = selector.split(':');\n\n      if (name_parts.length == 1) {\n        // Default namespace lookup\n        context.namespace = default_namespace;\n        context.name = name_parts[0];\n      } else {\n        // Namespaced lookup\n        context.namespace = name_parts[0];\n        context.name = name_parts[1];\n        context.bundle_name = namespaces[context.namespace].bundle_name;\n      }\n\n      // Namespace not found\n      if (!(context.namespace in namespaces)) {\n        throw (\n          'Widget namespace "' +\n          context.namespace +\n          '" has not been imported - Call AQ.Widget.import( bundle_name, namespace, endpoint ) to import bundled widgets to a namespace'\n        );\n      }\n\n      var widget_getter = namespaces[context.namespace].endpoint\n        .schema('widget')\n        .function(\n          'bundled_widget',\n          [namespaces[context.namespace].bundle_name, context.name],\n          {\n            use_cache: true,\n            meta_data: false,\n          }\n        );\n\n      // Go get this widget - retrieve_promises don't change for calls to the same widget - they are cached by the widget name\n      var widget_retrieve_promise = retrieve(widget_getter, {\n        namespace: context.namespace,\n        name: context.name,\n      });\n    }\n\n    context.id = AQ.uuid();\n\n    // Setup default namespace for child widget\n    context.widget = AQ.Widget.widget.bind({namespace: context.namespace});\n    context.widget.sync = AQ.Widget.widget.sync;\n\n    // Prepare and render the widget - each prepare_promise is unique because inputs are different - they are cached by the unique uuid created for the context\n    widget_promises[context.id] = prepare(widget_retrieve_promise, context);\n\n    // Return script that calls swap\n    return (\n      '<script id="widget-stub_' +\n      context.id +\n      '" data-widget_id="' +\n      context.id +\n      '">' +\n      'AQ.Widget.swap($("#widget-stub_' +\n      context.id +\n      '"), "' +\n      context.id +\n      '");' +\n      '</script>'\n    );\n  };\n\n  /* Import a bundle name to a local namespace */\n  AQ.Widget.import = function (bundle_name, namespace, endpoint) {\n    namespaces[namespace] = {\n      endpoint: endpoint,\n      bundle_name: bundle_name,\n    };\n  };\n\n  /* Return an array bundle of imported bundle names */\n  AQ.Widget.bundles = function () {\n    return Object.keys(namespaces).map(function (key) {\n      return namespaces[key].bundle_name;\n    });\n  };\n\n  /* Find the bundle that was imported to this namespace */\n  AQ.Widget.bundle = function (namespace) {\n    return namespaces[namespace].bundle_name;\n  };\n\n  /* Find the namespace that uses this bundle */\n  AQ.Widget.namespace = function (bundle_name) {\n    return Object.keys(namespaces).find(function (namespace) {\n      return namespaces[namespace].bundle_name == bundle_name;\n    });\n  };\n\n  function retrieve(widget_getter, selector) {\n    if ('semantic_selector' in selector) {\n      var semantic_lookup = true;\n    }\n\n    return widget_getter\n      .then(function (row) {\n        // Get all related widget data\n        return Promise.all([\n          row /* VIEWSIGNORE\n                row.related_rows('id', 'widget.input', 'widget_id', { use_cache: true, meta_data: true, events: null }).catch(function(){ return; }), \n                row.related_rows('id', 'widget.widget_view', 'widget_id', { use_cache: true, meta_data: true, events: null })\n                    .then(function(widget_views) {\n\n                        var db = row.schema.database;\n                        return widget_views.map(function(widget_view) {\n                            var view_id = widget_view.get('view_id');\n                            return db.schema(view_id.schema_id.name).view(view_id.name);\n                        });\n\n                    }).catch(function(err) { return; }), */,\n          row\n            .related_rows('id', 'widget.widget_dependency_js', 'widget_id', {\n              use_cache: true,\n              meta_data: true,\n              events: null,\n            })\n            .then(function (deps_js) {\n              if (!deps_js.length) {\n                return;\n              }\n              return deps_js.related_rows(\n                'dependency_js_id',\n                'widget.dependency_js',\n                'id',\n                {use_cache: true, meta_data: true, events: null}\n              );\n            })\n            .then(function (deps) {\n              return Promise.all(\n                deps.map(function (dep) {\n                  return System.import(dep.field('content').to_url()).then(\n                    function (dep_module) {\n                      //console.log('my module', dep_module);\n\n                      return {\n                        url: dep.field('content').to_url(),\n                        name: dep.get('variable') || 'non_amd_module',\n                        /* TODO: This value thing is a hack. For some reason, jwerty doesn't load properly here */\n                        value:\n                          typeof dep_module == 'object'\n                            ? dep_module[Object.keys(dep_module)[0]]\n                            : dep_module,\n                        //value: dep_module\n                      };\n                    }\n                  );\n                })\n              );\n            })\n            .catch(function () {\n              return;\n            }),\n        ]);\n      })\n      .catch(function (err) {\n        if (semantic_lookup) {\n          throw (\n            'Widget not found from semantic lookup with ' +\n            selector.semantic_selector +\n            ' on ' +\n            selector.url_id\n          );\n        } else {\n          throw (\n            'Widget does not exist, ' + selector.namespace + ':' + selector.name\n          );\n        }\n      });\n  }\n\n  function prepare(retrieve_promise, context) {\n    return retrieve_promise.then(function (widget_data) {\n      //console.log('retrieve_promise resolved', widget_data);\n      var [widget_row, /* inputs, VIEWSIGNORE views, */ deps_js] = widget_data;\n\n        if (!widget_row.get) {\n            console.log(widget_data, widget_row);\n        }\n      context.name = widget_row.get('name');\n\n      var xinput = context;\n      context = Object.assign(\n        {\n          db: widget_row.schema.database,\n          endpoint: widget_row.schema.database,\n          input: {},\n          xinput: xinput,\n        },\n        context\n      );\n\n      delete context.xinput.id;\n      delete context.xinput.name;\n      delete context.xinput.namespace;\n      delete context.xinput.widget;\n\n      // Process inputs\n      if (typeof inputs != 'undefined') {\n        inputs.forEach(function (input) {\n          var input_name = input.get('name');\n\n          if (typeof context[input_name] == 'undefined') {\n            if (input.get('optional')) {\n              var default_code = input.get('default_value');\n              try {\n                if (default_code) {\n                  context[input_name] = eval('(' + default_code + ')');\n                } else {\n                  context[input_name] = undefined;\n                }\n              } catch (e) {\n                error(\n                  e,\n                  context.name,\n                  'Widget default eval failure: ' + default_code\n                );\n                /*\n                                console.error("Widget default eval failure", default_code);\n                                throw e;\n                                */\n              }\n            } else {\n              error(\n                'Missing required input ' + input_name,\n                context.name,\n                'Inputs'\n              );\n            }\n          }\n          context.input[input_name] = context[input_name];\n          delete context.xinput[input_name];\n        });\n      }\n\n      // Load views into context\n      if (typeof views != 'undefined') {\n        views.forEach(function (view) {\n          context[view.schema.name + '_' + view.name] = view;\n        });\n      }\n\n      var rendered_widget = render(widget_row, context);\n      var post_js_function = create_post_js_function(\n        widget_row,\n        context,\n        deps_js\n      );\n\n      // Return rendered widget and post_js function\n      return {\n        html: rendered_widget,\n        widget_id: context.id,\n        widget_name: context.name,\n        post_js: post_js_function,\n      };\n    });\n  }\n\n  function render(widget_row, context) {\n    // Create html template\n    var html_template = doT.template(widget_row.get('html') || '');\n\n    // Compile html template\n    try {\n      var html = html_template(context);\n    } catch (e) {\n      error(e, context.name, 'HTML');\n    }\n\n    // Render html\n    try {\n      var rendered = $(html)\n        .attr('data-widget', context.name)\n        .attr('data-widget_id', context.id)\n        .attr('data-bundle_alias', context.namespace)\n        .attr('data-bundle_name', context.bundle_name)\n        .attr('data-widget_row_id', widget_row.get('id'))\n        .data('help', widget_row.get('help'));\n    } catch (e) {\n      error(e, context.name, 'HTML (adding data-* attributes)');\n    }\n\n    // If CSS exists and has not yet been applied\n    if (\n      widget_row.get('css') != null &&\n      $('style[data-widget="' + context.name + '"]').length == 0\n    ) {\n      // Create css template\n      var css_template = doT.template(widget_row.get('css') || '');\n\n      // Try to run css template\n      try {\n        var css = css_template(context);\n      } catch (e) {\n        error(e, context.name, 'CSS');\n      }\n\n      // Add css to dom\n      $(\n        '<style type="text/css" data-widget="' +\n          context.name +\n          '">' +\n          css +\n          '</style>'\n      ).appendTo(document.head);\n    }\n\n    return rendered;\n  }\n\n  function create_post_js_function(widget_row, context, deps_js) {\n    var context_keys = Object.keys(context).sort();\n\n    // Get context values\n    var context_vals = context_keys.map(function (key) {\n      return context[key];\n    });\n\n    // Dependency names and values\n    var dep_names = [],\n      dep_values = [];\n    if (deps_js != null) {\n      deps_js.forEach(function (dep_js) {\n        dep_names.push(dep_js.name);\n        dep_values.push(dep_js.value);\n      });\n    }\n\n    try {\n      /*\n       * Creating an script that looks like this\n       * function(dep1_name, dep2_name, ...) {\n       *   function(input1, input2) {\n       *       post_js\n       *   }.apply(this.this.context_vals);\n       * }.apply(this, this.dep_vals);\n       */\n      var post_js = Function(\n        '(function(' +\n          dep_names.join(',') +\n          ') { \\n' +\n          '(function(' +\n          context_keys.join(',') +\n          ') { \\n' +\n          'var w = $("#"+id);\\n\\n' +\n          widget_row.get('post_js') +\n          '\\n//# sourceURL=' +\n          widget_row.get('id') +\n          '/' +\n          widget_row.get('name') +\n          '/post_js\\n' +\n          '}).apply(this, this.context_vals);' +\n          '}).apply(this, this.dep_values);'\n      ).bind({context_vals: context_vals, dep_values: dep_values});\n    } catch (e) {\n      error(e, widget_row.get('name'), 'Creating post_js function');\n    }\n\n    return post_js;\n  }\n\n  // detect svg widgets by tag name.  might be better to check the dom to see if we're inside an svg tag?\n  AQ.Widget.is_svg = function (e) {\n    var svg_tags = ['circle', 'rect', 'polygon', 'g']; // TODO: add more, or change approach?\n    for (var i = 0; i < svg_tags.length; i++) {\n      if (e.tagName.toUpperCase() == svg_tags[i].toUpperCase()) {\n        // console.log('svg  widget: ' + svg_tags[i]);\n        return true;\n      }\n    }\n    return false;\n  };\n\n  AQ.Widget.swap = function ($element, id) {\n    widget_promises[id]\n      .then(function (rendered_widget) {\n        // Replace stub\n        // special case for svg elements - http://stackoverflow.com/questions/3642035/jquerys-append-not-working-with-svg-element\n        if (AQ.Widget.is_svg(rendered_widget.html[0])) {\n          // TODO: is there ever a case where there is more than one element in this array?\n          var div = document.createElementNS(\n            'http://www.w3.org/1999/xhtml',\n            'div'\n          );\n          div.innerHTML =\n            '<svg xmlns="http://www.w3.org/2000/svg">' +\n            rendered_widget.html[0].outerHTML +\n            '</svg>';\n\n          var frag = document.createDocumentFragment();\n          while (div.firstChild.firstChild)\n            frag.appendChild(div.firstChild.firstChild);\n\n          $element.replaceWith(frag);\n        } else $element.replaceWith(rendered_widget.html);\n\n        // Run post_js - or this may have to be done with a script tag appended to the widget\n        try {\n          rendered_widget.post_js();\n        } catch (e) {\n          error(e, rendered_widget.widget_name, 'Running post_js function');\n        }\n\n        var w = $('#' + rendered_widget.widget_id);\n\n        // notify the world that a widget has loaded.  debugger uses this to detect widget tree changes\n        w.trigger('widget_loaded', {widget: w});\n\n        // Delete prepeared_promise\n        delete widget_promises[id];\n      })\n      .catch(function (error) {\n        //console.error('Widget swap failed - ', error);\n        console.error(error);\n        // Remove stub\n        $element.remove();\n        // Delete promise\n        delete widget_promises[id];\n      });\n  };\n\n  function error(err, widget_name, step_name) {\n    console.error(\n      "widget('" + widget_name + "', ...) " + step_name + ' failed!'\n    );\n    //window.setTimeout(function() { throw err; }, 100);\n    throw err;\n  }\n\n  AQ.Widget.sync = function (\n    rowset_promise,\n    container,\n    widget_maker,\n    handlers\n  ) {\n    if (handlers === undefined) {\n      handlers = {};\n    }\n\n    if (widget_maker === undefined) {\n      throw 'widget.sync missing widget_maker argument';\n    }\n\n    if (container.length < 1) {\n      throw 'widget.sync failed: The specified container is empty or not found';\n      return;\n    }\n\n    if (container.length > 1) {\n      throw 'widget.sync failed: The specified container contains multiple elements';\n      return;\n    }\n\n    if (!container instanceof jQuery) {\n      throw 'widget.sync failed: The specified container is not a jQuery object';\n      return;\n    }\n\n    if (\n      typeof rowset_promise == 'undefined' ||\n      (!(rowset_promise instanceof Promise) &&\n        !(rowset_promise instanceof AQ.Rowset) &&\n        !(rowset_promise instanceof AQ.FunctionResultSet))\n    ) {\n      throw 'widget.sync failed: rowset_promise must be a "thenable" promise or a resolved AQ.Rowset or a resolved AQ.FunctionResultSet';\n    }\n\n    if (!(rowset_promise instanceof Promise)) {\n      rowset_promise = Promise.resolve(rowset_promise);\n    }\n\n    rowset_promise\n      .then(function (rowset) {\n        if (\n          typeof rowset == 'undefined' ||\n          typeof rowset.forEach == 'undefined'\n        ) {\n          throw 'Rowset is not defined. First argument to widget.sync must return a Rowset';\n        }\n\n        var container_id = AQ.uuid();\n\n        container.attr('data-container_id', container_id);\n        containers[container_id] = {\n          container: container,\n          widget_maker: widget_maker,\n          handlers: handlers,\n        };\n\n        if (rowset instanceof AQ.Rowset) {\n          let widgets = [];\n          rowset.forEach(function (row) {\n            const w = $(widget_maker(row));\n            container.append(w);\n            widgets.push([row.to_url(true), w.attr('data-widget_id')]);\n          });\n          rowset.onDelete(function (deletedRowId) {\n            const widget = widgets.find(([rowId]) => rowId === deletedRowId);\n            if (widget) {\n              const id = widget[1];\n              container.find(`#${id}`).remove();\n            }\n          });\n          rowset.onUpdate(function (row) {\n            const rowUrl = row.to_url(true);\n            const index = widgets.findIndex(([rowId]) => rowId === rowUrl);\n            if (index >= 0) {\n              const widget = widgets[index];\n              const id = widget[1];\n              const newWidget = $(widget_maker(row));\n              widgets[index] = [\n                row.to_url(true),\n                newWidget.attr('data-widget_id'),\n              ];\n              container.find(`#${id}`).replaceWith(newWidget);\n            }\n          });\n        } else {\n          rowset.forEach(function (row) {\n            container.append(widget_maker(row));\n          });\n        }\n      })\n      .catch(function (error) {\n        console.error('widget.sync failed: ', error);\n      });\n  };\n\n  // duplicate name for backwards compatibility\n\n  AQ.Widget.widget.sync = AQ.Widget.sync;\n\n  return AQ.Widget.widget;\n});\n
\\x3b5019fc08a9fb748e1738a3f8540a7b46937c6faa493ddbd9541b6bbf227d45	55dcddd1-0b18-4ef1-a789-3d565c7114bf
\\x5aed3b40c04ba9727c3eaa3284b8c73416ec9f642085a475372533324fb7eb82	plv8.elog(WARNING,'Loading datum-plv8.js......');\n\nvar AQ = AQ || {};\n\nAQ.uuid = function() {\n    var d = new Date().getTime();\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = (d + Math.random()*16)%16 | 0;\n        d = Math.floor(d/16);\n        return (c=='x' ? r : (r&0x7|0x8)).toString(16);\n    });\n}\n\n\nfunction query_options( options ) {\n\n    var keys = [];\n\n    if (typeof options != 'undefined') {\n\n        // Meta data defaults to true;\n        if (typeof options.meta_data == 'undefined') {\n            options.meta_data = true;\n        }\n\n        // Map the keys of the options object to an array of encoded url components\n        Object.keys(options).sort().map(function(key_name) {\n\n            var key = options[key_name];\n\n            switch(key_name) {\n\n                case 'where':\n                    // where: { name: 'column_name', op: '=', value: 'value' }\n                    // where: [{ name: 'column_name', op: '=', value: 'value' }]\n                    if (typeof key.length == 'undefined') key = [key];\n\n                    return key.map(function(where) {\n                        return 'where=' + encodeURIComponent(JSON.stringify(where));\n                    }).join('&');\n\n                case 'order_by':\n                    // So many possibilities...\n                    // order_by: '-?column_name'\n                    // order_by: ['-?column_name']\n                    // order_by: { 'column_name': 'asc|desc' }\n                    // order_by: [{ 'column_name': 'asc|desc' }]\n                    // order_by: { column: 'column_name', direction: 'asc|desc' }\n                    // order_by: [{ column: 'column_name', direction: 'asc|desc' }]\n                    if (typeof key.length == 'undefined') key = [key];\n\n                    return key_name + '=' + encodeURIComponent(key.map(function(o,i) {\n                        return ((typeof o.direction != 'undefined' && o.direction != 'asc') ? '-' : '') + o.column;\n                    }).join(','));\n\n                case 'limit':\n                    // limit: number\n                case 'offset':\n                    // offset: number\n                    var parsedNum = parseInt(key);\n                    if (!isNaN(parsedNum)) {\n                        return key_name + '=' + parsedNum;\n                    }\n                    return;\n                case 'meta_data':\n                case 'args':\n                case 'exclude':\n                case 'include':\n                    return key_name + '=' + encodeURIComponent(JSON.stringify(key));\n            }\n        }\n\n                                        // Remove all undefined elements of the array\n                                       ).forEach(function(e) {\n            if (typeof e != 'undefined') keys.push(e);\n        });\n    }\n\n    // Return the query string by joining the array with &'s\n    return keys.length ? '?' + keys.join('&') : '?';\n}\n\n\n\n/*--------------------------------- * Database * ---------------------------------*/\nfunction Endpoint( url ) {\n\n    this.url = url;\n    \n    var resource = function( method, meta_id, args, data ) {\n\n        args = args || {};\n\n        // URLs\n        var id_url = meta_id.to_url(true); // ID part of the URL only\n        var url_without_query = this.url + id_url;\n        var query_ops = query_options(args);\n        var url_with_query = url_without_query + query_ops;\n\n        // Settings object to send with 'fetch' method\n        var init_obj = {\n            method: method\n        };\n\n        // Don't add data on GET requests\n        if (method != 'GET') {\n            init_obj.body = JSON.stringify(data);\n        }\n\n        // var request = fetch(method == 'GET' ? url_with_query : url_without_query, init_obj);\n        var request = {\n            "then": function(f) {\n                plv8.elog(WARNING, 'THEN: this: '+JSON.stringify(this)+', f: '+JSON.stringify(f));\n                return f;\n            },\n            "catch": function(f) {\n                plv8.elog(WARNING, 'CATCH: this: '+JSON.stringify(this)+', f: '+JSON.stringify(f));\n                return f;\n            },\n            "bind": function(f) {\n                plv8.elog(WARNING, 'BIND: this: '+JSON.stringify(this)+', f: '+JSON.stringify(f));\n                return f;\n            }\n        }\n\n        var response = plv8.execute('select * from endpoint.request($1,$2,$3,$4,$5)', [\n            '0.2',\n            method,\n            url_without_query,\n            JSON.stringify(query_ops),\n            '{}'\n        ]);\n\n        plv8.elog(WARNING, 'FAT ASS RESPONSE: '+JSON.stringify(response));\n\n        // Read json stream\n        /*\n        var json = response.json();\n\n        if (response.status >= 200 && response.status < 300) {\n            return json;\n        }\n        */\n        \n        return request;\n    }\n\n/*\n\treturn {\n        url: this.url,\n        get: function( meta_id, args )        { return resource.call(this, 'GET', meta_id, args); }.bind(this),\n        post: function( meta_id, data )       { return resource.call(this, 'POST', meta_id, {}, data); }.bind(this),\n            patch: function( meta_id, data )      { return resource.call(this, 'PATCH', meta_id, {}, data); }.bind(this),\n                delete: function( meta_id, args )     { return resource.call(this, 'DELETE', meta_id, args); }.bind(this)\n};\n*/\n    \n    \n    \n    return {\n        "url": this.url,\n        "get": function( meta_id, args )        { return resource.call(this, 'GET', meta_id, args); },\n        "post": function( meta_id, data )       { return resource.call(this, 'POST', meta_id, {}, data); },\n        "patch": function( meta_id, data )      { return resource.call(this, 'PATCH', meta_id, {}, data); },\n        "delete": function( meta_id, args )     { return resource.call(this, 'DELETE', meta_id, args); }\n    };\n}\n\n\n/*--------------------------------- * Database * ---------------------------------*/\nAQ.Database = function( url, settings ) {\n    this.settings = settings;\n\n    // Not sure which name is better\n    this.endpoint = this.connection = new Endpoint(url);\n    this.query_string = query_options;\n};\nAQ.Database.prototype.constructor = AQ.Database;\nAQ.Database.prototype.schema = function( name ) { return new AQ.Schema(this, name); };\n\n/*--------------------------------- * Schema * ---------------------------------*/\nAQ.Schema = function( database, name ) {\n    this.database = database;\n    this.name = name;\n    this.id = { name: this.name };\n};\nAQ.Schema.prototype.constructor = AQ.Schema;\nAQ.Schema.prototype.relation = function( name )         { return new AQ.Relation(this, name); };\nAQ.Schema.prototype.table = function( name )            { return new AQ.Table(this, name); };\nAQ.Schema.prototype.view = function( name )             { return new AQ.View(this, name); };\nAQ.Schema.prototype.function = function( identifier, args, options )   {\n\n    // Function identifier (name and parameter list)\n    if (typeof identifier == 'object') {\n        var name = identifier.name;\n        var parameter_type_list = identifier.parameters;\n    }\n    // Selecting a function without specifying the parameters\n    else {\n        var name = identifier;\n    }\n\n    options = options || {};\n\n    // Arguments\n    options.args = {};\n\n    // `args = undefined` will pass no arguments into the server-side function\n    if (typeof args != 'undefined') {\n\n        // some_function?args={ kwargs: {} } -- Key/value object\n        if (!(args instanceof Array) && args instanceof Object) {\n            options.args.kwargs = args;\n        }\n        // some_function?args={ vals: [] } -- Array\n        else {\n            if (!(args instanceof Array)) {\n                // Regular value is placed into array\n                args = [ args ];\n            }\n            options.args.vals = args;\n        }\n    }\n\n    var fn = new AQ.Function(this, name, parameter_type_list);\n\n    return this.database.endpoint.get(fn, options)\n    .then(function(response) {\n\n        if (!response) {\n            throw 'Empty response';\n        }\n        else if (!response.result.length) {\n            throw 'Result set empty';\n        }\n        if(response.result.length > 1) {\n            return new AQ.FunctionResultSet(fn, response);\n        }\n        return new AQ.FunctionResult(fn, response);\n\n    }.bind(this)).catch(function(err) {\n        throw 'Function call request failed: ' + err;\n    });\n};\n\n/*--------------------------------- * Relation * ---------------------------------*/\nAQ.Relation = function( schema, name ) {\n    this.schema = schema;\n    this.name = name;\n    this.id = { schema_id: this.schema.id, name: this.name };\n};\nAQ.Relation.prototype.constructor = AQ.Relation;\nAQ.Relation.prototype.to_url = function( id_only ) {\n    return id_only ? '/relation/' + this.schema.name + '/' + this.name :\n    this.schema.database.endpoint.url + '/relation/' + this.schema.name + '/' + this.name;\n};\nAQ.Relation.prototype.column = function( name ) {\n    return new AQ.Column(this, name);\n};\nAQ.Relation.prototype.rows = function( options ) {\n\n    return this.schema.database.endpoint.get(this, options)\n    .then(function(rows) {\n\n        if (rows == null) {\n            throw 'Empty response';\n        }/*\n                else if (rows.result.length < 1) {\n                    throw 'No rows returned';\n                }*/\n        return new AQ.Rowset(this, rows, options);\n\n    }.bind(this)).catch(function(err) {\n        throw 'Rows request failed: ' + err;\n    });\n};\nAQ.Relation.prototype.row = function() {\n\n    // Multiple different ways to call 'row' function\n\n    // 1. Calling with Options object\n    if (typeof arguments[0] == 'object') {\n\n        var obj = arguments[0];\n        var args = arguments[1] || {};\n\n        // AQ.Relation.row({ where: { column_name: 'column_name', op: '=', value: 'value' } })\n        // Maybe it should be this one: AQ.Relation.row({ where: { column_name: value } })\n        if (typeof obj.where != 'undefined') {\n            args.where = obj.where;\n        }\n        // AQ.Relation.row({ column_name: 'column_name', op: '=', value: 'value' })\n        // Maybe it should be this one: AQ.Relation.row({ column_name: value })\n        else {\n            args.where = obj;\n        }\n\n    }\n    // 2. Calling with column_name and value\n    else if (typeof arguments[0] == 'string') {\n\n        // AQ.Relation.row(column_name, value [, options_obj])\n        var name = arguments[0];\n        var value = arguments[1];\n        var args = arguments[2] || {};\n\n        args.where = { name: name, op: '=', value: value };\n\n    }\n    // 3. Calling AQ.Relation.row() without arguments\n    else {\n        var args = {};\n    }\n\n    return this.schema.database.endpoint.get(this, args)\n    .then(function(row) {\n\n        if (row == null) {\n            throw 'Empty response';\n        }\n        else if (row.result.length == 0) {\n            throw 'No row returned';\n        }\n        else if (row.result.length > 1) {\n            throw 'Multiple rows returned';\n        }\n        return new AQ.Row(this, row);\n\n    }.bind(this)).catch(function(err) {\n        throw 'Row request failed: ' + err;\n    });\n};\n\n/*--------------------------------- * Table * ---------------------------------*/\nAQ.Table = function( schema, name ) {\n    this.schema = schema;\n    this.name = name;\n    this.id = { schema_id: this.schema.id, name: this.name };\n};\nAQ.Table.prototype = Object.create(AQ.Relation.prototype);\nAQ.Table.prototype.constructor = AQ.Table;\nAQ.Table.prototype.insert = function( data ) {\n\n    if (typeof data == 'undefined') {\n        // table.insert({}) is equivalent to table.insert()\n        // both will insert default values\n        data = {};\n    }\n\n    // Return inserted row promise\n    return this.schema.database.endpoint.patch(this, data)\n    .then(function(inserted_row) {\n\n        if (inserted_row == null) {\n            throw 'Empty response';\n        }\n        if (typeof data.length != 'undefined' && data.length > 1) {\n            return new AQ.Rowset(this, inserted_row, null);\n        }\n        return new AQ.Row(this, inserted_row);\n\n    }.bind(this)).catch(function(err) {\n        throw 'Insert failed: ' + err;\n    });\n\n};\n\n/*--------------------------------- * View * ---------------------------------*/\nAQ.View = function( schema, name ) {\n    this.schema = schema;\n    this.name = name;\n    this.id = { schema_id: this.schema.id, name: this.name };\n};\nAQ.View.prototype = Object.create(AQ.Relation.prototype);\nAQ.View.prototype.constructor = AQ.View;\n\n/*--------------------------------- * Rowset * ---------------------------------*/\nAQ.Rowset = function( relation, response, server_arguments ) {\n    this.relation = relation;\n    this.schema = relation.schema;\n    this.columns = response.columns || null;\n    this.pk_column_name = response.pk || null;\n    this.rows = response.result;\n    this.length = response.result.length;\n    this.server_arguments = server_arguments || {};\n};\nAQ.Rowset.prototype.constructor = AQ.Rowset;\nAQ.Rowset.prototype.map = function(fn) {\n    return this.rows.map(function(row) {\n        return new AQ.Row(this.relation, { columns: this.columns, pk: this.pk_column_name, result: [ row ] });\n    }.bind(this)).map(fn);\n};\nAQ.Rowset.prototype.forEach = function(fn) {\n    return this.rows.map(function(row) {\n        return new AQ.Row(this.relation, { columns: this.columns, pk: this.pk_column_name, result: [ row ] });\n    }.bind(this)).forEach(fn);\n};\nAQ.Rowset.prototype.reload = function() {\n    return this.relation.rows(this.server_arguments);\n};\n\n/**\n     * Call AQ.Rowset.where with (where_obj) or use shorthand notation (field, value) - filter results programmatically\n     *\n     * @param {Object} where_obj\n     * @param {[Boolean]} return_first\n     * @param {[Boolean]} async\n     *\n     * OR\n     *\n     * @param {String} field\n     * @param {Any} value\n     * @param {[Boolean]} return_first\n     * @param {[Boolean]} async\n     *\n     * @returns {Promise}\n     */\nAQ.Rowset.prototype.where = function() {\n\n    var first = false, async = true, where_obj = {};\n    if (typeof arguments[0] == 'object') {\n        // AQ.Rowset.where(where_obj [, return_first] [, async]);\n        where_obj = arguments[0];\n        var field = where_obj.field;\n        var value = where_obj.value;\n        if (arguments.length > 1) first = arguments[1];\n        if (arguments.length > 2) async = arguments[2];\n\n    }\n    else if (typeof arguments[0] == 'string' && arguments.length > 1) {\n        // AQ.Rowset.where(field, value [, return_first] [, async]);\n        var field = arguments[0];\n        var value = arguments[1];\n        if (arguments.length > 2) first = arguments[2];\n        if (arguments.length > 3) async = arguments[3];\n    }\n\n    return new Promise(function(resolve, reject) {\n\n        // TODO lots of logic here\n        // The new rowset that is returned must be in the same format as the response from the server\n\n        if (first) {\n            for (var i = 0; i < this.rows.length; i++) {\n                if (this.rows[i].row[field] == value) {\n                    resolve(new AQ.Row(this.relation, { columns: this.columns, result: [ this.rows[i] ] }));\n                }\n            }\n            reject('could not find ' + field + ' ' + value);\n        }\n        else {\n            var return_rowset = [];\n            for (var i = 0; i < this.rows.length; i++) {\n                if (this.rows[i].row[field] == value) {\n                    return_rowset.push(this.rows[i]);\n                }\n            }\n            resolve(new AQ.Rowset(this.relation, { columns: this.columns, result: return_rowset }));\n        }\n\n\n        // 2\n\n        // maybe we don't need to search the entire row and instead we return the first item found\n        /*\n            var new_rowset = _.filter(this.rows, function(el) {\n                //return AQ.equals.call(this, el[field], val);\n            });\n*/\n        if (new_rowset.length == 1) {\n            return new AQ.Row(this.relation, new_rowset);\n        }\n        else if (new_rowset.length > 1) {\n            throw 'Multiple Rows Returned';\n        }\n\n        // if row does not exist\n        return null;\n\n    }.bind(this));\n\n};\nAQ.Rowset.prototype.order_by = function( column, direction ) {\n    /*\n        var ordered = _.sortBy(this.rows, function(el) {\n            return el.row[column];\n        });\n*/\n    if (direction !== 'asc') {\n        ordered.reverse();\n    }\n    return new AQ.Rowset(this.relation, { columns: this.columns, result: ordered });\n};\nAQ.Rowset.prototype.limit = function( lim ) {\n    if (lim <= 0) {\n        throw 'Bad limit';\n    }\n    return new AQ.Rowset(this.relation, { columns: this.columns, result: this.rows.slice(0, lim) });\n};\nAQ.Rowset.prototype.related_rows = function( self_column_name, related_relation_name, related_column_name, options ) {\n\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.relation.schema.database;\n\n    var values = this.map(function(row) {\n        return row.get(self_column_name);\n    });\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: 'in',\n        value: values\n    });\n\n\n    return db.schema(schema_name).relation(relation_name).rows(options);\n};\nAQ.Rowset.prototype.related_row = function( self_column_name, related_relation_name, related_column_name, options ) {\n\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.relation.schema.database;\n\n    var values = this.map(function(row) {\n        return row.get(self_column_name);\n    });\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: 'in',\n        value: values\n    });\n\n    return db.schema(schema_name).relation(relation_name).row(options);\n\n};\n\n/*--------------------------------- * Row * ---------------------------------*/\nAQ.Row = function( relation, response ) {\n    this.relation = relation;\n    this.schema = relation.schema;\n    this.row_data = response.result[0].row;\n\n    this.cached_fields = {};\n    this.columns = response.columns || null;\n    this.pk_column_name = null;\n    this.pk_value = null;\n    this.id = null;\n    this.to_url = function() {\n        console.error('You must call a row with "meta_data: true" in order to use the to_url function');\n        throw 'Datum.js: Programming Error';\n    };\n\n    if (typeof response.pk != 'undefined') {\n        this.pk_column_name = response.pk;\n        this.pk_value = this.get(this.pk_column_name);\n        // this.id = {"pk_column_id":{"relation_id":{"schema_id":{"name":this.schema.name},"name":this.relation.name},"name":this.pk_column_name},"pk_value": this.pk_value}\n        this.id = {\n            pk_column_id: {\n                relation_id: this.relation.id,\n                name: this.pk_column_name\n            },\n            pk_value: this.pk_value\n        };\n\n        this.to_url = function( id_only ) {\n            return id_only ? '/row/' + this.relation.schema.name + '/' + this.relation.name + '/' + /*JSON.stringify(this.pk_value)*/ this.pk_value :\n            this.relation.schema.database.endpoint.url + '/row/' + this.relation.schema.name + '/' + this.relation.name + '/' + /*JSON.stringify(this.pk_value)*/ this.pk_value;\n        };\n\n    }\n};\nAQ.Row.prototype = {\n    constructor: AQ.Row,\n    get: function( name )           { return this.row_data[name]; },\n    set: function( name, value )    { this.row_data[name] = value; return this; },\n    to_string: function()           { return JSON.stringify(this.row_data); },\n    clone: function()               { return new AQ.Row(this.relation, { columns: this.columns, pk: this.pk_column_name, result: [{ row: this.row_data }]}); },\n    field: function( name ) {\n        if (typeof this.cached_fields[name] == 'undefined') {\n            this.cached_fields[name] = new AQ.Field(this, name, name === this.pk_column_name);\n        }\n        return this.cached_fields[name];\n    },\n    fields: function() {\n        if (this.columns != null) {\n            return this.columns.map(function(c) {\n                return this.field(c.name);\n            }.bind(this));\n        }\n        return null;\n    }\n};\nAQ.Row.prototype.update = function() {\n    return this.relation.schema.database.endpoint.patch(this, this.row_data)\n    .then(function(response) {\n\n        if(response == null) {\n            throw 'Empty response';\n        }\n        return this;\n\n    }.bind(this)).catch(function(err) {\n        throw 'Update failed: ' + err;\n    });\n};\nAQ.Row.prototype.delete = function() { \n    return this.relation.schema.database.endpoint.delete(this)\n    .then(function(response) {\n\n        if(response == null) {\n            throw 'Empty response';\n        }\n\n    }).catch(function(err) {\n        throw 'Delete failed: ' + err;\n    });\n};\nAQ.Row.prototype.related_rows = function( self_column_name, related_relation_name, related_column_name, options )  {\n\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.relation.schema.database;\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: '=',\n        value: this.get(self_column_name)\n    });\n\n    return db.schema(schema_name).relation(relation_name).rows(options);\n};\nAQ.Row.prototype.related_row = function( self_column_name, related_relation_name, related_column_name, options ) {\n\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.relation.schema.database;\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: '=',\n        value: this.get(self_column_name)\n    });\n\n    return db.schema(schema_name).relation(relation_name).row(options);\n};\n\n/*--------------------------------- * Column * ---------------------------------*/\nAQ.Column = function( relation, name ) {\n    this.relation = relation;\n    this.name = name;\n    this.id = { relation_id: relation.id, name: name };\n};\nAQ.Column.prototype.constructor = AQ.Column;\n\n/*--------------------------------- * Field * ---------------------------------*/\nAQ.Field = function( row, name, pk ) {\n    this.row = row;\n    this.column = new AQ.Column(row.relation, name);\n    this.is_primary_key = pk;\n    this.name = name;\n    this.value = row.get(name);\n    this.id = { row_id: this.row.id, column_id: this.column.id };\n    this.to_url = function( id_only ) {\n        if (this.row.pk_value == null) {\n            console.error('You must call a row with "meta_data: true" in order to use the to_url function');\n            throw 'Datum.js: Programming Error';\n        }\n        return id_only ? '/field/' + this.row.relation.schema.name + '/' + this.row.relation.name + '/' + /*JSON.stringify(this.row.pk_value)*/ this.row.pk_value + '/' + this.column.name :\n        this.row.relation.schema.database.endpoint.url + '/field/' + this.row.relation.schema.name + '/' + this.row.relation.name + '/' + /*JSON.stringify(this.row.pk_value)*/ this.row.pk_value + '/' + this.column.name;\n    };\n};\nAQ.Field.prototype = {\n    constructor: AQ.Field,\n    get: function()          { return this.row.get(this.name); },\n    set: function(value)     { this.value = value; return this.row.set(this.name, value); },\n    update: function()       { return this.row.update(); } // TODO: This is wrong\n};\n\n/*--------------------------------- * Function * ---------------------------------*/\nAQ.Function = function( schema, name, args ) {\n    this.schema = schema;\n    this.name = name;\n\n    if(args instanceof Array) {\n        this.args = '{' + args.join(',') + '}';\n    }\n    else {\n        this.args = args;\n    }\n\n    this.id = { schema_id: this.schema.id, name: this.name, args: this.args };\n    this.to_url = function( id_only ) {\n        var base_url = id_only ? '' : this.schema.database.endpoint.url;\n        if (typeof this.args != 'undefined') {\n            return base_url + '/function/' + this.schema.name + '/' + this.name + '/' + this.args;\n        }\n        return base_url + '/function/' + this.schema.name + '/' + this.name;\n    };\n};\nAQ.Function.prototype.constructor = AQ.Function;\n\n/*--------------------------------- * Function Result * ---------------------------------*/\nAQ.FunctionResult = function( fn, response ) {\n    this.function = fn;\n    this.schema = fn.schema;\n    this.row_data = response.result[0].row;\n    this.rows = response.result;\n    this.columns = response.columns;\n};\nAQ.FunctionResult.prototype = {\n    constructor: AQ.FunctionResult,\n    get: function( name )           { return this.row_data[name]; },\n    to_string: function()           { return JSON.stringify(this.row_data); }\n};\nAQ.FunctionResult.prototype.map = function(fn) {\n    return this.rows.map(function(row) {\n        return new AQ.FunctionResult(this.function, { columns: this.columns, result: [ row ] });\n    }.bind(this)).map(fn);\n};\nAQ.FunctionResult.prototype.forEach = function(fn) {\n    return this.rows.map(function(row) {\n        return new AQ.FunctionResult(this.function, { columns: this.columns, result: [ row ] });\n    }.bind(this)).forEach(fn);\n};\nAQ.FunctionResult.prototype.related_rows = function( self_column_name, related_relation_name, related_column_name, options )  {\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.function.schema.database;\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: '=',\n        value: this.get(self_column_name)\n    });\n\n    return db.schema(schema_name).relation(relation_name).rows(options);\n};\nAQ.FunctionResult.prototype.related_row = function( self_column_name, related_relation_name, related_column_name, options ) {\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.function.schema.database;\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: '=',\n        value: this.get(self_column_name)\n    });\n\n    return db.schema(schema_name).relation(relation_name).row(options);\n};\n\n/*--------------------------------- * Function Result Set * ---------------------------------*/\nAQ.FunctionResultSet = function( fn, response ) {\n    this.function = fn;\n    this.schema = fn.schema;\n    this.columns = response.columns;\n    this.rows = response.result;\n};\nAQ.FunctionResultSet.prototype.constructor = AQ.FunctionResultSet;\nAQ.FunctionResultSet.prototype.map = function(fn) {\n    return this.rows.map(function(row) {\n        return new AQ.FunctionResult(this.function, { columns: this.columns, result: [ row ] });\n    }.bind(this)).map(fn);\n};\nAQ.FunctionResultSet.prototype.forEach = function(fn) {\n    return this.rows.map(function(row) {\n        return new AQ.FunctionResult(this.function, { columns: this.columns, result: [ row ] });\n    }.bind(this)).forEach(fn);\n};\nAQ.FunctionResultSet.prototype.related_rows = function( self_column_name, related_relation_name, related_column_name, options ) {\n\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.function.schema.database;\n\n    var values = this.map(function(row) {\n        return row.get(self_column_name);\n    });\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: 'in',\n        value: values\n    });\n\n    return db.schema(schema_name).relation(relation_name).rows(options);\n};\nAQ.FunctionResultSet.prototype.related_row = function( self_column_name, related_relation_name, related_column_name, options ) {\n\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.function.schema.database;\n\n    var values = this.map(function(row) {\n        return row.get(self_column_name);\n    });\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: 'in',\n        value: values\n    });\n\n    return db.schema(schema_name).relation(relation_name).row(options);\n\n};\n\n\n\nvar endpoint = new AQ.Database();\n
\\x63bf33fe51bbd62f4b38ff3dea918cae934af53ccb727450b5ce17be57e3679e	/widget.js
\\x699ec770fcc3d1a0e97410d0e7567abf5f1aeec49da979b087d4ff3ac8d42850	c8b9c599-9d1b-417a-8e29-43080bb7dd88
\\x6b85584d52dc23b2eba2c85475644769bf9395f11f6e9f5d0d33f66575561afb	/*******************************************************************************\n* Widget.js\n*\n* Created by Aquameta Labs, an open source company in Portland Oregon, USA.\n* Project: http://aquameta.com/\n******************************************************************************/\ndefine(['/doT.js', '/jQuery.min.js', '/datum.js'], function(doT, $, AQ, undefined) {\n\n    'use strict';\n\n    doT.templateSettings.strip = false;\n\n    var widget_promises = {};\n    var containers = {};\n    var namespaces = {};\n\n\n    AQ.Widget = {};\n\n\n    AQ.Widget.widget = function ( selector, input, extra ) {\n\n        if (!selector || typeof selector != 'string') {\n            throw "Widget - Selector argument is invalid or missing";\n        }\n\n        // Same namespace as calling widget, instead of global '' namespace\n        var default_namespace = (typeof this != 'undefined' && typeof this.namespace != 'undefined') ? this.namespace : '';\n\n        var is_semantic_dsl_lookup = selector.indexOf('/') != -1;\n\n        // For semantic lookup\n        // * selector is 'semantics/purpose/default_bundle'\n        // * input is AQ.* object\n        // * extra is {} to send to widget\n        if (is_semantic_dsl_lookup) {\n\n            if (!input) {\n                throw "Semantics requires an AQ.* to be passed in";\n            }\n\n            var context = extra || {};\n            var semantics = selector.split('/');\n            var args_object = {};\n\n            // If input is a promise (that will resolve as a Rowset or a Row), resolve it first\n            if (input instanceof Promise) {\n\n                var url_id;\n                var widget_getter = input.then(function(input) {\n\n                    context.datum = input;\n\n                    // These are the same for both Rowset and Row\n                    var endpoint = input.relation.schema.database;\n                    var fn = 'relation_widget';\n                    var type = 'meta.relation_id';\n                    args_object.relation_id = input.relation.id;\n\n                    if (input instanceof AQ.Rowset) {\n                        context.rows = input;\n                        url_id = input.relation.to_url(true);\n                    }\n                    else if (input instanceof AQ.Row) {\n                        context.row = input;\n                        url_id = input.to_url(true);\n                    }\n                    args_object.widget_purpose = semantics[1];\n                    args_object.default_bundle = semantics.length >= 3 ? semantics[2] : 'org.aquameta.core.semantics';\n                    \n                    return endpoint.schema('semantics').function({\n                        name: fn,\n                        parameters: [type,'text','text']\n                    }, args_object, { use_cache: true, meta_data: false });\n\n                });\n\n            }\n            // Else, check which type it is\n            else {\n\n                context.datum = input;\n\n                if (input instanceof AQ.Relation || input instanceof AQ.Table || input instanceof AQ.View) {\n                    var endpoint = input.schema.database;\n                    var fn = 'relation_widget';\n                    var type = 'meta.relation_id';\n                    args_object.relation_id = input.id;\n                    var url_id = input.to_url(true);\n                    context.relation = input;\n                }\n                else if (input instanceof AQ.Row) {\n                    var endpoint = input.relation.schema.database;\n                    var fn = 'relation_widget';\n                    var type = 'meta.relation_id';\n                    args_object.relation_id = input.relation.id;\n                    var url_id = input.to_url(true);\n                    context.row = input;\n                }\n                else if (input instanceof AQ.Rowset) {\n                    var endpoint = input.relation.schema.database;\n                    var fn = 'relation_widget';\n                    var type = 'meta.relation_id';\n                    args_object.relation_id = input.relation.id;\n                    var url_id = input.relation.to_url(true);\n                    context.rows = input;\n                }\n                else if (input instanceof AQ.Column) {\n                    var endpoint = input.relation.schema.database;\n                    var fn = 'column_widget';\n                    var type = 'meta.column_id';\n                    args_object.column_id = input.id;\n                    var url_id = input.relation.to_url(true);\n                    context.column = input;\n                }\n                else if (input instanceof AQ.Field) {\n                    var endpoint = input.row.relation.schema.database;\n                    var fn = 'column_widget';\n                    var type = 'meta.column_id';\n                    args_object.column_id = input.column.id;\n                    var url_id = input.to_url(true);\n                    context.field = input;\n                }\n                \n                args_object.widget_purpose = semantics[1];\n                args_object.default_bundle = semantics.length >= 3 ? semantics[2] : 'org.aquameta.core.semantics';\n                \n                var widget_getter = endpoint.schema('semantics').function({\n                    name: fn,\n                    parameters: [type,'text','text']\n                }, args_object, { use_cache: true, meta_data: false });\n            }\n\n            // Go get this widget - retrieve_promises don't change for calls to the same widget - they are cached by the widget name\n            var widget_retrieve_promise = retrieve(widget_getter, {\n                semantic_selector: selector,\n                url_id: url_id\n            });\n\n        }\n\n        // For regular widget lookup\n        // * selector is '[namespace:]widget_name'\n        // * input is {} to send to widget\n        // * extra is ignored\n        else {\n\n            //var context = typeof input != 'undefined' ? Object.assign({}, input) : {};\n            var context = input || {};\n\n            var name_parts = selector.split(':');\n\n            if (name_parts.length == 1) {\n                // Default namespace lookup\n                context.namespace = default_namespace;\n                context.name = name_parts[0];\n            }\n            else {\n                // Namespaced lookup\n                context.namespace = name_parts[0];\n                context.name = name_parts[1];\n                context.bundle_name = namespaces[context.namespace].bundle_name;\n            }\n\n            // Namespace not found\n            if (!(context.namespace in namespaces)) {\n                throw 'Widget namespace "'+context.namespace+'" has not been imported - Call AQ.Widget.import( bundle_name, namespace, endpoint ) to import bundled widgets to a namespace';\n            }\n    \n            var widget_getter = namespaces[context.namespace].endpoint.schema('widget').function('bundled_widget',\n                [ namespaces[context.namespace].bundle_name, context.name ], {\n                    use_cache: true,\n                    meta_data: false\n                });\n\n            // Go get this widget - retrieve_promises don't change for calls to the same widget - they are cached by the widget name\n            var widget_retrieve_promise = retrieve(widget_getter, {\n                namespace: context.namespace,\n                name: context.name\n            });\n\n        }\n\n        context.id = AQ.uuid();\n\n        // Setup default namespace for child widget\n        context.widget = AQ.Widget.widget.bind({ namespace: context.namespace });\n        context.widget.sync = AQ.Widget.widget.sync;\n\n        // Prepare and render the widget - each prepare_promise is unique because inputs are different - they are cached by the unique uuid created for the context\n        widget_promises[context.id] = prepare(widget_retrieve_promise, context);\n\n        // Return script that calls swap\n        return '<script id="widget-stub_' + context.id  + '" data-widget_id="' + context.id + '">' +\n                  'AQ.Widget.swap($("#widget-stub_' +  context.id  + '"), "' + context.id + '");'  + \n               '</script>';\n\n    }\n\n\n\n    /* Import a bundle name to a local namespace */\n    AQ.Widget.import = function( bundle_name, namespace, endpoint ) {\n\n        namespaces[namespace] = {\n            endpoint: endpoint,\n            bundle_name: bundle_name\n        };\n\n    };\n\n\n    /* Return an array bundle of imported bundle names */\n    AQ.Widget.bundles = function() {\n        return Object.keys(namespaces).map(function(key) {\n            return namespaces[key].bundle_name;\n        });\n    };\n\n\n\n    /* Find the bundle that was imported to this namespace */\n    AQ.Widget.bundle = function( namespace ) {\n        return namespaces[namespace].bundle_name;\n    };\n\n\n\n    /* Find the namespace that uses this bundle */\n    AQ.Widget.namespace = function( bundle_name ) {\n        return Object.keys(namespaces).find(function(namespace) {\n            return namespaces[namespace].bundle_name == bundle_name;\n        });\n    };\n\n\n\n    function retrieve( widget_getter, selector ) {\n\n        if ('semantic_selector' in selector) {\n            var semantic_lookup = true;\n        }\n\n        return widget_getter.then(function(row) {\n\n            // Get all related widget data\n            return Promise.all([\n                row,/* VIEWSIGNORE\n                row.related_rows('id', 'widget.input', 'widget_id', { use_cache: true, meta_data: true, events: false }).catch(function(){ return; }), \n                row.related_rows('id', 'widget.widget_view', 'widget_id', { use_cache: true, meta_data: true, events: false })\n                    .then(function(widget_views) {\n\n                        var db = row.schema.database;\n                        return widget_views.map(function(widget_view) {\n                            var view_id = widget_view.get('view_id');\n                            return db.schema(view_id.schema_id.name).view(view_id.name);\n                        });\n\n                    }).catch(function(err) { return; }), */\n                row.related_rows('id', 'widget.widget_dependency_js', 'widget_id', { use_cache: true, meta_data: true, events: false })\n                    .then(function(deps_js) {\n\n                        if (!deps_js.length) { return; }\n                        return deps_js.related_rows('dependency_js_id', 'widget.dependency_js', 'id', { use_cache: true, meta_data: true, events: false });\n\n                    }).then(function(deps) {\n\n                        return Promise.all(\n\n                            deps.map(function(dep) {\n                                return System.import(dep.field('content').to_url()).then(function(dep_module) {\n                                    //console.log('my module', dep_module);\n                                    \n                                    return {\n                                        url: dep.field('content').to_url(),\n                                        name: dep.get('variable') || 'non_amd_module',\n                                        /* TODO: This value thing is a hack. For some reason, jwerty doesn't load properly here */\n                                        value: typeof dep_module == 'object' ? dep_module[Object.keys(dep_module)[0]] : dep_module\n                                        //value: dep_module\n                                    };\n                                });\n                            })\n                        );\n\n                    }).catch(function() { return; })\n            ]);\n        }).catch(function(err) {\n            if (semantic_lookup) {\n                throw 'Widget not found from semantic lookup with ' + selector.semantic_selector + ' on ' + selector.url_id;\n            }\n            else {\n                throw 'Widget does not exist, ' + selector.namespace + ':' + selector.name;\n            }\n        });\n    };\n\n\n\n    function prepare( retrieve_promise, context ) {\n\n        return retrieve_promise.then(function( widget_data ) {\n\n            //console.log('retrieve_promise resolved', widget_data);\n\t\t\tvar [ widget_row,  /* inputs, VIEWSIGNORE views, */ deps_js ] = widget_data;\n\n            context.name = widget_row.get('name');\n\n            var xinput = context;\n            context = Object.assign({\n                    db: widget_row.schema.database,\n                    endpoint: widget_row.schema.database,\n                    input: {},\n                    xinput: xinput\n                }, context);\n\n            delete context.xinput.id;\n            delete context.xinput.name;\n            delete context.xinput.namespace;\n            delete context.xinput.widget;\n\n            // Process inputs\n            if (typeof inputs != 'undefined') {\n\n                inputs.forEach(function(input) {\n                    var input_name = input.get('name');\n\n                    if (typeof context[input_name] == 'undefined') {\n                        if (input.get('optional')) {\n                            var default_code = input.get('default_value');\n                            try {\n\n                                if (default_code) {\n                                    context[input_name] = eval('(' + default_code + ')');\n                                }\n                                else {\n                                    context[input_name] =  undefined;\n                                }\n\n                            }\n                            catch (e) {\n                                error(e, context.name, "Widget default eval failure: " + default_code);\n                                /*\n                                console.error("Widget default eval failure", default_code);\n                                throw e;\n                                */\n                            }\n\n                        }\n                        else {\n                            error('Missing required input ' + input_name, context.name, 'Inputs');\n                        }\n                    }\n                    context.input[input_name] = context[input_name];\n                    delete context.xinput[input_name];\n                });\n            }\n\n            // Load views into context\n            if (typeof views != 'undefined') {\n                views.forEach(function(view) {\n                    context[view.schema.name + '_' + view.name] = view;\n                });\n            }\n\n            var rendered_widget = render(widget_row, context);\n            var post_js_function = create_post_js_function(widget_row, context, deps_js);\n\n            // Return rendered widget and post_js function\n            return {\n                html: rendered_widget,\n                widget_id: context.id,\n                widget_name: context.name,\n                post_js: post_js_function\n            };\n\n        });\n    };\n\n\n\n    function render( widget_row, context ) {\n\n        // Create html template\n        var html_template = doT.template(widget_row.get('html') || '');\n\n        // Compile html template\n        try {\n            var html = html_template(context);\n        } catch(e) {\n            error(e, context.name, 'HTML');\n        }\n\n        // Render html\n        try {\n            var rendered = $(html).attr('data-widget', context.name)\n                .attr('data-widget_id', context.id)\n                .attr('data-bundle_alias', context.namespace)\n                .attr('data-bundle_name', context.bundle_name)\n                .attr('data-widget_row_id', widget_row.get('id'))\n                .data('help', widget_row.get('help'));\n        } catch(e) {\n            error(e, context.name, 'HTML (adding data-* attributes)');\n        }\n                                \n        // If CSS exists and has not yet been applied\n        if (widget_row.get('css') != null && $('style[data-widget="' + context.name + '"]').length == 0) {\n\n            // Create css template\n            var css_template = doT.template(widget_row.get('css') || '');\n\n            // Try to run css template\n            try {\n                var css = css_template(context);\n            } catch(e) {\n                error(e, context.name, 'CSS');\n            }\n\n            // Add css to dom\n            $('<style type="text/css" data-widget="' + context.name + '">' + css + '</style>').appendTo(document.head);\n        }\n\n        return rendered;\n    };\n\n\n\n    function create_post_js_function( widget_row, context, deps_js ) {\n\n        var context_keys = Object.keys(context).sort();\n\n        // Get context values\n        var context_vals = context_keys.map(function(key) {\n            return context[key];\n        });\n\n        // Dependency names and values\n        var dep_names = [],\n            dep_values = [];\n        if (deps_js != null) {\n            deps_js.forEach(function(dep_js) {\n                dep_names.push(dep_js.name);\n                dep_values.push(dep_js.value);\n            });\n        }\n\n        try {\n            /*\n            * Creating an script that looks like this\n            * function(dep1_name, dep2_name, ...) {\n            *   function(input1, input2) {\n            *       post_js\n            *   }.apply(this.this.context_vals);\n            * }.apply(this, this.dep_vals);\n            */\n            var post_js = Function(\n                '(function(' + dep_names.join(',') + ') { \\n' +\n                    '(function(' + context_keys.join(',') + ') { \\n' +\n                        'var w = $("#"+id);\\n\\n' +\n                        widget_row.get('post_js') +\n                        '\\n//# sourceURL=' + widget_row.get('id') + '/' + widget_row.get('name') + '/post_js\\n' +\n                    '}).apply(this, this.context_vals);' +\n                '}).apply(this, this.dep_values);'\n            ).bind({ context_vals: context_vals, dep_values: dep_values });\n        }\n        catch(e) {\n            error(e, widget_row.get('name'), 'Creating post_js function');\n        }\n\n        return post_js;\n\n    };\n\n\n    // detect svg widgets by tag name.  might be better to check the dom to see if we're inside an svg tag?\n    AQ.Widget.is_svg = function( e ) {\n        var svg_tags = ['circle','rect','polygon','g']; // TODO: add more, or change approach?\n        for (var i=0;i<svg_tags.length;i++) {\n            if (e.tagName.toUpperCase() == svg_tags[i].toUpperCase()) {\n                // console.log('svg  widget: ' + svg_tags[i]);\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n\n    AQ.Widget.swap = function( $element, id ) {\n        widget_promises[id].then(function(rendered_widget) {\n\n            // Replace stub\n            // special case for svg elements - http://stackoverflow.com/questions/3642035/jquerys-append-not-working-with-svg-element\n            if (AQ.Widget.is_svg(rendered_widget.html[0])) { // TODO: is there ever a case where there is more than one element in this array?\n                var div = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');\n                div.innerHTML= '<svg xmlns="http://www.w3.org/2000/svg">'+rendered_widget.html[0].outerHTML+'</svg>';\n\n                var frag= document.createDocumentFragment();\n                while (div.firstChild.firstChild)\n                    frag.appendChild(div.firstChild.firstChild);\n\n                $element.replaceWith(frag);\n            }\n            else $element.replaceWith(rendered_widget.html);\n\n            // Run post_js - or this may have to be done with a script tag appended to the widget\n            try {\n                rendered_widget.post_js();\n            }\n            catch(e) {\n                error(e, rendered_widget.widget_name, 'Running post_js function');\n            }\n\n            var w = $('#' + rendered_widget.widget_id);\n\n            // notify the world that a widget has loaded.  debugger uses this to detect widget tree changes\n            w.trigger('widget_loaded', { widget: w });\n\n            // Delete prepeared_promise\n            delete widget_promises[id];\n\n        }).catch(function(error) {\n            //console.error('Widget swap failed - ', error);\n            console.error(error);\n            // Remove stub\n            $element.remove();\n            // Delete promise\n            delete widget_promises[id];\n        });\n    };\n\n\n\n    function error( err, widget_name, step_name ) {\n        console.error("widget('" + widget_name + "', ...) " + step_name + " failed!");\n        //window.setTimeout(function() { throw err; }, 100);\n        throw err;\n    }\n\n\n\n    AQ.Widget.sync = function(rowset_promise, container, widget_maker, handlers) {\n\n        if(handlers === undefined) {\n            handlers = {};\n        }\n\n        if (widget_maker === undefined) {\n            throw 'widget.sync missing widget_maker argument';\n        }\n\n        if (container.length < 1) {\n            throw 'widget.sync failed: The specified container is empty or not found';\n            return;\n        }\n\n        if (container.length > 1) {\n            throw 'widget.sync failed: The specified container contains multiple elements';\n            return;\n        }\n\n        if (!container instanceof jQuery) {\n            throw 'widget.sync failed: The specified container is not a jQuery object';\n            return;\n        }\n\n        if (typeof rowset_promise == 'undefined' ||\n            (!(rowset_promise instanceof Promise) && !(rowset_promise instanceof AQ.Rowset) && !(rowset_promise instanceof AQ.FunctionResultSet))) {\n            throw 'widget.sync failed: rowset_promise must be a "thenable" promise or a resolved AQ.Rowset or a resolved AQ.FunctionResultSet';\n        }\n\n        if (!(rowset_promise instanceof Promise)) {\n            rowset_promise = Promise.resolve(rowset_promise);\n        }\n\n        rowset_promise.then(function(rowset) {\n\n            if (typeof rowset == 'undefined' || typeof rowset.forEach == 'undefined') {\n                throw 'Rowset is not defined. First argument to widget.sync must return a Rowset';\n            }\n\n            var container_id = AQ.uuid();\n\n            container.attr('data-container_id', container_id)\n            containers[container_id] = {\n                container: container,\n                widget_maker: widget_maker,\n                handlers: handlers\n            };\n\n            rowset.forEach(function(row) {\n                container.append(widget_maker(row));\n            });\n\n        }).catch(function(error) {\n            console.error('widget.sync failed: ', error);\n        });\n\n    }\n\n    // duplicate name for backwards compatibility\n    AQ.Widget.widget.sync = AQ.Widget.sync;\n\n    return AQ.Widget.widget;\n\n});\n
\\x79b89ec15cf2d7113073ed5483c18e770569f3464958771e5e7b7f61d9d4c431	/*******************************************************************************\n* Widget.js\n*\n* Created by Aquameta Labs, an open source company in Portland Oregon, USA.\n* Project: http://aquameta.com/\n******************************************************************************/\ndefine(['/doT.js', '/jQuery.min.js', '/datum.js'], function(doT, $, AQ, undefined) {\n\n    'use strict';\n\n    doT.templateSettings.strip = false;\n\n    var widget_promises = {};\n    var containers = {};\n    var namespaces = {};\n\n\n    AQ.Widget = {};\n\n\n    AQ.Widget.widget = function ( selector, input, extra ) {\n\n        if (!selector || typeof selector != 'string') {\n            throw "Widget - Selector argument is invalid or missing";\n        }\n\n        // Same namespace as calling widget, instead of global '' namespace\n        var default_namespace = (typeof this != 'undefined' && typeof this.namespace != 'undefined') ? this.namespace : '';\n\n        var is_semantic_dsl_lookup = selector.indexOf('/') != -1;\n\n        // For semantic lookup\n        // * selector is 'semantics/purpose/default_bundle'\n        // * input is AQ.* object\n        // * extra is {} to send to widget\n        if (is_semantic_dsl_lookup) {\n\n            if (!input) {\n                throw "Semantics requires an AQ.* to be passed in";\n            }\n\n            var context = extra || {};\n            var semantics = selector.split('/');\n            var args_object = {};\n\n            // If input is a promise (that will resolve as a Rowset or a Row), resolve it first\n            if (input instanceof Promise) {\n\n                var url_id;\n                var widget_getter = input.then(function(input) {\n\n                    context.datum = input;\n\n                    // These are the same for both Rowset and Row\n                    var endpoint = input.relation.schema.database;\n                    var fn = 'relation_widget';\n                    var type = 'meta.relation_id';\n                    args_object.relation_id = input.relation.id;\n\n                    if (input instanceof AQ.Rowset) {\n                        context.rows = input;\n                        url_id = input.relation.to_url(true);\n                    }\n                    else if (input instanceof AQ.Row) {\n                        context.row = input;\n                        url_id = input.to_url(true);\n                    }\n                    args_object.widget_purpose = semantics[1];\n                    args_object.default_bundle = semantics.length >= 3 ? semantics[2] : 'org.aquameta.core.semantics';\n                    \n                    return endpoint.schema('semantics').function({\n                        name: fn,\n                        parameters: [type,'text','text']\n                    }, args_object, { use_cache: true, meta_data: false });\n\n                });\n\n            }\n            // Else, check which type it is\n            else {\n\n                context.datum = input;\n\n                if (input instanceof AQ.Relation || input instanceof AQ.Table || input instanceof AQ.View) {\n                    var endpoint = input.schema.database;\n                    var fn = 'relation_widget';\n                    var type = 'meta.relation_id';\n                    args_object.relation_id = input.id;\n                    var url_id = input.to_url(true);\n                    context.relation = input;\n                }\n                else if (input instanceof AQ.Row) {\n                    var endpoint = input.relation.schema.database;\n                    var fn = 'relation_widget';\n                    var type = 'meta.relation_id';\n                    args_object.relation_id = input.relation.id;\n                    var url_id = input.to_url(true);\n                    context.row = input;\n                }\n                else if (input instanceof AQ.Rowset) {\n                    var endpoint = input.relation.schema.database;\n                    var fn = 'relation_widget';\n                    var type = 'meta.relation_id';\n                    args_object.relation_id = input.relation.id;\n                    var url_id = input.relation.to_url(true);\n                    context.rows = input;\n                }\n                else if (input instanceof AQ.Column) {\n                    var endpoint = input.relation.schema.database;\n                    var fn = 'column_widget';\n                    var type = 'meta.column_id';\n                    args_object.column_id = input.id;\n                    var url_id = input.relation.to_url(true);\n                    context.column = input;\n                }\n                else if (input instanceof AQ.Field) {\n                    var endpoint = input.row.relation.schema.database;\n                    var fn = 'column_widget';\n                    var type = 'meta.column_id';\n                    args_object.column_id = input.column.id;\n                    var url_id = input.to_url(true);\n                    context.field = input;\n                }\n                \n                args_object.widget_purpose = semantics[1];\n                args_object.default_bundle = semantics.length >= 3 ? semantics[2] : 'org.aquameta.core.semantics';\n                \n                var widget_getter = endpoint.schema('semantics').function({\n                    name: fn,\n                    parameters: [type,'text','text']\n                }, args_object, { use_cache: true, meta_data: false });\n            }\n\n            // Go get this widget - retrieve_promises don't change for calls to the same widget - they are cached by the widget name\n            var widget_retrieve_promise = retrieve(widget_getter, {\n                semantic_selector: selector,\n                url_id: url_id\n            });\n\n        }\n\n        // For regular widget lookup\n        // * selector is '[namespace:]widget_name'\n        // * input is {} to send to widget\n        // * extra is ignored\n        else {\n\n            //var context = typeof input != 'undefined' ? Object.assign({}, input) : {};\n            var context = input || {};\n\n            var name_parts = selector.split(':');\n\n            if (name_parts.length == 1) {\n                // Default namespace lookup\n                context.namespace = default_namespace;\n                context.name = name_parts[0];\n            }\n            else {\n                // Namespaced lookup\n                context.namespace = name_parts[0];\n                context.name = name_parts[1];\n                context.bundle_name = namespaces[context.namespace].bundle_name;\n            }\n\n            // Namespace not found\n            if (!(context.namespace in namespaces)) {\n                throw 'Widget namespace "'+context.namespace+'" has not been imported - Call AQ.Widget.import( bundle_name, namespace, endpoint ) to import bundled widgets to a namespace';\n            }\n    \n            var widget_getter = namespaces[context.namespace].endpoint.schema('widget').function('bundled_widget',\n                [ namespaces[context.namespace].bundle_name, context.name ], {\n                    use_cache: true,\n                    meta_data: false\n                });\n\n            // Go get this widget - retrieve_promises don't change for calls to the same widget - they are cached by the widget name\n            var widget_retrieve_promise = retrieve(widget_getter, {\n                namespace: context.namespace,\n                name: context.name\n            });\n\n        }\n\n        context.id = AQ.uuid();\n\n        // Setup default namespace for child widget\n        context.widget = AQ.Widget.widget.bind({ namespace: context.namespace });\n        context.widget.sync = AQ.Widget.widget.sync;\n\n        // Prepare and render the widget - each prepare_promise is unique because inputs are different - they are cached by the unique uuid created for the context\n        widget_promises[context.id] = prepare(widget_retrieve_promise, context);\n\n        // Return script that calls swap\n        return '<script id="widget-stub_' + context.id  + '" data-widget_id="' + context.id + '">' +\n                  'AQ.Widget.swap($("#widget-stub_' +  context.id  + '"), "' + context.id + '");'  + \n               '</script>';\n\n    }\n\n\n\n    /* Import a bundle name to a local namespace */\n    AQ.Widget.import = function( bundle_name, namespace, endpoint ) {\n\n        namespaces[namespace] = {\n            endpoint: endpoint,\n            bundle_name: bundle_name\n        };\n\n    };\n\n\n    /* Return an array bundle of imported bundle names */\n    AQ.Widget.bundles = function() {\n        return Object.keys(namespaces).map(function(key) {\n            return namespaces[key].bundle_name;\n        });\n    };\n\n\n\n    /* Find the bundle that was imported to this namespace */\n    AQ.Widget.bundle = function( namespace ) {\n        return namespaces[namespace].bundle_name;\n    };\n\n\n\n    /* Find the namespace that uses this bundle */\n    AQ.Widget.namespace = function( bundle_name ) {\n        return Object.keys(namespaces).find(function(namespace) {\n            return namespaces[namespace].bundle_name == bundle_name;\n        });\n    };\n\n\n\n    function retrieve( widget_getter, selector ) {\n\n        if ('semantic_selector' in selector) {\n            var semantic_lookup = true;\n        }\n\n        return widget_getter.then(function(row) {\n\n            // Get all related widget data\n            return Promise.all([\n                row,/* VIEWSIGNORE\n                row.related_rows('id', 'widget.input', 'widget_id', { use_cache: true, meta_data: true }).catch(function(){ return; }), \n                row.related_rows('id', 'widget.widget_view', 'widget_id', { use_cache: true, meta_data: true })\n                    .then(function(widget_views) {\n\n                        var db = row.schema.database;\n                        return widget_views.map(function(widget_view) {\n                            var view_id = widget_view.get('view_id');\n                            return db.schema(view_id.schema_id.name).view(view_id.name);\n                        });\n\n                    }).catch(function(err) { return; }), */\n                row.related_rows('id', 'widget.widget_dependency_js', 'widget_id', { use_cache: true, meta_data: true })\n                    .then(function(deps_js) {\n\n                        if (!deps_js.length) { return; }\n                        return deps_js.related_rows('dependency_js_id', 'widget.dependency_js', 'id', { use_cache: true, meta_data: true });\n\n                    }).then(function(deps) {\n\n                        return Promise.all(\n\n                            deps.map(function(dep) {\n                                return System.import(dep.field('content').to_url()).then(function(dep_module) {\n                                    //console.log('my module', dep_module);\n                                    \n                                    return {\n                                        url: dep.field('content').to_url(),\n                                        name: dep.get('variable') || 'non_amd_module',\n                                        /* TODO: This value thing is a hack. For some reason, jwerty doesn't load properly here */\n                                        value: typeof dep_module == 'object' ? dep_module[Object.keys(dep_module)[0]] : dep_module\n                                        //value: dep_module\n                                    };\n                                });\n                            })\n                        );\n\n                    }).catch(function() { return; })\n            ]);\n        }).catch(function(err) {\n            if (semantic_lookup) {\n                throw 'Widget not found from semantic lookup with ' + selector.semantic_selector + ' on ' + selector.url_id;\n            }\n            else {\n                throw 'Widget does not exist, ' + selector.namespace + ':' + selector.name;\n            }\n        });\n    };\n\n\n\n    function prepare( retrieve_promise, context ) {\n\n        return retrieve_promise.then(function( widget_data ) {\n\n            //console.log('retrieve_promise resolved', widget_data);\n\t\t\tvar [ widget_row,  /* inputs, VIEWSIGNORE views, */ deps_js ] = widget_data;\n\n            context.name = widget_row.get('name');\n\n            var xinput = context;\n            context = Object.assign({\n                    db: widget_row.schema.database,\n                    endpoint: widget_row.schema.database,\n                    input: {},\n                    xinput: xinput\n                }, context);\n\n            delete context.xinput.id;\n            delete context.xinput.name;\n            delete context.xinput.namespace;\n            delete context.xinput.widget;\n\n            // Process inputs\n            if (typeof inputs != 'undefined') {\n\n                inputs.forEach(function(input) {\n                    var input_name = input.get('name');\n\n                    if (typeof context[input_name] == 'undefined') {\n                        if (input.get('optional')) {\n                            var default_code = input.get('default_value');\n                            try {\n\n                                if (default_code) {\n                                    context[input_name] = eval('(' + default_code + ')');\n                                }\n                                else {\n                                    context[input_name] =  undefined;\n                                }\n\n                            }\n                            catch (e) {\n                                error(e, context.name, "Widget default eval failure: " + default_code);\n                                /*\n                                console.error("Widget default eval failure", default_code);\n                                throw e;\n                                */\n                            }\n\n                        }\n                        else {\n                            error('Missing required input ' + input_name, context.name, 'Inputs');\n                        }\n                    }\n                    context.input[input_name] = context[input_name];\n                    delete context.xinput[input_name];\n                });\n            }\n\n            // Load views into context\n            if (typeof views != 'undefined') {\n                views.forEach(function(view) {\n                    context[view.schema.name + '_' + view.name] = view;\n                });\n            }\n\n            var rendered_widget = render(widget_row, context);\n            var post_js_function = create_post_js_function(widget_row, context, deps_js);\n\n            // Return rendered widget and post_js function\n            return {\n                html: rendered_widget,\n                widget_id: context.id,\n                widget_name: context.name,\n                post_js: post_js_function\n            };\n\n        });\n    };\n\n\n\n    function render( widget_row, context ) {\n\n        // Create html template\n        var html_template = doT.template(widget_row.get('html') || '');\n\n        // Compile html template\n        try {\n            var html = html_template(context);\n        } catch(e) {\n            error(e, context.name, 'HTML');\n        }\n\n        // Render html\n        try {\n            var rendered = $(html).attr('data-widget', context.name)\n                .attr('data-widget_id', context.id)\n                .attr('data-bundle_alias', context.namespace)\n                .attr('data-bundle_name', context.bundle_name)\n                .attr('data-widget_row_id', widget_row.get('id'))\n                .data('help', widget_row.get('help'));\n        } catch(e) {\n            error(e, context.name, 'HTML (adding data-* attributes)');\n        }\n                                \n        // If CSS exists and has not yet been applied\n        if (widget_row.get('css') != null && $('style[data-widget="' + context.name + '"]').length == 0) {\n\n            // Create css template\n            var css_template = doT.template(widget_row.get('css') || '');\n\n            // Try to run css template\n            try {\n                var css = css_template(context);\n            } catch(e) {\n                error(e, context.name, 'CSS');\n            }\n\n            // Add css to dom\n            $('<style type="text/css" data-widget="' + context.name + '">' + css + '</style>').appendTo(document.head);\n        }\n\n        return rendered;\n    };\n\n\n\n    function create_post_js_function( widget_row, context, deps_js ) {\n\n        var context_keys = Object.keys(context).sort();\n\n        // Get context values\n        var context_vals = context_keys.map(function(key) {\n            return context[key];\n        });\n\n        // Dependency names and values\n        var dep_names = [],\n            dep_values = [];\n        if (deps_js != null) {\n            deps_js.forEach(function(dep_js) {\n                dep_names.push(dep_js.name);\n                dep_values.push(dep_js.value);\n            });\n        }\n\n        try {\n            /*\n            * Creating an script that looks like this\n            * function(dep1_name, dep2_name, ...) {\n            *   function(input1, input2) {\n            *       post_js\n            *   }.apply(this.this.context_vals);\n            * }.apply(this, this.dep_vals);\n            */\n            var post_js = Function(\n                '(function(' + dep_names.join(',') + ') { \\n' +\n                    '(function(' + context_keys.join(',') + ') { \\n' +\n                        'var w = $("#"+id);\\n\\n' +\n                        widget_row.get('post_js') +\n                        '\\n//# sourceURL=' + widget_row.get('id') + '/' + widget_row.get('name') + '/post_js\\n' +\n                    '}).apply(this, this.context_vals);' +\n                '}).apply(this, this.dep_values);'\n            ).bind({ context_vals: context_vals, dep_values: dep_values });\n        }\n        catch(e) {\n            error(e, widget_row.get('name'), 'Creating post_js function');\n        }\n\n        return post_js;\n\n    };\n\n\n    // detect svg widgets by tag name.  might be better to check the dom to see if we're inside an svg tag?\n    AQ.Widget.is_svg = function( e ) {\n        var svg_tags = ['circle','rect','polygon','g']; // TODO: add more, or change approach?\n        for (var i=0;i<svg_tags.length;i++) {\n            if (e.tagName.toUpperCase() == svg_tags[i].toUpperCase()) {\n                // console.log('svg  widget: ' + svg_tags[i]);\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n\n    AQ.Widget.swap = function( $element, id ) {\n        widget_promises[id].then(function(rendered_widget) {\n\n            // Replace stub\n            // special case for svg elements - http://stackoverflow.com/questions/3642035/jquerys-append-not-working-with-svg-element\n            if (AQ.Widget.is_svg(rendered_widget.html[0])) { // TODO: is there ever a case where there is more than one element in this array?\n                var div = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');\n                div.innerHTML= '<svg xmlns="http://www.w3.org/2000/svg">'+rendered_widget.html[0].outerHTML+'</svg>';\n\n                var frag= document.createDocumentFragment();\n                while (div.firstChild.firstChild)\n                    frag.appendChild(div.firstChild.firstChild);\n\n                $element.replaceWith(frag);\n            }\n            else $element.replaceWith(rendered_widget.html);\n\n            // Run post_js - or this may have to be done with a script tag appended to the widget\n            try {\n                rendered_widget.post_js();\n            }\n            catch(e) {\n                error(e, rendered_widget.widget_name, 'Running post_js function');\n            }\n\n            var w = $('#' + rendered_widget.widget_id);\n\n            // notify the world that a widget has loaded.  debugger uses this to detect widget tree changes\n            w.trigger('widget_loaded', { widget: w });\n\n            // Delete prepeared_promise\n            delete widget_promises[id];\n\n        }).catch(function(error) {\n            //console.error('Widget swap failed - ', error);\n            console.error(error);\n            // Remove stub\n            $element.remove();\n            // Delete promise\n            delete widget_promises[id];\n        });\n    };\n\n\n\n    function error( err, widget_name, step_name ) {\n        console.error("widget('" + widget_name + "', ...) " + step_name + " failed!");\n        //window.setTimeout(function() { throw err; }, 100);\n        throw err;\n    }\n\n\n\n    AQ.Widget.sync = function(rowset_promise, container, widget_maker, handlers) {\n\n        if(handlers === undefined) {\n            handlers = {};\n        }\n\n        if (widget_maker === undefined) {\n            throw 'widget.sync missing widget_maker argument';\n        }\n\n        if (container.length < 1) {\n            throw 'widget.sync failed: The specified container is empty or not found';\n            return;\n        }\n\n        if (container.length > 1) {\n            throw 'widget.sync failed: The specified container contains multiple elements';\n            return;\n        }\n\n        if (!container instanceof jQuery) {\n            throw 'widget.sync failed: The specified container is not a jQuery object';\n            return;\n        }\n\n        if (typeof rowset_promise == 'undefined' ||\n            (!(rowset_promise instanceof Promise) && !(rowset_promise instanceof AQ.Rowset) && !(rowset_promise instanceof AQ.FunctionResultSet))) {\n            throw 'widget.sync failed: rowset_promise must be a "thenable" promise or a resolved AQ.Rowset or a resolved AQ.FunctionResultSet';\n        }\n\n        if (!(rowset_promise instanceof Promise)) {\n            rowset_promise = Promise.resolve(rowset_promise);\n        }\n\n        rowset_promise.then(function(rowset) {\n\n            if (typeof rowset == 'undefined' || typeof rowset.forEach == 'undefined') {\n                throw 'Rowset is not defined. First argument to widget.sync must return a Rowset';\n            }\n\n            var container_id = AQ.uuid();\n\n            container.attr('data-container_id', container_id)\n            containers[container_id] = {\n                container: container,\n                widget_maker: widget_maker,\n                handlers: handlers\n            };\n\n            rowset.forEach(function(row) {\n                container.append(widget_maker(row));\n            });\n\n        }).catch(function(error) {\n            console.error('widget.sync failed: ', error);\n        });\n\n    }\n\n    // duplicate name for backwards compatibility\n    AQ.Widget.widget.sync = AQ.Widget.sync;\n\n    return AQ.Widget.widget;\n\n});\n
\\x911fc0c48cb0c70601db5775a9bef1b740dc4cc9f9b46389b9f0563fe7eb94d7	0.2.0
\\x9d79664474502879247ae90c2d7a2b6c4aa4927b1f10f5651309d338c58283b7	/*******************************************************************************\n * Widget.js\n *\n * Created by Aquameta Labs, an open source company in Portland Oregon, USA.\n * Project: http://aquameta.com/\n ******************************************************************************/\n/* eslint-env browser */\n/* globals jQuery define */\ndefine(['/doT.js', '/jQuery.min.js', '/datum.js'], function (\n  doT,\n  $,\n  AQ,\n  undefined // eslint-disable-line\n) {\n  'use strict';\n\n  doT.templateSettings.strip = false;\n\n  var widget_promises = {};\n  var containers = {};\n  var namespaces = {};\n\n  AQ.Widget = {};\n\n  AQ.Widget.widget = function (selector, input, extra) {\n    if (!selector || typeof selector != 'string') {\n      throw 'Widget - Selector argument is invalid or missing';\n    }\n\n    // Same namespace as calling widget, instead of global '' namespace\n    var default_namespace =\n      typeof this != 'undefined' && typeof this.namespace != 'undefined'\n        ? this.namespace\n        : '';\n\n    var is_semantic_dsl_lookup = selector.indexOf('/') != -1;\n\n    // For semantic lookup\n    // * selector is 'semantics/purpose/default_bundle'\n    // * input is AQ.* object\n    // * extra is {} to send to widget\n    if (is_semantic_dsl_lookup) {\n      if (!input) {\n        throw 'Semantics requires an AQ.* to be passed in';\n      }\n\n      var context = extra || {};\n      var semantics = selector.split('/');\n      var args_object = {};\n\n      // If input is a promise (that will resolve as a Rowset or a Row), resolve it first\n      if (input instanceof Promise) {\n        var url_id;\n        var widget_getter = input.then(function (input) {\n          context.datum = input;\n\n          // These are the same for both Rowset and Row\n          var endpoint = input.relation.schema.database;\n          var fn = 'relation_widget';\n          var type = 'meta.relation_id';\n          args_object.relation_id = input.relation.id;\n\n          if (input instanceof AQ.Rowset) {\n            context.rows = input;\n            url_id = input.relation.to_url(true);\n          } else if (input instanceof AQ.Row) {\n            context.row = input;\n            url_id = input.to_url(true);\n          }\n          args_object.widget_purpose = semantics[1];\n          args_object.default_bundle =\n            semantics.length >= 3\n              ? semantics[2]\n              : 'org.aquameta.core.semantics';\n\n          return endpoint.schema('semantics').function(\n            {\n              name: fn,\n              parameters: [type, 'text', 'text'],\n            },\n            args_object,\n            {use_cache: true, meta_data: false}\n          );\n        });\n      }\n      // Else, check which type it is\n      else {\n        context.datum = input;\n\n        if (\n          input instanceof AQ.Relation ||\n          input instanceof AQ.Table ||\n          input instanceof AQ.View\n        ) {\n          var endpoint = input.schema.database;\n          var fn = 'relation_widget';\n          var type = 'meta.relation_id';\n          args_object.relation_id = input.id;\n          var url_id = input.to_url(true);\n          context.relation = input;\n        } else if (input instanceof AQ.Row) {\n          var endpoint = input.relation.schema.database;\n          var fn = 'relation_widget';\n          var type = 'meta.relation_id';\n          args_object.relation_id = input.relation.id;\n          var url_id = input.to_url(true);\n          context.row = input;\n        } else if (input instanceof AQ.Rowset) {\n          var endpoint = input.relation.schema.database;\n          var fn = 'relation_widget';\n          var type = 'meta.relation_id';\n          args_object.relation_id = input.relation.id;\n          var url_id = input.relation.to_url(true);\n          context.rows = input;\n        } else if (input instanceof AQ.Column) {\n          var endpoint = input.relation.schema.database;\n          var fn = 'column_widget';\n          var type = 'meta.column_id';\n          args_object.column_id = input.id;\n          var url_id = input.relation.to_url(true);\n          context.column = input;\n        } else if (input instanceof AQ.Field) {\n          var endpoint = input.row.relation.schema.database;\n          var fn = 'column_widget';\n          var type = 'meta.column_id';\n          args_object.column_id = input.column.id;\n          var url_id = input.to_url(true);\n          context.field = input;\n        }\n\n        args_object.widget_purpose = semantics[1];\n        args_object.default_bundle =\n          semantics.length >= 3 ? semantics[2] : 'org.aquameta.core.semantics';\n\n        var widget_getter = endpoint.schema('semantics').function(\n          {\n            name: fn,\n            parameters: [type, 'text', 'text'],\n          },\n          args_object,\n          {use_cache: true, meta_data: false}\n        );\n      }\n\n      // Go get this widget - retrieve_promises don't change for calls to the same widget - they are cached by the widget name\n      var widget_retrieve_promise = retrieve(widget_getter, {\n        semantic_selector: selector,\n        url_id: url_id,\n      });\n    }\n\n    // For regular widget lookup\n    // * selector is '[namespace:]widget_name'\n    // * input is {} to send to widget\n    // * extra is ignored\n    else {\n      //var context = typeof input != 'undefined' ? Object.assign({}, input) : {};\n      var context = input || {};\n\n      var name_parts = selector.split(':');\n\n      if (name_parts.length == 1) {\n        // Default namespace lookup\n        context.namespace = default_namespace;\n        context.name = name_parts[0];\n      } else {\n        // Namespaced lookup\n        context.namespace = name_parts[0];\n        context.name = name_parts[1];\n        context.bundle_name = namespaces[context.namespace].bundle_name;\n      }\n\n      // Namespace not found\n      if (!(context.namespace in namespaces)) {\n        throw (\n          'Widget namespace "' +\n          context.namespace +\n          '" has not been imported - Call AQ.Widget.import( bundle_name, namespace, endpoint ) to import bundled widgets to a namespace'\n        );\n      }\n\n      var widget_getter = namespaces[context.namespace].endpoint\n        .schema('widget')\n        .function(\n          'bundled_widget',\n          [namespaces[context.namespace].bundle_name, context.name],\n          {\n            use_cache: true,\n            meta_data: false,\n          }\n        );\n\n      // Go get this widget - retrieve_promises don't change for calls to the same widget - they are cached by the widget name\n      var widget_retrieve_promise = retrieve(widget_getter, {\n        namespace: context.namespace,\n        name: context.name,\n      });\n    }\n\n    context.id = AQ.uuid();\n\n    // Setup default namespace for child widget\n    context.widget = AQ.Widget.widget.bind({namespace: context.namespace});\n    context.widget.sync = AQ.Widget.widget.sync;\n\n    // Prepare and render the widget - each prepare_promise is unique because inputs are different - they are cached by the unique uuid created for the context\n    widget_promises[context.id] = prepare(widget_retrieve_promise, context);\n\n    // Return script that calls swap\n    return (\n      '<script id="widget-stub_' +\n      context.id +\n      '" data-widget_id="' +\n      context.id +\n      '">' +\n      'AQ.Widget.swap($("#widget-stub_' +\n      context.id +\n      '"), "' +\n      context.id +\n      '");' +\n      '</script>'\n    );\n  };\n\n  /* Import a bundle name to a local namespace */\n  AQ.Widget.import = function (bundle_name, namespace, endpoint) {\n    namespaces[namespace] = {\n      endpoint: endpoint,\n      bundle_name: bundle_name,\n    };\n  };\n\n  /* Return an array bundle of imported bundle names */\n  AQ.Widget.bundles = function () {\n    return Object.keys(namespaces).map(function (key) {\n      return namespaces[key].bundle_name;\n    });\n  };\n\n  /* Find the bundle that was imported to this namespace */\n  AQ.Widget.bundle = function (namespace) {\n    return namespaces[namespace].bundle_name;\n  };\n\n  /* Find the namespace that uses this bundle */\n  AQ.Widget.namespace = function (bundle_name) {\n    return Object.keys(namespaces).find(function (namespace) {\n      return namespaces[namespace].bundle_name == bundle_name;\n    });\n  };\n\n  function retrieve(widget_getter, selector) {\n    if ('semantic_selector' in selector) {\n      var semantic_lookup = true;\n    }\n\n    return widget_getter\n      .then(function (row) {\n        // Get all related widget data\n        return Promise.all([\n          row /* VIEWSIGNORE\n                row.related_rows('id', 'widget.input', 'widget_id', { use_cache: true, meta_data: true, events: null }).catch(function(){ return; }), \n                row.related_rows('id', 'widget.widget_view', 'widget_id', { use_cache: true, meta_data: true, events: null })\n                    .then(function(widget_views) {\n\n                        var db = row.schema.database;\n                        return widget_views.map(function(widget_view) {\n                            var view_id = widget_view.get('view_id');\n                            return db.schema(view_id.schema_id.name).view(view_id.name);\n                        });\n\n                    }).catch(function(err) { return; }), */,\n          row\n            .related_rows('id', 'widget.widget_dependency_js', 'widget_id', {\n              use_cache: true,\n              meta_data: true,\n              events: null,\n            })\n            .then(function (deps_js) {\n              if (!deps_js.length) {\n                return;\n              }\n              return deps_js.related_rows(\n                'dependency_js_id',\n                'widget.dependency_js',\n                'id',\n                {use_cache: true, meta_data: true, events: null}\n              );\n            })\n            .then(function (deps) {\n              return Promise.all(\n                deps.map(function (dep) {\n                  return System.import(dep.field('content').to_url()).then(\n                    function (dep_module) {\n                      //console.log('my module', dep_module);\n\n                      return {\n                        url: dep.field('content').to_url(),\n                        name: dep.get('variable') || 'non_amd_module',\n                        /* TODO: This value thing is a hack. For some reason, jwerty doesn't load properly here */\n                        value:\n                          typeof dep_module == 'object'\n                            ? dep_module[Object.keys(dep_module)[0]]\n                            : dep_module,\n                        //value: dep_module\n                      };\n                    }\n                  );\n                })\n              );\n            })\n            .catch(function () {\n              return;\n            }),\n        ]);\n      })\n      .catch(function (err) {\n        if (semantic_lookup) {\n          throw (\n            'Widget not found from semantic lookup with ' +\n            selector.semantic_selector +\n            ' on ' +\n            selector.url_id\n          );\n        } else {\n          throw (\n            'Widget does not exist, ' + selector.namespace + ':' + selector.name\n          );\n        }\n      });\n  }\n\n  function prepare(retrieve_promise, context) {\n    return retrieve_promise.then(function (widget_data) {\n      //console.log('retrieve_promise resolved', widget_data);\n      var [widget_row, /* inputs, VIEWSIGNORE views, */ deps_js] = widget_data;\n\n      context.name = widget_row.get('name');\n\n      var xinput = context;\n      context = Object.assign(\n        {\n          db: widget_row.schema.database,\n          endpoint: widget_row.schema.database,\n          input: {},\n          xinput: xinput,\n        },\n        context\n      );\n\n      delete context.xinput.id;\n      delete context.xinput.name;\n      delete context.xinput.namespace;\n      delete context.xinput.widget;\n\n      // Process inputs\n      if (typeof inputs != 'undefined') {\n        inputs.forEach(function (input) {\n          var input_name = input.get('name');\n\n          if (typeof context[input_name] == 'undefined') {\n            if (input.get('optional')) {\n              var default_code = input.get('default_value');\n              try {\n                if (default_code) {\n                  context[input_name] = eval('(' + default_code + ')');\n                } else {\n                  context[input_name] = undefined;\n                }\n              } catch (e) {\n                error(\n                  e,\n                  context.name,\n                  'Widget default eval failure: ' + default_code\n                );\n                /*\n                                console.error("Widget default eval failure", default_code);\n                                throw e;\n                                */\n              }\n            } else {\n              error(\n                'Missing required input ' + input_name,\n                context.name,\n                'Inputs'\n              );\n            }\n          }\n          context.input[input_name] = context[input_name];\n          delete context.xinput[input_name];\n        });\n      }\n\n      // Load views into context\n      if (typeof views != 'undefined') {\n        views.forEach(function (view) {\n          context[view.schema.name + '_' + view.name] = view;\n        });\n      }\n\n      var rendered_widget = render(widget_row, context);\n      var post_js_function = create_post_js_function(\n        widget_row,\n        context,\n        deps_js\n      );\n\n      // Return rendered widget and post_js function\n      return {\n        html: rendered_widget,\n        widget_id: context.id,\n        widget_name: context.name,\n        post_js: post_js_function,\n      };\n    });\n  }\n\n  function render(widget_row, context) {\n    // Create html template\n    var html_template = doT.template(widget_row.get('html') || '');\n\n    // Compile html template\n    try {\n      var html = html_template(context);\n    } catch (e) {\n      error(e, context.name, 'HTML');\n    }\n\n    // Render html\n    try {\n      var rendered = $(html)\n        .attr('data-widget', context.name)\n        .attr('data-widget_id', context.id)\n        .attr('data-bundle_alias', context.namespace)\n        .attr('data-bundle_name', context.bundle_name)\n        .attr('data-widget_row_id', widget_row.get('id'))\n        .data('help', widget_row.get('help'));\n    } catch (e) {\n      error(e, context.name, 'HTML (adding data-* attributes)');\n    }\n\n    // If CSS exists and has not yet been applied\n    if (\n      widget_row.get('css') != null &&\n      $('style[data-widget="' + context.name + '"]').length == 0\n    ) {\n      // Create css template\n      var css_template = doT.template(widget_row.get('css') || '');\n\n      // Try to run css template\n      try {\n        var css = css_template(context);\n      } catch (e) {\n        error(e, context.name, 'CSS');\n      }\n\n      // Add css to dom\n      $(\n        '<style type="text/css" data-widget="' +\n          context.name +\n          '">' +\n          css +\n          '</style>'\n      ).appendTo(document.head);\n    }\n\n    return rendered;\n  }\n\n  function create_post_js_function(widget_row, context, deps_js) {\n    var context_keys = Object.keys(context).sort();\n\n    // Get context values\n    var context_vals = context_keys.map(function (key) {\n      return context[key];\n    });\n\n    // Dependency names and values\n    var dep_names = [],\n      dep_values = [];\n    if (deps_js != null) {\n      deps_js.forEach(function (dep_js) {\n        dep_names.push(dep_js.name);\n        dep_values.push(dep_js.value);\n      });\n    }\n\n    try {\n      /*\n       * Creating an script that looks like this\n       * function(dep1_name, dep2_name, ...) {\n       *   function(input1, input2) {\n       *       post_js\n       *   }.apply(this.this.context_vals);\n       * }.apply(this, this.dep_vals);\n       */\n      var post_js = Function(\n        '(function(' +\n          dep_names.join(',') +\n          ') { \\n' +\n          '(function(' +\n          context_keys.join(',') +\n          ') { \\n' +\n          'var w = $("#"+id);\\n\\n' +\n          widget_row.get('post_js') +\n          '\\n//# sourceURL=' +\n          widget_row.get('id') +\n          '/' +\n          widget_row.get('name') +\n          '/post_js\\n' +\n          '}).apply(this, this.context_vals);' +\n          '}).apply(this, this.dep_values);'\n      ).bind({context_vals: context_vals, dep_values: dep_values});\n    } catch (e) {\n      error(e, widget_row.get('name'), 'Creating post_js function');\n    }\n\n    return post_js;\n  }\n\n  // detect svg widgets by tag name.  might be better to check the dom to see if we're inside an svg tag?\n  AQ.Widget.is_svg = function (e) {\n    var svg_tags = ['circle', 'rect', 'polygon', 'g']; // TODO: add more, or change approach?\n    for (var i = 0; i < svg_tags.length; i++) {\n      if (e.tagName.toUpperCase() == svg_tags[i].toUpperCase()) {\n        // console.log('svg  widget: ' + svg_tags[i]);\n        return true;\n      }\n    }\n    return false;\n  };\n\n  AQ.Widget.swap = function ($element, id) {\n    widget_promises[id]\n      .then(function (rendered_widget) {\n        // Replace stub\n        // special case for svg elements - http://stackoverflow.com/questions/3642035/jquerys-append-not-working-with-svg-element\n        if (AQ.Widget.is_svg(rendered_widget.html[0])) {\n          // TODO: is there ever a case where there is more than one element in this array?\n          var div = document.createElementNS(\n            'http://www.w3.org/1999/xhtml',\n            'div'\n          );\n          div.innerHTML =\n            '<svg xmlns="http://www.w3.org/2000/svg">' +\n            rendered_widget.html[0].outerHTML +\n            '</svg>';\n\n          var frag = document.createDocumentFragment();\n          while (div.firstChild.firstChild)\n            frag.appendChild(div.firstChild.firstChild);\n\n          $element.replaceWith(frag);\n        } else $element.replaceWith(rendered_widget.html);\n\n        // Run post_js - or this may have to be done with a script tag appended to the widget\n        try {\n          rendered_widget.post_js();\n        } catch (e) {\n          error(e, rendered_widget.widget_name, 'Running post_js function');\n        }\n\n        var w = $('#' + rendered_widget.widget_id);\n\n        // notify the world that a widget has loaded.  debugger uses this to detect widget tree changes\n        w.trigger('widget_loaded', {widget: w});\n\n        // Delete prepeared_promise\n        delete widget_promises[id];\n      })\n      .catch(function (error) {\n        //console.error('Widget swap failed - ', error);\n        console.error(error);\n        // Remove stub\n        $element.remove();\n        // Delete promise\n        delete widget_promises[id];\n      });\n  };\n\n  function error(err, widget_name, step_name) {\n    console.error(\n      "widget('" + widget_name + "', ...) " + step_name + ' failed!'\n    );\n    //window.setTimeout(function() { throw err; }, 100);\n    throw err;\n  }\n\n  AQ.Widget.sync = function (\n    rowset_promise,\n    container,\n    widget_maker,\n    handlers\n  ) {\n    if (handlers === undefined) {\n      handlers = {};\n    }\n\n    if (widget_maker === undefined) {\n      throw 'widget.sync missing widget_maker argument';\n    }\n\n    if (container.length < 1) {\n      throw 'widget.sync failed: The specified container is empty or not found';\n      return;\n    }\n\n    if (container.length > 1) {\n      throw 'widget.sync failed: The specified container contains multiple elements';\n      return;\n    }\n\n    if (!container instanceof jQuery) {\n      throw 'widget.sync failed: The specified container is not a jQuery object';\n      return;\n    }\n\n    if (\n      typeof rowset_promise == 'undefined' ||\n      (!(rowset_promise instanceof Promise) &&\n        !(rowset_promise instanceof AQ.Rowset) &&\n        !(rowset_promise instanceof AQ.FunctionResultSet))\n    ) {\n      throw 'widget.sync failed: rowset_promise must be a "thenable" promise or a resolved AQ.Rowset or a resolved AQ.FunctionResultSet';\n    }\n\n    if (!(rowset_promise instanceof Promise)) {\n      rowset_promise = Promise.resolve(rowset_promise);\n    }\n\n    rowset_promise\n      .then(function (rowset) {\n        if (\n          typeof rowset == 'undefined' ||\n          typeof rowset.forEach == 'undefined'\n        ) {\n          throw 'Rowset is not defined. First argument to widget.sync must return a Rowset';\n        }\n\n        var container_id = AQ.uuid();\n\n        container.attr('data-container_id', container_id);\n        containers[container_id] = {\n          container: container,\n          widget_maker: widget_maker,\n          handlers: handlers,\n        };\n\n        if (rowset instanceof AQ.Rowset) {\n          let widgets = [];\n          rowset.forEach(function (row) {\n            const w = $(widget_maker(row));\n            container.append(w);\n            widgets.push([row.to_url(true), w.attr('data-widget_id')]);\n          });\n          rowset.onDelete(function (deletedRowId) {\n            const widget = widgets.find(([rowId]) => rowId === deletedRowId);\n            if (widget) {\n              const id = widget[1];\n              container.find(`#${id}`).remove();\n            }\n          });\n          rowset.onUpdate(function (row) {\n            const rowUrl = row.to_url(true);\n            const index = widgets.findIndex(([rowId]) => rowId === rowUrl);\n            if (index >= 0) {\n              const widget = widgets[index];\n              const id = widget[1];\n              const newWidget = $(widget_maker(row));\n              widgets[index] = [\n                row.to_url(true),\n                newWidget.attr('data-widget_id'),\n              ];\n              container.find(`#${id}`).replaceWith(newWidget);\n            }\n          });\n        } else {\n          rowset.forEach(function (row) {\n            container.append(widget_maker(row));\n          });\n        }\n      })\n      .catch(function (error) {\n        console.error('widget.sync failed: ', error);\n      });\n  };\n\n  // duplicate name for backwards compatibility\n\n  AQ.Widget.widget.sync = AQ.Widget.sync;\n\n  return AQ.Widget.widget;\n});\n
\\xb5bea41b6c623f7c09f1bf24dcae58ebab3c0cdd90ad966bc43a45b44867e12b	true
\\xcb218518c86e9538f54d6562b2d09a2e8a1fd11dbb99b21c08ab600688c10356	0e0f1e42-ad32-4018-b1ca-74cacb29fde4
\\xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855	
