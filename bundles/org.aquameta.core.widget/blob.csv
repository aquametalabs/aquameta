\\x03c8e8ddbe2a10aaa70d5801effc641b53e735160801f7473dfc3fd02f8cbe77	9333968d-c297-4134-9c47-ba675a8f06d6
\\x041abec0914b28277d97a49b988d1121baca6a18f1f34f5cbbecefc6d40aadb3	db204596-15af-435a-9bcc-39db62a3fb3c
\\x09e5a5e60fa868568e57ebaadce8c7287476e3cfe2d827ac998d2887934ef630	{js,NULL,NULL,""}
\\x157cb9fd9cdda863d397e487c0e961a3368ba27fd65c65db7cd008b07ced947d	export class Function {\n    constructor(schema, name, args) {\n        this.schema = schema;\n        this.name = name;\n\n        if (args instanceof Array) {\n            this.args = '{' + args.join(',') + '}';\n        } else {\n            this.args = args;\n        }\n\n        this.id = { schema_id: this.schema.id, name: this.name, args: this.args };\n        this.to_url = function (id_only) {\n            var base_url = id_only ? '' : this.schema.database.endpoint.url;\n            if (typeof this.args != 'undefined') {\n                return (\n                    base_url +\n                    '/function/' +\n                    this.schema.name +\n                    '/' +\n                    this.name +\n                    '/' +\n                    this.args\n                );\n            }\n            return base_url + '/function/' + this.schema.name + '/' + this.name;\n        };\n    }\n}\n\nexport class FunctionResult {\n    constructor(fn, response) {\n        this.function = fn;\n        this.schema = fn.schema;\n        this.row_data = response.result[0].row;\n        this.rows = response.result;\n        this.columns = response.columns;\n    }\n    get(name) {\n        return this.row_data[name];\n    }\n    to_string() {\n        return JSON.stringify(this.row_data);\n    }\n    map(fn) {\n        return this.rows\n            .map(\n                function (row) {\n                    return new FunctionResult(this.function, {\n                        columns: this.columns,\n                        result: [row],\n                    });\n                }.bind(this)\n            )\n            .map(fn);\n    }\n    forEach(fn) {\n        return this.rows\n            .map(\n                function (row) {\n                    return new FunctionResult(this.function, {\n                        columns: this.columns,\n                        result: [row],\n                    });\n                }.bind(this)\n            )\n            .forEach(fn);\n    }\n    related_rows(\n        self_column_name,\n        related_relation_name,\n        related_column_name,\n        options\n    ) {\n        var relation_parts = related_relation_name.split('.');\n        if (relation_parts.length < 2) {\n            console.error(\n                'Related relation name must be schema qualified (schema_name.relation_name)'\n            );\n            /* throw "Related relation name must be schema qualified (schema_name.relation_name)"; */\n        }\n\n        var schema_name = relation_parts[0];\n        var relation_name = relation_parts[1];\n        var db = this.function.schema.database;\n\n        options = options || {};\n        options.where =\n            options.where instanceof Array\n                ? options.where\n                : typeof options.where == 'undefined'\n                    ? []\n                    : [options.where];\n        options.where.push({\n            name: related_column_name,\n            op: '=',\n            value: this.get(self_column_name),\n        });\n\n        return db.schema(schema_name).relation(relation_name).rows(options);\n    }\n    related_row(\n        self_column_name,\n        related_relation_name,\n        related_column_name,\n        options\n    ) {\n        var relation_parts = related_relation_name.split('.');\n        if (relation_parts.length < 2) {\n            console.error(\n                'Related relation name must be schema qualified (schema_name.relation_name)'\n            );\n            /* throw "Related relation name must be schema qualified (schema_name.relation_name)"; */\n        }\n\n        var schema_name = relation_parts[0];\n        var relation_name = relation_parts[1];\n        var db = this.function.schema.database;\n\n        options = options || {};\n        options.where =\n            options.where instanceof Array\n                ? options.where\n                : typeof options.where == 'undefined'\n                    ? []\n                    : [options.where];\n        options.where.push({\n            name: related_column_name,\n            op: '=',\n            value: this.get(self_column_name),\n        });\n\n        return db.schema(schema_name).relation(relation_name).row(options);\n    }\n}\n\nexport class FunctionResultSet {\n    constructor(fn, response) {\n        this.function = fn;\n        this.schema = fn.schema;\n        this.columns = response.columns;\n        this.rows = response.result;\n    }\n    map(fn) {\n        return this.rows\n            .map(\n                function (row) {\n                    return new FunctionResult(this.function, {\n                        columns: this.columns,\n                        result: [row],\n                    });\n                }.bind(this)\n            )\n            .map(fn);\n    }\n    forEach(fn) {\n        return this.rows\n            .map(\n                function (row) {\n                    return new FunctionResult(this.function, {\n                        columns: this.columns,\n                        result: [row],\n                    });\n                }.bind(this)\n            )\n            .forEach(fn);\n    }\n    related_rows(\n        self_column_name,\n        related_relation_name,\n        related_column_name,\n        options\n    ) {\n        var relation_parts = related_relation_name.split('.');\n        if (relation_parts.length < 2) {\n            console.error(\n                'Related relation name must be schema qualified (schema_name.relation_name)'\n            );\n            /* throw "Related relation name must be schema qualified (schema_name.relation_name)"; */\n        }\n\n        var schema_name = relation_parts[0];\n        var relation_name = relation_parts[1];\n        var db = this.function.schema.database;\n\n        var values = this.map(function (row) {\n            return row.get(self_column_name);\n        });\n\n        options = options || {};\n        options.where =\n            options.where instanceof Array\n                ? options.where\n                : typeof options.where == 'undefined'\n                    ? []\n                    : [options.where];\n        options.where.push({\n            name: related_column_name,\n            op: 'in',\n            value: values,\n        });\n\n        return db.schema(schema_name).relation(relation_name).rows(options);\n    }\n    related_row(\n        self_column_name,\n        related_relation_name,\n        related_column_name,\n        options\n    ) {\n        var relation_parts = related_relation_name.split('.');\n        if (relation_parts.length < 2) {\n            console.error(\n                'Related relation name must be schema qualified (schema_name.relation_name)'\n            );\n            /* throw "Related relation name must be schema qualified (schema_name.relation_name)"; */\n        }\n\n        var schema_name = relation_parts[0];\n        var relation_name = relation_parts[1];\n        var db = this.function.schema.database;\n\n        var values = this.map(function (row) {\n            return row.get(self_column_name);\n        });\n\n        options = options || {};\n        options.where =\n            options.where instanceof Array\n                ? options.where\n                : typeof options.where == 'undefined'\n                    ? []\n                    : [options.where];\n        options.where.push({\n            name: related_column_name,\n            op: 'in',\n            value: values,\n        });\n\n        return db.schema(schema_name).relation(relation_name).row(options);\n    }\n}
\\x16cedf80ade01c62bdd1ae931d0492330c0b62bf294c08c095ce2fab21a9298d	js
\\x1e8b1db39250d6446486b0fb92d71bd04e0eda7546fb4661e0bca1025626154f	export function uuid() {\n  const d = new Date().getTime();\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(\n    /[xy]/g,\n    function (c) {\n      const r = (d + Math.random() * 16) % 16 | 0;\n      d = Math.floor(d / 16);\n      return (c == 'x' ? r : (r & 0x7) | 0x8).toString(16);\n    }\n  );\n}\n\nexport function getPersistedSessionId() {\n    return sessionStorage.getItem('sessionId') || null;\n}\n\nexport function persistSessionId(sessionId) {\n    if (sessionId) {\n        sessionStorage.setItem('sessionId', sessionId);\n    }\n}\n\nexport class Callbacks {\n    constructor() {\n        this.map = new Map();\n    }\n    call(cbType, payload) {\n        const callbacks = this.map.get(cbType) || [];\n        for (const callback of callbacks) {\n            callback(payload);\n        }\n    }\n    add(cbType, cb) {\n        this.map.set(\n            cbType,\n            this.map.has(cbType) ? this.map.get(cbType).concat(cb) : [cb]\n        );\n    }\n    remove(cbType, cb) {\n        const callbacks = this.map.get(cbType);\n        if (callbacks) {\n            this.map.set(\n                cbType,\n                callbacks.filter((callback) => callback !== cb)\n            );\n        }\n    }\n}
\\x1f679d9ba17102fe3711460718f55034c97376a18a0e4d366fe24b1fc693da06	datum-plv8
\\x22987eb4d2046647bedea009c6f38e31586d2951c8a3a480878f4b6d4ab9f805	import db from '/org.aquameta.core.endpoint/widget.module/datum@0.3.1.js';\nimport { track, untrack } from './widget-tracker@1.0.0.js';\n\n/**\n * TODO: Could be overkill...\n *  but if widget had an api for managing state, we'd be able to serialized state\n *  and replace a widget with an updated copy\n * \n * Maybe like Lit:\n *  static properties = { a: {}, b: {} }\n */\n\n/**\n * TODO: fsm integration - so many ways to do this\n *  this would help with managing state since most state would need to be in the fsm?\n * this.widgetMachine = machine;\n */\n\n/**\n * TODO:\n * - How would this work with replacing inner contents with new widget contents?\n * - What happens to the state of child elements?\n * - I guess that's the rub, child state is lost because you edited the parent widget. That's fine.\n */\n\n// TODO: Should use an external store for this, so different versions of WidgetElement can still communicate\nconst widgets = new Set();\n\nexport function WidgetElement(meta, BaseClass) {\n    const { error, metadata } = validateMeta(meta);\n    if (error) {\n        console.log(error);\n        metadata.widgetName = meta;\n    }\n    // TODO: Instead of a set, this should be a map to the current tag name\n    widgets.add(metadata.widgetName);\n    if (!BaseClass) {\n        let request = null;\n        return class extends HTMLElement {\n            static widgetName = metadata.widgetName;\n            #widgetBindingMap = {};\n            #widgetBindings = {};\n            constructor() {\n                super();\n                this._metadata = metadata;\n                this.attachShadow({ mode: 'open' });\n                const attributes = {};\n                for (const attr of this.getAttributeNames()) {\n                    attributes[attr] = this.getAttribute(attr);\n                }\n                if (!request) {\n                    // TODO: this needs to be bundle aware\n                    //  - so we get the widget that is bundled by the calling widget\n                    //  - this will get the wrong html/css for this js component\n                    request = db.schema('widget').table('widget').row('name', this._metadata.widgetName)\n                        .then(widget => {\n                            this._metadata.widgetId = widget.get('id');\n                            const template = document.createElement('template');\n                            template.innerHTML = getInnerHtml(widget, attributes);\n                            return template;\n                        });\n                }\n            }\n            connectedCallback() {\n                const parentPromise = findParentWidget(this.shadowRoot).then(parent => {\n                    this._metadata.parent = parent;\n                });\n                request.then(template => {\n                    // put widget in dom\n                    this.shadowRoot.appendChild(template.content.cloneNode(true));\n                    // find all widget bindings\n                    for (const [binding, selector] of Object.entries(this.#widgetBindingMap)) {\n                        this.#widgetBindings[binding] = this.shadowRoot.querySelector(selector);\n                    }\n                    // call back to let widget know it is connected\n                    if (this.onWidgetConnected) {\n                        // ensure all metadata is populated before connecting widget\n                        parentPromise.then(() => {\n                            this.onWidgetConnected();\n                        });\n                    }\n                });\n                // TODO: is this `track` useful? We are already creating a tree of widgets when the component connects\n                track(this._metadata, this);\n            }\n            disconnectedCallback() {\n                untrack(this);\n            }\n            widgetBind(bindingMap) {\n                this.#widgetBindingMap = bindingMap;\n                return this.#widgetBindings;\n            }\n        }\n    } else {\n        // TODO: setting a static member on a base class. Does this even work without conflicting with other components?\n        // TODO: can we add a mixin to this class that won't interfere but will still allow us to get import.meta and track it\n        BaseClass.widgetName = metadata.widgetName;\n        return class extends BaseClass {\n            static widgetName = metadata.widgetName;\n            constructor() {\n                super();\n                this._metadata = metadata;\n            }\n            connectedCallback() {\n                if (super.connectedCallback) {\n                    super.connectedCallback();\n                }\n                // TODO: what if component doesnt have shadow root\n                const parentPromise = findParentWidget(this.shadowRoot).then(parent => {\n                    this._metadata.parent = parent;\n                    if (this.onWidgetConnected) {\n                        this.onWidgetConnected();\n                    }\n                });\n                track(this._metadata, this);\n            }\n            disconnectedCallback() {\n                if (super.disconnectedCallback) {\n                    super.disconnectedCallback();\n                }\n                untrack(this);\n            }\n        }\n    }\n}\n\n// TODO: Why is this async?\nasync function findParentWidget(root) {\n    if (!root) {\n        return null;\n    }\n    // TODO: don't use getRootNode. traverse manually to find tagNames in widgets Set\n    //  - also not sure its worth it for defining semantics lookup because slots would cause problems\n    let parent = null;\n    let node = root.host.getRootNode().host;\n    while (node && node !== document.body) {\n        if (!node.tagName) {\n            break;\n        }\n        if (widgets.has(node.tagName.toLowerCase())) {\n            parent = node;\n            break;\n        }\n        node = node.getRootNode().host;\n    }\n    return parent;\n}\n\n// TODO: provide a subscription method to intercept this and add a dev\n// parameter e.g. 'test-widget' -> 'test-widget-1'\nexport function register(Element, options) {\n    customElements.define(Element.widgetName, Element, options);\n    return (attributes) => {\n        const el = document.createElement(Element.widgetName);\n        for (const [key, value] of Object.entries(attributes)) {\n            // TODO: Could support a mix of things here\n            //  * strings are attributes\n            //  * objects are properties\n            //  * objects with object.attribute=true, object.value is a attribute\n            //  * objects with object.attribute=false, object.value is a property\n            if (typeof value !== 'object') {\n                el.setAttribute(key, value);\n            } else if (Object.hasOwn(value, 'attribute')) {\n                if (value.attribute) {\n                    el.setAttribute(key, value.value);\n                } else {\n                    el[key] = value.value;\n                }\n            } else {\n                el[key] = value;\n            }\n        }\n        return el;\n    }\n}\n\n// TODO: figure out most efficient way to add css\n// - Does this causes page bloat?\n// - Is it better to add a css import here?\nfunction getInnerHtml(widget, attributes) {\n    let contents = `<style>${widget.get('css') || ''}</style>${widget.get('html') || ''}`;\n    for (const [key, value] of Object.entries(attributes)) {\n        contents = contents.replaceAll(`{attrs.${key}}`, value);\n    }\n    return contents;\n}\n\nfunction validateMeta(meta) {\n    const metadata = {\n        bundleName: null,\n        widgetName: null,\n    }\n    if (!meta) {\n        return {\n            error: 'WidgetElement must be passed `import.meta` to instantiate',\n            metadata,\n        };\n    }\n    if (typeof meta === 'string') {\n        return {\n            error: `WidgetElement wrapper function should be passed import.meta, not a tag name: ${meta}`,\n            metadata,\n        };\n    }\n    const url = meta.url.replace(window.location.origin, '');\n    const [_, bundle, relation, widget] = url.split('/');\n    if (!bundle || !relation || !widget) {\n        return {\n            error: 'WidgetElement must be imported with bundle url',\n            metadata,\n        };\n    }\n    metadata.bundleName = bundle;\n    metadata.widgetName = widget.replace(/\\.js$/, '');\n    if (relation !== 'widget.component') {\n        return {\n            error: 'WidgetElement must be defined in widget.widget table and imported the standard way',\n            metadata,\n        };\n    }\n    return { error: null, metadata };\n}
\\x25d6c52c36b7b0e874cc0c8fe045c2f463051cae601dbb3fdb433c3077bdf3bc	79ab4b40-c5cc-4e79-b6a5-374da3397557
\\x276a0c979db080af8089ac4da0bd99896eefd3a830c654e9c4e8f8416f63f26f	64840ccf-f961-4d3c-ae35-c30aa4f37166
\\x27a20a98248b1b1da6c836db0f17cb342f7aa7661b2a6d273e0a2ad7098513de	import {Row} from './row@0.3.1.js';\nimport {Column} from './column@0.3.1.js';\nimport {Field} from './field@0.3.1.js';\nimport {Callbacks} from './util@0.3.1.js';\n\nfunction rowId(relId, pkValue) {\n    return {\n        url() {\n            return (\n                '/row/' + relId.schema_id.name + '/' + relId.name + '/' + pkValue\n            );\n        },\n    };\n}\n\nexport class Rowset {\n    constructor(relation, response, server_arguments) {\n        this.relation = relation;\n        this.schema = relation.schema;\n        this.columns = response.columns || null;\n        this.pk_column_name = response.pk || null;\n        this.rows = response.result;\n        this.length = response.result.length;\n        this.server_arguments = server_arguments || {};\n        this.callbacks = new Callbacks();\n    }\n    map(fn) {\n        return this.rows\n            .map(\n                function (row) {\n                    return new Row(this.relation, {\n                        columns: this.columns,\n                        pk: this.pk_column_name,\n                        result: [row],\n                    });\n                }.bind(this)\n            )\n            .map(fn);\n    }\n    forEach(fn) {\n        const newRow = (row) => {\n            return new Row(this.relation, {\n                columns: this.columns,\n                pk: this.pk_column_name,\n                result: [row],\n            });\n        };\n        this.onInsert(fn);\n        this.rows.map(newRow).forEach(fn);\n        return this;\n    }\n    reload() {\n        return this.relation.rows(this.server_arguments);\n    }\n    _triggerEvent(eventType, payload, newRowId) {\n        const relId = this.relation.id;\n        const pkColumn = this.pk_column_name;\n        const rowIdStr = rowId(\n            newRowId.pk_column_id.relation_id,\n            newRowId.pk_value\n        ).url();\n        // TODO: need a rewrite on datum to fix this\n        // imitate api response to create row\n        const newRow = (row, pk) => {\n            return new Row(this.relation, {\n                columns: this.columns,\n                pk: pk || this.pk_column_name,\n                result: [row],\n            });\n        };\n        switch (eventType) {\n            case 'insert': {\n                const completeRow = { row: payload };\n                this.rows.push(completeRow);\n                payload = newRow(completeRow);\n                break;\n            }\n            case 'update': {\n                // TODO: I think payload is only the update fields, may need to reconstruct real row\n                let index = this.rows.findIndex(\n                    ({ row }) => rowId(relId, row[pkColumn]).url() === rowIdStr\n                );\n                if (index < 0) {\n                    console.error(\n                        'Rowset: trying to trigger update on nonexistant row'\n                    );\n                    break;\n                }\n                const completeRow = { row: { ...this.rows[index].row, ...payload } };\n                this.rows[index] = completeRow;\n                payload = newRow(completeRow, pkColumn);\n                break;\n            }\n            case 'delete': {\n                // TODO: I think payload is only the row_id, may need to reconstruct real row\n                let index = this.rows.findIndex(\n                    (row) => rowId(relId, row[pkColumn]).url() === rowIdStr\n                );\n                if (!index) {\n                    console.error(\n                        'Rowset: trying to trigger delete on nonexistant row'\n                    );\n                    break;\n                }\n                this.rows.splice(index, 1);\n                payload = rowIdStr;\n                break;\n            }\n        }\n        this.callbacks.call(eventType, payload);\n    }\n    onInsert(fn) {\n        // TODO: maybe get rid of string\n        this.callbacks.add('insert', fn);\n    }\n    onUpdate(fn) {\n        // TODO: can you update a rowset?\n        this.callbacks.add('update', fn);\n    }\n    onDelete(fn) {\n        this.callbacks.add('delete', fn);\n    }\n\n    /**\n      * Call Rowset.where with (where_obj) or use shorthand notation (field, value) - filter results programmatically\n      *\n      * @param {Object} where_obj\n      * @param {[Boolean]} return_first\n      * @param {[Boolean]} async\n      *\n      * OR\n      *\n      * @param {String} field\n      * @param {Any} value\n      * @param {[Boolean]} return_first\n      * @param {[Boolean]} async\n      *\n      * @returns {Promise}\n      */\n    where() {\n        var first = false,\n            async = true,\n            where_obj = {};\n        if (typeof arguments[0] == 'object') {\n            // Rowset.where(where_obj [, return_first] [, async]);\n            where_obj = arguments[0];\n            var field = where_obj.field;\n            var value = where_obj.value;\n            if (arguments.length > 1) first = arguments[1];\n            if (arguments.length > 2) async = arguments[2];\n        } else if (typeof arguments[0] == 'string' && arguments.length > 1) {\n            // Rowset.where(field, value [, return_first] [, async]);\n            var field = arguments[0];\n            var value = arguments[1];\n            if (arguments.length > 2) first = arguments[2];\n            if (arguments.length > 3) async = arguments[3];\n        }\n\n        return new Promise(\n            function (resolve, reject) {\n                // TODO lots of logic here\n                // The new rowset that is returned must be in the same format as the response from the server\n\n                if (first) {\n                    for (var i = 0; i < this.rows.length; i++) {\n                        if (this.rows[i].row[field] == value) {\n                            resolve(\n                                new Row(this.relation, {\n                                    columns: this.columns,\n                                    result: [this.rows[i]],\n                                })\n                            );\n                        }\n                    }\n                    reject('could not find ' + field + ' ' + value);\n                } else {\n                    var return_rowset = [];\n                    for (var i = 0; i < this.rows.length; i++) {\n                        if (this.rows[i].row[field] == value) {\n                            return_rowset.push(this.rows[i]);\n                        }\n                    }\n                    resolve(\n                        new Rowset(this.relation, {\n                            columns: this.columns,\n                            result: return_rowset,\n                        })\n                    );\n                }\n\n                // 2\n\n                // maybe we don't need to search the entire row and instead we return the first item found\n                /*\n                    var new_rowset = _.filter(this.rows, function(el) {\n                        //return equals.call(this, el[field], val);\n                    });\n          */\n                if (new_rowset.length == 1) {\n                    return new Row(this.relation, new_rowset);\n                } else if (new_rowset.length > 1) {\n                    throw 'Multiple Rows Returned';\n                }\n\n                // if row does not exist\n                return null;\n            }.bind(this)\n        );\n    }\n    order_by(column, direction) {\n        /*\n            var ordered = _.sortBy(this.rows, function(el) {\n                return el.row[column];\n            });\n      */\n        if (direction !== 'asc') {\n            ordered.reverse();\n        }\n        return new Rowset(this.relation, {\n            columns: this.columns,\n            result: ordered,\n        });\n    }\n    limit(lim) {\n        if (lim <= 0) {\n            throw 'Bad limit';\n        }\n        return new Rowset(this.relation, {\n            columns: this.columns,\n            result: this.rows.slice(0, lim),\n        });\n    }\n    related_rows(\n        self_column_name,\n        related_relation_name,\n        related_column_name,\n        options\n    ) {\n        var relation_parts = related_relation_name.split('.');\n        if (relation_parts.length < 2) {\n            console.error(\n                'Related relation name must be schema qualified (schema_name.relation_name)'\n            );\n            // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n        }\n\n        var schema_name = relation_parts[0];\n        var relation_name = relation_parts[1];\n        var db = this.relation.schema.database;\n\n        var values = this.map(function (row) {\n            return row.get(self_column_name);\n        });\n\n        options = options || {};\n        options.where =\n            options.where instanceof Array\n                ? options.where\n                : typeof options.where == 'undefined'\n                    ? []\n                    : [options.where];\n        options.where.push({\n            name: related_column_name,\n            op: 'in',\n            value: values,\n        });\n\n        return db.schema(schema_name).relation(relation_name).rows(options);\n    }\n    related_row(\n        self_column_name,\n        related_relation_name,\n        related_column_name,\n        options\n    ) {\n        var relation_parts = related_relation_name.split('.');\n        if (relation_parts.length < 2) {\n            console.error(\n                'Related relation name must be schema qualified (schema_name.relation_name)'\n            );\n            // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n        }\n\n        var schema_name = relation_parts[0];\n        var relation_name = relation_parts[1];\n        var db = this.relation.schema.database;\n\n        var values = this.map(function (row) {\n            return row.get(self_column_name);\n        });\n\n        options = options || {};\n        options.where =\n            options.where instanceof Array\n                ? options.where\n                : typeof options.where == 'undefined'\n                    ? []\n                    : [options.where];\n        options.where.push({\n            name: related_column_name,\n            op: 'in',\n            value: values,\n        });\n\n        return db.schema(schema_name).relation(relation_name).row(options);\n    }\n}\n
\\x3549b0028b75d981cdda2e573e9cb49dedc200185876df299f912b79f69dabd8	database
\\x3a977f7685dc91e51e197b3feaa9fb9a13b5f0cc5fc07344dcc397f84dd76677	7c8ed3e3-e83d-416b-a836-492620b88090
\\x3b0e735bb094f4159106949505ef91b36b5c14062624418d2ffda78206dd7975	export class Column {\n    constructor(relation, name) {\n        this.relation = relation;\n        this.name = name;\n        this.id = { relation_id: relation.id, name: name };\n    }\n}
\\x3b5019fc08a9fb748e1738a3f8540a7b46937c6faa493ddbd9541b6bbf227d45	55dcddd1-0b18-4ef1-a789-3d565c7114bf
\\x40315a6d0e19564e3d06eb4ad09762bb61308700432f5dac792c115a065017e6	// Note: Add `?events=false` to a url to stop all events\nconst query = new Set(location.search.slice(1).split('&'));\n\nexport class Socket {\n  constructor(handleEvent) {\n    this.handleEvent = handleEvent;\n    this.isAttached = false;\n    this.sessionId = null;\n    this.intendedSessionId = null;\n    this._socket = io('/');\n    this._socket.on('event', this.onMessage.bind(this));\n    this._socket.on('connect', () => {\n      if (!this.isAttached) {\n        if (this.sessionId) {\n          this.attach(this.sessionId);\n        } else if (this.intendedSessionId) {\n          this.attach(this.intendedSessionId);\n        }\n        // else { connectSession has not been called yet }\n      }\n    });\n    this._socket.on('disconnect', () => {\n      this.isAttached = false;\n      // socket.io will handle reconnecting\n    });\n    this.cache = {};\n  }\n  onMessage(event) {\n    let response;\n    try {\n      response = JSON.parse(event);\n    } catch (e) {\n      console.error('socket: error while parsing event', e);\n      return;\n    }\n\n    switch (response.type) {\n      case 'attached':\n        this.isAttached = true;\n        this.sessionId = response.sessionId;\n        this.intendedSessionId = null;\n        console.log('socket attached', response.sessionId);\n        break;\n\n      case 'event':\n        this.handleEvent(response.data);\n        break;\n    }\n  }\n  attach(sessionId) {\n    if (!this.sessionId) {\n      this.intendedSessionId = sessionId;\n    }\n    if (this._socket.connected) {\n      if (!sessionId) {\n        console.error('socket error: invalid session id', sessionId);\n      }\n      this._socket.emit('attach', sessionId);\n    }\n    // else { socket will attempt to attach when connected }\n  }\n}
\\x43d0ed05477f70aed2df16f80fa3156051bd577e2f2ba7cb9e5be772bef857a7	\n\nimport db from '/org.aquameta.core.widget/widget.module/datum@0.3.1.js';\nimport { track, untrack } from './widget-tracker@1.0.0.js';\n\n/**\n * TODO: Could be overkill...\n *  but if widget had an api for managing state, we'd be able to serialized state\n *  and replace a widget with an updated copy\n * \n * Maybe like Lit:\n *  static properties = { a: {}, b: {} }\n */\n\n/**\n * TODO: fsm integration - so many ways to do this\n *  this would help with managing state since most state would need to be in the fsm?\n * this.widgetMachine = machine;\n */\n\n/**\n * TODO:\n * - How would this work with replacing inner contents with new widget contents?\n * - What happens to the state of child elements?\n * - I guess that's the rub, child state is lost because you edited the parent widget. That's fine.\n */\n\n// TODO: Should use an external store for this, so different versions of WidgetElement can still communicate\nconst widgets = new Set();\n\nexport function WidgetElement(meta, BaseClass) {\n    const { error, metadata } = validateMeta(meta);\n    if (error) {\n        console.log(error);\n        metadata.widgetName = meta;\n    }\n    // TODO: Instead of a set, this should be a map to the current tag name\n    widgets.add(metadata.widgetName);\n    if (!BaseClass) {\n        let request = null;\n        return class extends HTMLElement {\n            static widgetName = metadata.widgetName;\n            #widgetBindingMap = {};\n            #widgetBindings = {};\n            constructor() {\n                super();\n                this._metadata = metadata;\n                this.attachShadow({ mode: 'open' });\n                const attributes = {};\n                for (const attr of this.getAttributeNames()) {\n                    attributes[attr] = this.getAttribute(attr);\n                }\n                if (!request) {\n                    // TODO: this needs to be bundle aware\n                    //  - so we get the widget that is bundled by the calling widget\n                    //  - this will get the wrong html/css for this js component\nrequest = db.schema('widget').table('component').row('name', this._metadata.widgetName)\n                        .then(widget => {\n                            this._metadata.widgetId = widget.get('id');\n                            const template = document.createElement('template');\n                            template.innerHTML = getInnerHtml(widget, attributes);\n                            return template;\n                        });\n                }\n            }\n            connectedCallback() {\n                const parentPromise = findParentWidget(this.shadowRoot).then(parent => {\n                    this._metadata.parent = parent;\n                });\n                request.then(template => {\n                    // put widget in dom\n                    this.shadowRoot.appendChild(template.content.cloneNode(true));\n                    // find all widget bindings\n                    for (const [binding, selector] of Object.entries(this.#widgetBindingMap)) {\n                        this.#widgetBindings[binding] = this.shadowRoot.querySelector(selector);\n                    }\n                    // call back to let widget know it is connected\n                    if (this.onWidgetConnected) {\n                        // ensure all metadata is populated before connecting widget\n                        parentPromise.then(() => {\n                            this.onWidgetConnected();\n                        });\n                    }\n                });\n                // TODO: is this `track` useful? We are already creating a tree of widgets when the component connects\n                track(this._metadata, this);\n            }\n            disconnectedCallback() {\n                untrack(this);\n            }\n            widgetBind(bindingMap) {\n                this.#widgetBindingMap = bindingMap;\n                return this.#widgetBindings;\n            }\n        }\n    } else {\n        // TODO: setting a static member on a base class. Does this even work without conflicting with other components?        // TODO: can we add a mixin to this class that won't interfere but will still allow us to get import.meta and track it\n        BaseClass.widgetName = metadata.widgetName;\n        return class extends BaseClass {\n            static widgetName = metadata.widgetName;\n            constructor() {\n                super();\n                this._metadata = metadata;\n            }\n            connectedCallback() {\n                if (super.connectedCallback) {\n                    super.connectedCallback();\n                }\n                // TODO: what if component doesnt have shadow root\n                const parentPromise = findParentWidget(this.shadowRoot).then(parent => {\n                    this._metadata.parent = parent;\n                    if (this.onWidgetConnected) {\n                        this.onWidgetConnected();\n                    }\n                });\n                track(this._metadata, this);\n            }\n            disconnectedCallback() {\n                if (super.disconnectedCallbac) {\n                    super.disconnectedCallback();\n                }\n                untrack(this);\n            }\n        }\n    }\n}\n\n// TODO: Why is this async?\nasync function findParentWidget(root) {\n    if (!root) {\n        return null;\n    }\n    // TODO: don't use getRootNode. traverse manually to find tagNames in widgets Set\n    //  - also not sure its worth it for defining semantics lookup because slots would cause problems\n    let parent = null;\n    let node = root.host.getRootNode().host;\n    while (node && node !== document.body) {\n        if (!node.tagName) {\n            break;\n        }\n        if (widgets.has(node.tagName.toLowerCase())) {\n            parent = node;\n            break;\n        }\n        node = node.getRootNode().host;\n    }\n    return parent;\n}\n\n// TODO: provide a subscription method to intercept this and add a dev\n// parameter e.g. 'test-widget' -> 'test-widget-1'\nexport function register(Element, options) {\n    customElements.define(Element.widgetName, Element, options);\n    return (attributes) => {\n        const el = document.createElement(Element.widgetName);\n        for (const [key, value] of Object.entries(attributes)) {\n            // TODO: Could support a mix of things here\n            //  * strings are attributes\n            //  * objects are properties\n            //  * objects with object.attribute=true, object.value is a attribute\n            //  * objects with object.attribute=false, object.value is a property\n            if (typeof value !== 'object') {\n                el.setAttribute(key, value);\n            } else if (Object.hasOwn(value, 'attribute')) {\n                if (value.attribute) {\n                    el.setAttribute(key, value.value);\n                } else {\n                    el[key] = value.value;\n                }\n            } else {\n                el[key] = value;\n            }\n        }\n        return el;\n    }\n}\n\n// TODO: figure out most efficient way to add css\n// - Does this causes page bloat?\n// - Is it better to add a css import here?\nfunction getInnerHtml(widget, attributes) {\n    let contents = `<style>${widget.get('css') || ''}</style>${widget.get('html') || ''}`;\n    for (const [key, value] of Object.entries(attributes)) {\n        contents = contents.replaceAll(`{attrs.${key}}`, value);\n    }\n    return contents;\n}\n\nfunction validateMeta(meta) {\n    const metadata = {\n        bundleName: null,\n        widgetName: null,\n    }\n    if (!meta) {\n        return {\n            error: 'WidgetElement must be passed `import.meta` to instantiate',\n            metadata,\n        };\n    }\n    if (typeof meta === 'string') {\n        return {\n            error: `WidgetElement wrapper function should be passed import.meta, not a tag name: ${meta}`,\n            metadata,\n        };\n    }\n    const url = meta.url.replace(window.location.origin, '');\n    const [_, bundle, relation, widget] = url.split('/');\n    if (!bundle || !relation || !widget) {\n        return {\n            error: 'WidgetElement must be imported with bundle url',\n            metadata,\n        };\n    }\n    metadata.bundleName = bundle;\n    metadata.widgetName = widget.replace(/\\.js$/, '');\n    if (relation !== 'widget.component') {\n        return {\n            error: 'WidgetElement must be defined in widget.widget table and imported the standard way',\n            metadata,\n        };\n    }\n    return { error: null, metadata };\n}\n\n
\\x47dd56c2c7a7f7aac789ff6a0190ecc9f7508548c7e4f5118bef1622b478fbeb	socket
\\x481786c0970fc86c1568cbbbbee28906f49f8bc578b555d567fa18b1b3cc27ef	8c908914-724a-46f8-a924-8abed49246eb
\\x5614391dee25a88fc447278570f6502b5aacd63035d5d2e7a2a2936557acbcab	dfe57840-41ac-4ae5-8078-06a9e3482eac
\\x588da0ec9475642b88f9c7f108e09fee427e8cc0fa243dbb8754e78f200664f8	8bc29965-1ab2-45ab-bdd6-ad2f36a2659d
\\x5adf965e0b1cab9851bd63ffd254d4094567e2f233650cdf66bf2b708ebee469	{html}
\\x5aed3b40c04ba9727c3eaa3284b8c73416ec9f642085a475372533324fb7eb82	plv8.elog(WARNING,'Loading datum-plv8.js......');\n\nvar AQ = AQ || {};\n\nAQ.uuid = function() {\n    var d = new Date().getTime();\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = (d + Math.random()*16)%16 | 0;\n        d = Math.floor(d/16);\n        return (c=='x' ? r : (r&0x7|0x8)).toString(16);\n    });\n}\n\n\nfunction query_options( options ) {\n\n    var keys = [];\n\n    if (typeof options != 'undefined') {\n\n        // Meta data defaults to true;\n        if (typeof options.meta_data == 'undefined') {\n            options.meta_data = true;\n        }\n\n        // Map the keys of the options object to an array of encoded url components\n        Object.keys(options).sort().map(function(key_name) {\n\n            var key = options[key_name];\n\n            switch(key_name) {\n\n                case 'where':\n                    // where: { name: 'column_name', op: '=', value: 'value' }\n                    // where: [{ name: 'column_name', op: '=', value: 'value' }]\n                    if (typeof key.length == 'undefined') key = [key];\n\n                    return key.map(function(where) {\n                        return 'where=' + encodeURIComponent(JSON.stringify(where));\n                    }).join('&');\n\n                case 'order_by':\n                    // So many possibilities...\n                    // order_by: '-?column_name'\n                    // order_by: ['-?column_name']\n                    // order_by: { 'column_name': 'asc|desc' }\n                    // order_by: [{ 'column_name': 'asc|desc' }]\n                    // order_by: { column: 'column_name', direction: 'asc|desc' }\n                    // order_by: [{ column: 'column_name', direction: 'asc|desc' }]\n                    if (typeof key.length == 'undefined') key = [key];\n\n                    return key_name + '=' + encodeURIComponent(key.map(function(o,i) {\n                        return ((typeof o.direction != 'undefined' && o.direction != 'asc') ? '-' : '') + o.column;\n                    }).join(','));\n\n                case 'limit':\n                    // limit: number\n                case 'offset':\n                    // offset: number\n                    var parsedNum = parseInt(key);\n                    if (!isNaN(parsedNum)) {\n                        return key_name + '=' + parsedNum;\n                    }\n                    return;\n                case 'meta_data':\n                case 'args':\n                case 'exclude':\n                case 'include':\n                    return key_name + '=' + encodeURIComponent(JSON.stringify(key));\n            }\n        }\n\n                                        // Remove all undefined elements of the array\n                                       ).forEach(function(e) {\n            if (typeof e != 'undefined') keys.push(e);\n        });\n    }\n\n    // Return the query string by joining the array with &'s\n    return keys.length ? '?' + keys.join('&') : '?';\n}\n\n\n\n/*--------------------------------- * Database * ---------------------------------*/\nfunction Endpoint( url ) {\n\n    this.url = url;\n    \n    var resource = function( method, meta_id, args, data ) {\n\n        args = args || {};\n\n        // URLs\n        var id_url = meta_id.to_url(true); // ID part of the URL only\n        var url_without_query = this.url + id_url;\n        var query_ops = query_options(args);\n        var url_with_query = url_without_query + query_ops;\n\n        // Settings object to send with 'fetch' method\n        var init_obj = {\n            method: method\n        };\n\n        // Don't add data on GET requests\n        if (method != 'GET') {\n            init_obj.body = JSON.stringify(data);\n        }\n\n        // var request = fetch(method == 'GET' ? url_with_query : url_without_query, init_obj);\n        var request = {\n            "then": function(f) {\n                plv8.elog(WARNING, 'THEN: this: '+JSON.stringify(this)+', f: '+JSON.stringify(f));\n                return f;\n            },\n            "catch": function(f) {\n                plv8.elog(WARNING, 'CATCH: this: '+JSON.stringify(this)+', f: '+JSON.stringify(f));\n                return f;\n            },\n            "bind": function(f) {\n                plv8.elog(WARNING, 'BIND: this: '+JSON.stringify(this)+', f: '+JSON.stringify(f));\n                return f;\n            }\n        }\n\n        var response = plv8.execute('select * from endpoint.request($1,$2,$3,$4,$5)', [\n            '0.2',\n            method,\n            url_without_query,\n            JSON.stringify(query_ops),\n            '{}'\n        ]);\n\n        plv8.elog(WARNING, 'FAT ASS RESPONSE: '+JSON.stringify(response));\n\n        // Read json stream\n        /*\n        var json = response.json();\n\n        if (response.status >= 200 && response.status < 300) {\n            return json;\n        }\n        */\n        \n        return request;\n    }\n\n/*\n\treturn {\n        url: this.url,\n        get: function( meta_id, args )        { return resource.call(this, 'GET', meta_id, args); }.bind(this),\n        post: function( meta_id, data )       { return resource.call(this, 'POST', meta_id, {}, data); }.bind(this),\n            patch: function( meta_id, data )      { return resource.call(this, 'PATCH', meta_id, {}, data); }.bind(this),\n                delete: function( meta_id, args )     { return resource.call(this, 'DELETE', meta_id, args); }.bind(this)\n};\n*/\n    \n    \n    \n    return {\n        "url": this.url,\n        "get": function( meta_id, args )        { return resource.call(this, 'GET', meta_id, args); },\n        "post": function( meta_id, data )       { return resource.call(this, 'POST', meta_id, {}, data); },\n        "patch": function( meta_id, data )      { return resource.call(this, 'PATCH', meta_id, {}, data); },\n        "delete": function( meta_id, args )     { return resource.call(this, 'DELETE', meta_id, args); }\n    };\n}\n\n\n/*--------------------------------- * Database * ---------------------------------*/\nAQ.Database = function( url, settings ) {\n    this.settings = settings;\n\n    // Not sure which name is better\n    this.endpoint = this.connection = new Endpoint(url);\n    this.query_string = query_options;\n};\nAQ.Database.prototype.constructor = AQ.Database;\nAQ.Database.prototype.schema = function( name ) { return new AQ.Schema(this, name); };\n\n/*--------------------------------- * Schema * ---------------------------------*/\nAQ.Schema = function( database, name ) {\n    this.database = database;\n    this.name = name;\n    this.id = { name: this.name };\n};\nAQ.Schema.prototype.constructor = AQ.Schema;\nAQ.Schema.prototype.relation = function( name )         { return new AQ.Relation(this, name); };\nAQ.Schema.prototype.table = function( name )            { return new AQ.Table(this, name); };\nAQ.Schema.prototype.view = function( name )             { return new AQ.View(this, name); };\nAQ.Schema.prototype.function = function( identifier, args, options )   {\n\n    // Function identifier (name and parameter list)\n    if (typeof identifier == 'object') {\n        var name = identifier.name;\n        var parameter_type_list = identifier.parameters;\n    }\n    // Selecting a function without specifying the parameters\n    else {\n        var name = identifier;\n    }\n\n    options = options || {};\n\n    // Arguments\n    options.args = {};\n\n    // `args = undefined` will pass no arguments into the server-side function\n    if (typeof args != 'undefined') {\n\n        // some_function?args={ kwargs: {} } -- Key/value object\n        if (!(args instanceof Array) && args instanceof Object) {\n            options.args.kwargs = args;\n        }\n        // some_function?args={ vals: [] } -- Array\n        else {\n            if (!(args instanceof Array)) {\n                // Regular value is placed into array\n                args = [ args ];\n            }\n            options.args.vals = args;\n        }\n    }\n\n    var fn = new AQ.Function(this, name, parameter_type_list);\n\n    return this.database.endpoint.get(fn, options)\n    .then(function(response) {\n\n        if (!response) {\n            throw 'Empty response';\n        }\n        else if (!response.result.length) {\n            throw 'Result set empty';\n        }\n        if(response.result.length > 1) {\n            return new AQ.FunctionResultSet(fn, response);\n        }\n        return new AQ.FunctionResult(fn, response);\n\n    }.bind(this)).catch(function(err) {\n        throw 'Function call request failed: ' + err;\n    });\n};\n\n/*--------------------------------- * Relation * ---------------------------------*/\nAQ.Relation = function( schema, name ) {\n    this.schema = schema;\n    this.name = name;\n    this.id = { schema_id: this.schema.id, name: this.name };\n};\nAQ.Relation.prototype.constructor = AQ.Relation;\nAQ.Relation.prototype.to_url = function( id_only ) {\n    return id_only ? '/relation/' + this.schema.name + '/' + this.name :\n    this.schema.database.endpoint.url + '/relation/' + this.schema.name + '/' + this.name;\n};\nAQ.Relation.prototype.column = function( name ) {\n    return new AQ.Column(this, name);\n};\nAQ.Relation.prototype.rows = function( options ) {\n\n    return this.schema.database.endpoint.get(this, options)\n    .then(function(rows) {\n\n        if (rows == null) {\n            throw 'Empty response';\n        }/*\n                else if (rows.result.length < 1) {\n                    throw 'No rows returned';\n                }*/\n        return new AQ.Rowset(this, rows, options);\n\n    }.bind(this)).catch(function(err) {\n        throw 'Rows request failed: ' + err;\n    });\n};\nAQ.Relation.prototype.row = function() {\n\n    // Multiple different ways to call 'row' function\n\n    // 1. Calling with Options object\n    if (typeof arguments[0] == 'object') {\n\n        var obj = arguments[0];\n        var args = arguments[1] || {};\n\n        // AQ.Relation.row({ where: { column_name: 'column_name', op: '=', value: 'value' } })\n        // Maybe it should be this one: AQ.Relation.row({ where: { column_name: value } })\n        if (typeof obj.where != 'undefined') {\n            args.where = obj.where;\n        }\n        // AQ.Relation.row({ column_name: 'column_name', op: '=', value: 'value' })\n        // Maybe it should be this one: AQ.Relation.row({ column_name: value })\n        else {\n            args.where = obj;\n        }\n\n    }\n    // 2. Calling with column_name and value\n    else if (typeof arguments[0] == 'string') {\n\n        // AQ.Relation.row(column_name, value [, options_obj])\n        var name = arguments[0];\n        var value = arguments[1];\n        var args = arguments[2] || {};\n\n        args.where = { name: name, op: '=', value: value };\n\n    }\n    // 3. Calling AQ.Relation.row() without arguments\n    else {\n        var args = {};\n    }\n\n    return this.schema.database.endpoint.get(this, args)\n    .then(function(row) {\n\n        if (row == null) {\n            throw 'Empty response';\n        }\n        else if (row.result.length == 0) {\n            throw 'No row returned';\n        }\n        else if (row.result.length > 1) {\n            throw 'Multiple rows returned';\n        }\n        return new AQ.Row(this, row);\n\n    }.bind(this)).catch(function(err) {\n        throw 'Row request failed: ' + err;\n    });\n};\n\n/*--------------------------------- * Table * ---------------------------------*/\nAQ.Table = function( schema, name ) {\n    this.schema = schema;\n    this.name = name;\n    this.id = { schema_id: this.schema.id, name: this.name };\n};\nAQ.Table.prototype = Object.create(AQ.Relation.prototype);\nAQ.Table.prototype.constructor = AQ.Table;\nAQ.Table.prototype.insert = function( data ) {\n\n    if (typeof data == 'undefined') {\n        // table.insert({}) is equivalent to table.insert()\n        // both will insert default values\n        data = {};\n    }\n\n    // Return inserted row promise\n    return this.schema.database.endpoint.patch(this, data)\n    .then(function(inserted_row) {\n\n        if (inserted_row == null) {\n            throw 'Empty response';\n        }\n        if (typeof data.length != 'undefined' && data.length > 1) {\n            return new AQ.Rowset(this, inserted_row, null);\n        }\n        return new AQ.Row(this, inserted_row);\n\n    }.bind(this)).catch(function(err) {\n        throw 'Insert failed: ' + err;\n    });\n\n};\n\n/*--------------------------------- * View * ---------------------------------*/\nAQ.View = function( schema, name ) {\n    this.schema = schema;\n    this.name = name;\n    this.id = { schema_id: this.schema.id, name: this.name };\n};\nAQ.View.prototype = Object.create(AQ.Relation.prototype);\nAQ.View.prototype.constructor = AQ.View;\n\n/*--------------------------------- * Rowset * ---------------------------------*/\nAQ.Rowset = function( relation, response, server_arguments ) {\n    this.relation = relation;\n    this.schema = relation.schema;\n    this.columns = response.columns || null;\n    this.pk_column_name = response.pk || null;\n    this.rows = response.result;\n    this.length = response.result.length;\n    this.server_arguments = server_arguments || {};\n};\nAQ.Rowset.prototype.constructor = AQ.Rowset;\nAQ.Rowset.prototype.map = function(fn) {\n    return this.rows.map(function(row) {\n        return new AQ.Row(this.relation, { columns: this.columns, pk: this.pk_column_name, result: [ row ] });\n    }.bind(this)).map(fn);\n};\nAQ.Rowset.prototype.forEach = function(fn) {\n    return this.rows.map(function(row) {\n        return new AQ.Row(this.relation, { columns: this.columns, pk: this.pk_column_name, result: [ row ] });\n    }.bind(this)).forEach(fn);\n};\nAQ.Rowset.prototype.reload = function() {\n    return this.relation.rows(this.server_arguments);\n};\n\n/**\n     * Call AQ.Rowset.where with (where_obj) or use shorthand notation (field, value) - filter results programmatically\n     *\n     * @param {Object} where_obj\n     * @param {[Boolean]} return_first\n     * @param {[Boolean]} async\n     *\n     * OR\n     *\n     * @param {String} field\n     * @param {Any} value\n     * @param {[Boolean]} return_first\n     * @param {[Boolean]} async\n     *\n     * @returns {Promise}\n     */\nAQ.Rowset.prototype.where = function() {\n\n    var first = false, async = true, where_obj = {};\n    if (typeof arguments[0] == 'object') {\n        // AQ.Rowset.where(where_obj [, return_first] [, async]);\n        where_obj = arguments[0];\n        var field = where_obj.field;\n        var value = where_obj.value;\n        if (arguments.length > 1) first = arguments[1];\n        if (arguments.length > 2) async = arguments[2];\n\n    }\n    else if (typeof arguments[0] == 'string' && arguments.length > 1) {\n        // AQ.Rowset.where(field, value [, return_first] [, async]);\n        var field = arguments[0];\n        var value = arguments[1];\n        if (arguments.length > 2) first = arguments[2];\n        if (arguments.length > 3) async = arguments[3];\n    }\n\n    return new Promise(function(resolve, reject) {\n\n        // TODO lots of logic here\n        // The new rowset that is returned must be in the same format as the response from the server\n\n        if (first) {\n            for (var i = 0; i < this.rows.length; i++) {\n                if (this.rows[i].row[field] == value) {\n                    resolve(new AQ.Row(this.relation, { columns: this.columns, result: [ this.rows[i] ] }));\n                }\n            }\n            reject('could not find ' + field + ' ' + value);\n        }\n        else {\n            var return_rowset = [];\n            for (var i = 0; i < this.rows.length; i++) {\n                if (this.rows[i].row[field] == value) {\n                    return_rowset.push(this.rows[i]);\n                }\n            }\n            resolve(new AQ.Rowset(this.relation, { columns: this.columns, result: return_rowset }));\n        }\n\n\n        // 2\n\n        // maybe we don't need to search the entire row and instead we return the first item found\n        /*\n            var new_rowset = _.filter(this.rows, function(el) {\n                //return AQ.equals.call(this, el[field], val);\n            });\n*/\n        if (new_rowset.length == 1) {\n            return new AQ.Row(this.relation, new_rowset);\n        }\n        else if (new_rowset.length > 1) {\n            throw 'Multiple Rows Returned';\n        }\n\n        // if row does not exist\n        return null;\n\n    }.bind(this));\n\n};\nAQ.Rowset.prototype.order_by = function( column, direction ) {\n    /*\n        var ordered = _.sortBy(this.rows, function(el) {\n            return el.row[column];\n        });\n*/\n    if (direction !== 'asc') {\n        ordered.reverse();\n    }\n    return new AQ.Rowset(this.relation, { columns: this.columns, result: ordered });\n};\nAQ.Rowset.prototype.limit = function( lim ) {\n    if (lim <= 0) {\n        throw 'Bad limit';\n    }\n    return new AQ.Rowset(this.relation, { columns: this.columns, result: this.rows.slice(0, lim) });\n};\nAQ.Rowset.prototype.related_rows = function( self_column_name, related_relation_name, related_column_name, options ) {\n\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.relation.schema.database;\n\n    var values = this.map(function(row) {\n        return row.get(self_column_name);\n    });\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: 'in',\n        value: values\n    });\n\n\n    return db.schema(schema_name).relation(relation_name).rows(options);\n};\nAQ.Rowset.prototype.related_row = function( self_column_name, related_relation_name, related_column_name, options ) {\n\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.relation.schema.database;\n\n    var values = this.map(function(row) {\n        return row.get(self_column_name);\n    });\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: 'in',\n        value: values\n    });\n\n    return db.schema(schema_name).relation(relation_name).row(options);\n\n};\n\n/*--------------------------------- * Row * ---------------------------------*/\nAQ.Row = function( relation, response ) {\n    this.relation = relation;\n    this.schema = relation.schema;\n    this.row_data = response.result[0].row;\n\n    this.cached_fields = {};\n    this.columns = response.columns || null;\n    this.pk_column_name = null;\n    this.pk_value = null;\n    this.id = null;\n    this.to_url = function() {\n        console.error('You must call a row with "meta_data: true" in order to use the to_url function');\n        throw 'Datum.js: Programming Error';\n    };\n\n    if (typeof response.pk != 'undefined') {\n        this.pk_column_name = response.pk;\n        this.pk_value = this.get(this.pk_column_name);\n        // this.id = {"pk_column_id":{"relation_id":{"schema_id":{"name":this.schema.name},"name":this.relation.name},"name":this.pk_column_name},"pk_value": this.pk_value}\n        this.id = {\n            pk_column_id: {\n                relation_id: this.relation.id,\n                name: this.pk_column_name\n            },\n            pk_value: this.pk_value\n        };\n\n        this.to_url = function( id_only ) {\n            return id_only ? '/row/' + this.relation.schema.name + '/' + this.relation.name + '/' + /*JSON.stringify(this.pk_value)*/ this.pk_value :\n            this.relation.schema.database.endpoint.url + '/row/' + this.relation.schema.name + '/' + this.relation.name + '/' + /*JSON.stringify(this.pk_value)*/ this.pk_value;\n        };\n\n    }\n};\nAQ.Row.prototype = {\n    constructor: AQ.Row,\n    get: function( name )           { return this.row_data[name]; },\n    set: function( name, value )    { this.row_data[name] = value; return this; },\n    to_string: function()           { return JSON.stringify(this.row_data); },\n    clone: function()               { return new AQ.Row(this.relation, { columns: this.columns, pk: this.pk_column_name, result: [{ row: this.row_data }]}); },\n    field: function( name ) {\n        if (typeof this.cached_fields[name] == 'undefined') {\n            this.cached_fields[name] = new AQ.Field(this, name, name === this.pk_column_name);\n        }\n        return this.cached_fields[name];\n    },\n    fields: function() {\n        if (this.columns != null) {\n            return this.columns.map(function(c) {\n                return this.field(c.name);\n            }.bind(this));\n        }\n        return null;\n    }\n};\nAQ.Row.prototype.update = function() {\n    return this.relation.schema.database.endpoint.patch(this, this.row_data)\n    .then(function(response) {\n\n        if(response == null) {\n            throw 'Empty response';\n        }\n        return this;\n\n    }.bind(this)).catch(function(err) {\n        throw 'Update failed: ' + err;\n    });\n};\nAQ.Row.prototype.delete = function() { \n    return this.relation.schema.database.endpoint.delete(this)\n    .then(function(response) {\n\n        if(response == null) {\n            throw 'Empty response';\n        }\n\n    }).catch(function(err) {\n        throw 'Delete failed: ' + err;\n    });\n};\nAQ.Row.prototype.related_rows = function( self_column_name, related_relation_name, related_column_name, options )  {\n\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.relation.schema.database;\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: '=',\n        value: this.get(self_column_name)\n    });\n\n    return db.schema(schema_name).relation(relation_name).rows(options);\n};\nAQ.Row.prototype.related_row = function( self_column_name, related_relation_name, related_column_name, options ) {\n\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.relation.schema.database;\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: '=',\n        value: this.get(self_column_name)\n    });\n\n    return db.schema(schema_name).relation(relation_name).row(options);\n};\n\n/*--------------------------------- * Column * ---------------------------------*/\nAQ.Column = function( relation, name ) {\n    this.relation = relation;\n    this.name = name;\n    this.id = { relation_id: relation.id, name: name };\n};\nAQ.Column.prototype.constructor = AQ.Column;\n\n/*--------------------------------- * Field * ---------------------------------*/\nAQ.Field = function( row, name, pk ) {\n    this.row = row;\n    this.column = new AQ.Column(row.relation, name);\n    this.is_primary_key = pk;\n    this.name = name;\n    this.value = row.get(name);\n    this.id = { row_id: this.row.id, column_id: this.column.id };\n    this.to_url = function( id_only ) {\n        if (this.row.pk_value == null) {\n            console.error('You must call a row with "meta_data: true" in order to use the to_url function');\n            throw 'Datum.js: Programming Error';\n        }\n        return id_only ? '/field/' + this.row.relation.schema.name + '/' + this.row.relation.name + '/' + /*JSON.stringify(this.row.pk_value)*/ this.row.pk_value + '/' + this.column.name :\n        this.row.relation.schema.database.endpoint.url + '/field/' + this.row.relation.schema.name + '/' + this.row.relation.name + '/' + /*JSON.stringify(this.row.pk_value)*/ this.row.pk_value + '/' + this.column.name;\n    };\n};\nAQ.Field.prototype = {\n    constructor: AQ.Field,\n    get: function()          { return this.row.get(this.name); },\n    set: function(value)     { this.value = value; return this.row.set(this.name, value); },\n    update: function()       { return this.row.update(); } // TODO: This is wrong\n};\n\n/*--------------------------------- * Function * ---------------------------------*/\nAQ.Function = function( schema, name, args ) {\n    this.schema = schema;\n    this.name = name;\n\n    if(args instanceof Array) {\n        this.args = '{' + args.join(',') + '}';\n    }\n    else {\n        this.args = args;\n    }\n\n    this.id = { schema_id: this.schema.id, name: this.name, args: this.args };\n    this.to_url = function( id_only ) {\n        var base_url = id_only ? '' : this.schema.database.endpoint.url;\n        if (typeof this.args != 'undefined') {\n            return base_url + '/function/' + this.schema.name + '/' + this.name + '/' + this.args;\n        }\n        return base_url + '/function/' + this.schema.name + '/' + this.name;\n    };\n};\nAQ.Function.prototype.constructor = AQ.Function;\n\n/*--------------------------------- * Function Result * ---------------------------------*/\nAQ.FunctionResult = function( fn, response ) {\n    this.function = fn;\n    this.schema = fn.schema;\n    this.row_data = response.result[0].row;\n    this.rows = response.result;\n    this.columns = response.columns;\n};\nAQ.FunctionResult.prototype = {\n    constructor: AQ.FunctionResult,\n    get: function( name )           { return this.row_data[name]; },\n    to_string: function()           { return JSON.stringify(this.row_data); }\n};\nAQ.FunctionResult.prototype.map = function(fn) {\n    return this.rows.map(function(row) {\n        return new AQ.FunctionResult(this.function, { columns: this.columns, result: [ row ] });\n    }.bind(this)).map(fn);\n};\nAQ.FunctionResult.prototype.forEach = function(fn) {\n    return this.rows.map(function(row) {\n        return new AQ.FunctionResult(this.function, { columns: this.columns, result: [ row ] });\n    }.bind(this)).forEach(fn);\n};\nAQ.FunctionResult.prototype.related_rows = function( self_column_name, related_relation_name, related_column_name, options )  {\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.function.schema.database;\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: '=',\n        value: this.get(self_column_name)\n    });\n\n    return db.schema(schema_name).relation(relation_name).rows(options);\n};\nAQ.FunctionResult.prototype.related_row = function( self_column_name, related_relation_name, related_column_name, options ) {\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.function.schema.database;\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: '=',\n        value: this.get(self_column_name)\n    });\n\n    return db.schema(schema_name).relation(relation_name).row(options);\n};\n\n/*--------------------------------- * Function Result Set * ---------------------------------*/\nAQ.FunctionResultSet = function( fn, response ) {\n    this.function = fn;\n    this.schema = fn.schema;\n    this.columns = response.columns;\n    this.rows = response.result;\n};\nAQ.FunctionResultSet.prototype.constructor = AQ.FunctionResultSet;\nAQ.FunctionResultSet.prototype.map = function(fn) {\n    return this.rows.map(function(row) {\n        return new AQ.FunctionResult(this.function, { columns: this.columns, result: [ row ] });\n    }.bind(this)).map(fn);\n};\nAQ.FunctionResultSet.prototype.forEach = function(fn) {\n    return this.rows.map(function(row) {\n        return new AQ.FunctionResult(this.function, { columns: this.columns, result: [ row ] });\n    }.bind(this)).forEach(fn);\n};\nAQ.FunctionResultSet.prototype.related_rows = function( self_column_name, related_relation_name, related_column_name, options ) {\n\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.function.schema.database;\n\n    var values = this.map(function(row) {\n        return row.get(self_column_name);\n    });\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: 'in',\n        value: values\n    });\n\n    return db.schema(schema_name).relation(relation_name).rows(options);\n};\nAQ.FunctionResultSet.prototype.related_row = function( self_column_name, related_relation_name, related_column_name, options ) {\n\n    var relation_parts = related_relation_name.split('.');\n    if (relation_parts.length < 2) {\n        console.error("Related relation name must be schema qualified (schema_name.relation_name)");\n        // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n    }\n\n    var schema_name = relation_parts[0];\n    var relation_name = relation_parts[1];\n    var db = this.function.schema.database;\n\n    var values = this.map(function(row) {\n        return row.get(self_column_name);\n    });\n\n    options = options || {};\n    options.where = options.where instanceof Array ? options.where : (typeof options.where == 'undefined' ?  [] : [options.where]);\n    options.where.push({\n        name: related_column_name,\n        op: 'in',\n        value: values\n    });\n\n    return db.schema(schema_name).relation(relation_name).row(options);\n\n};\n\n\n\nvar endpoint = new AQ.Database();\n
\\x61cd79d0b8c4ec03ba3c3ed46a942040626a1991483b28ad1de1e1a7a9cd2c3f	e308c3df-5174-4114-8fa0-99c4acbc66ce
\\x634768dae1474506e4bf7d341890542b09987d7e6aea5d446c02e37581a56954	row
\\x63bf33fe51bbd62f4b38ff3dea918cae934af53ccb727450b5ce17be57e3679e	/widget.js
\\x6514bbbcfc9022be007d768fc75821f8c2c635041813a399856adfe9c45c1889	/{$2}/widget.module/{$3}@{$4}.css
\\x699ec770fcc3d1a0e97410d0e7567abf5f1aeec49da979b087d4ff3ac8d42850	c8b9c599-9d1b-417a-8e29-43080bb7dd88
\\x6b85584d52dc23b2eba2c85475644769bf9395f11f6e9f5d0d33f66575561afb	/*******************************************************************************\n* Widget.js\n*\n* Created by Aquameta Labs, an open source company in Portland Oregon, USA.\n* Project: http://aquameta.com/\n******************************************************************************/\ndefine(['/doT.js', '/jQuery.min.js', '/datum.js'], function(doT, $, AQ, undefined) {\n\n    'use strict';\n\n    doT.templateSettings.strip = false;\n\n    var widget_promises = {};\n    var containers = {};\n    var namespaces = {};\n\n\n    AQ.Widget = {};\n\n\n    AQ.Widget.widget = function ( selector, input, extra ) {\n\n        if (!selector || typeof selector != 'string') {\n            throw "Widget - Selector argument is invalid or missing";\n        }\n\n        // Same namespace as calling widget, instead of global '' namespace\n        var default_namespace = (typeof this != 'undefined' && typeof this.namespace != 'undefined') ? this.namespace : '';\n\n        var is_semantic_dsl_lookup = selector.indexOf('/') != -1;\n\n        // For semantic lookup\n        // * selector is 'semantics/purpose/default_bundle'\n        // * input is AQ.* object\n        // * extra is {} to send to widget\n        if (is_semantic_dsl_lookup) {\n\n            if (!input) {\n                throw "Semantics requires an AQ.* to be passed in";\n            }\n\n            var context = extra || {};\n            var semantics = selector.split('/');\n            var args_object = {};\n\n            // If input is a promise (that will resolve as a Rowset or a Row), resolve it first\n            if (input instanceof Promise) {\n\n                var url_id;\n                var widget_getter = input.then(function(input) {\n\n                    context.datum = input;\n\n                    // These are the same for both Rowset and Row\n                    var endpoint = input.relation.schema.database;\n                    var fn = 'relation_widget';\n                    var type = 'meta.relation_id';\n                    args_object.relation_id = input.relation.id;\n\n                    if (input instanceof AQ.Rowset) {\n                        context.rows = input;\n                        url_id = input.relation.to_url(true);\n                    }\n                    else if (input instanceof AQ.Row) {\n                        context.row = input;\n                        url_id = input.to_url(true);\n                    }\n                    args_object.widget_purpose = semantics[1];\n                    args_object.default_bundle = semantics.length >= 3 ? semantics[2] : 'org.aquameta.core.semantics';\n                    \n                    return endpoint.schema('semantics').function({\n                        name: fn,\n                        parameters: [type,'text','text']\n                    }, args_object, { use_cache: true, meta_data: false });\n\n                });\n\n            }\n            // Else, check which type it is\n            else {\n\n                context.datum = input;\n\n                if (input instanceof AQ.Relation || input instanceof AQ.Table || input instanceof AQ.View) {\n                    var endpoint = input.schema.database;\n                    var fn = 'relation_widget';\n                    var type = 'meta.relation_id';\n                    args_object.relation_id = input.id;\n                    var url_id = input.to_url(true);\n                    context.relation = input;\n                }\n                else if (input instanceof AQ.Row) {\n                    var endpoint = input.relation.schema.database;\n                    var fn = 'relation_widget';\n                    var type = 'meta.relation_id';\n                    args_object.relation_id = input.relation.id;\n                    var url_id = input.to_url(true);\n                    context.row = input;\n                }\n                else if (input instanceof AQ.Rowset) {\n                    var endpoint = input.relation.schema.database;\n                    var fn = 'relation_widget';\n                    var type = 'meta.relation_id';\n                    args_object.relation_id = input.relation.id;\n                    var url_id = input.relation.to_url(true);\n                    context.rows = input;\n                }\n                else if (input instanceof AQ.Column) {\n                    var endpoint = input.relation.schema.database;\n                    var fn = 'column_widget';\n                    var type = 'meta.column_id';\n                    args_object.column_id = input.id;\n                    var url_id = input.relation.to_url(true);\n                    context.column = input;\n                }\n                else if (input instanceof AQ.Field) {\n                    var endpoint = input.row.relation.schema.database;\n                    var fn = 'column_widget';\n                    var type = 'meta.column_id';\n                    args_object.column_id = input.column.id;\n                    var url_id = input.to_url(true);\n                    context.field = input;\n                }\n                \n                args_object.widget_purpose = semantics[1];\n                args_object.default_bundle = semantics.length >= 3 ? semantics[2] : 'org.aquameta.core.semantics';\n                \n                var widget_getter = endpoint.schema('semantics').function({\n                    name: fn,\n                    parameters: [type,'text','text']\n                }, args_object, { use_cache: true, meta_data: false });\n            }\n\n            // Go get this widget - retrieve_promises don't change for calls to the same widget - they are cached by the widget name\n            var widget_retrieve_promise = retrieve(widget_getter, {\n                semantic_selector: selector,\n                url_id: url_id\n            });\n\n        }\n\n        // For regular widget lookup\n        // * selector is '[namespace:]widget_name'\n        // * input is {} to send to widget\n        // * extra is ignored\n        else {\n\n            //var context = typeof input != 'undefined' ? Object.assign({}, input) : {};\n            var context = input || {};\n\n            var name_parts = selector.split(':');\n\n            if (name_parts.length == 1) {\n                // Default namespace lookup\n                context.namespace = default_namespace;\n                context.name = name_parts[0];\n            }\n            else {\n                // Namespaced lookup\n                context.namespace = name_parts[0];\n                context.name = name_parts[1];\n                context.bundle_name = namespaces[context.namespace].bundle_name;\n            }\n\n            // Namespace not found\n            if (!(context.namespace in namespaces)) {\n                throw 'Widget namespace "'+context.namespace+'" has not been imported - Call AQ.Widget.import( bundle_name, namespace, endpoint ) to import bundled widgets to a namespace';\n            }\n    \n            var widget_getter = namespaces[context.namespace].endpoint.schema('widget').function('bundled_widget',\n                [ namespaces[context.namespace].bundle_name, context.name ], {\n                    use_cache: true,\n                    meta_data: false\n                });\n\n            // Go get this widget - retrieve_promises don't change for calls to the same widget - they are cached by the widget name\n            var widget_retrieve_promise = retrieve(widget_getter, {\n                namespace: context.namespace,\n                name: context.name\n            });\n\n        }\n\n        context.id = AQ.uuid();\n\n        // Setup default namespace for child widget\n        context.widget = AQ.Widget.widget.bind({ namespace: context.namespace });\n        context.widget.sync = AQ.Widget.widget.sync;\n\n        // Prepare and render the widget - each prepare_promise is unique because inputs are different - they are cached by the unique uuid created for the context\n        widget_promises[context.id] = prepare(widget_retrieve_promise, context);\n\n        // Return script that calls swap\n        return '<script id="widget-stub_' + context.id  + '" data-widget_id="' + context.id + '">' +\n                  'AQ.Widget.swap($("#widget-stub_' +  context.id  + '"), "' + context.id + '");'  + \n               '</script>';\n\n    }\n\n\n\n    /* Import a bundle name to a local namespace */\n    AQ.Widget.import = function( bundle_name, namespace, endpoint ) {\n\n        namespaces[namespace] = {\n            endpoint: endpoint,\n            bundle_name: bundle_name\n        };\n\n    };\n\n\n    /* Return an array bundle of imported bundle names */\n    AQ.Widget.bundles = function() {\n        return Object.keys(namespaces).map(function(key) {\n            return namespaces[key].bundle_name;\n        });\n    };\n\n\n\n    /* Find the bundle that was imported to this namespace */\n    AQ.Widget.bundle = function( namespace ) {\n        return namespaces[namespace].bundle_name;\n    };\n\n\n\n    /* Find the namespace that uses this bundle */\n    AQ.Widget.namespace = function( bundle_name ) {\n        return Object.keys(namespaces).find(function(namespace) {\n            return namespaces[namespace].bundle_name == bundle_name;\n        });\n    };\n\n\n\n    function retrieve( widget_getter, selector ) {\n\n        if ('semantic_selector' in selector) {\n            var semantic_lookup = true;\n        }\n\n        return widget_getter.then(function(row) {\n\n            // Get all related widget data\n            return Promise.all([\n                row,/* VIEWSIGNORE\n                row.related_rows('id', 'widget.input', 'widget_id', { use_cache: true, meta_data: true, events: false }).catch(function(){ return; }), \n                row.related_rows('id', 'widget.widget_view', 'widget_id', { use_cache: true, meta_data: true, events: false })\n                    .then(function(widget_views) {\n\n                        var db = row.schema.database;\n                        return widget_views.map(function(widget_view) {\n                            var view_id = widget_view.get('view_id');\n                            return db.schema(view_id.schema_id.name).view(view_id.name);\n                        });\n\n                    }).catch(function(err) { return; }), */\n                row.related_rows('id', 'widget.widget_dependency_js', 'widget_id', { use_cache: true, meta_data: true, events: false })\n                    .then(function(deps_js) {\n\n                        if (!deps_js.length) { return; }\n                        return deps_js.related_rows('dependency_js_id', 'widget.dependency_js', 'id', { use_cache: true, meta_data: true, events: false });\n\n                    }).then(function(deps) {\n\n                        return Promise.all(\n\n                            deps.map(function(dep) {\n                                return System.import(dep.field('content').to_url()).then(function(dep_module) {\n                                    //console.log('my module', dep_module);\n                                    \n                                    return {\n                                        url: dep.field('content').to_url(),\n                                        name: dep.get('variable') || 'non_amd_module',\n                                        /* TODO: This value thing is a hack. For some reason, jwerty doesn't load properly here */\n                                        value: typeof dep_module == 'object' ? dep_module[Object.keys(dep_module)[0]] : dep_module\n                                        //value: dep_module\n                                    };\n                                });\n                            })\n                        );\n\n                    }).catch(function() { return; })\n            ]);\n        }).catch(function(err) {\n            if (semantic_lookup) {\n                throw 'Widget not found from semantic lookup with ' + selector.semantic_selector + ' on ' + selector.url_id;\n            }\n            else {\n                throw 'Widget does not exist, ' + selector.namespace + ':' + selector.name;\n            }\n        });\n    };\n\n\n\n    function prepare( retrieve_promise, context ) {\n\n        return retrieve_promise.then(function( widget_data ) {\n\n            //console.log('retrieve_promise resolved', widget_data);\n\t\t\tvar [ widget_row,  /* inputs, VIEWSIGNORE views, */ deps_js ] = widget_data;\n\n            context.name = widget_row.get('name');\n\n            var xinput = context;\n            context = Object.assign({\n                    db: widget_row.schema.database,\n                    endpoint: widget_row.schema.database,\n                    input: {},\n                    xinput: xinput\n                }, context);\n\n            delete context.xinput.id;\n            delete context.xinput.name;\n            delete context.xinput.namespace;\n            delete context.xinput.widget;\n\n            // Process inputs\n            if (typeof inputs != 'undefined') {\n\n                inputs.forEach(function(input) {\n                    var input_name = input.get('name');\n\n                    if (typeof context[input_name] == 'undefined') {\n                        if (input.get('optional')) {\n                            var default_code = input.get('default_value');\n                            try {\n\n                                if (default_code) {\n                                    context[input_name] = eval('(' + default_code + ')');\n                                }\n                                else {\n                                    context[input_name] =  undefined;\n                                }\n\n                            }\n                            catch (e) {\n                                error(e, context.name, "Widget default eval failure: " + default_code);\n                                /*\n                                console.error("Widget default eval failure", default_code);\n                                throw e;\n                                */\n                            }\n\n                        }\n                        else {\n                            error('Missing required input ' + input_name, context.name, 'Inputs');\n                        }\n                    }\n                    context.input[input_name] = context[input_name];\n                    delete context.xinput[input_name];\n                });\n            }\n\n            // Load views into context\n            if (typeof views != 'undefined') {\n                views.forEach(function(view) {\n                    context[view.schema.name + '_' + view.name] = view;\n                });\n            }\n\n            var rendered_widget = render(widget_row, context);\n            var post_js_function = create_post_js_function(widget_row, context, deps_js);\n\n            // Return rendered widget and post_js function\n            return {\n                html: rendered_widget,\n                widget_id: context.id,\n                widget_name: context.name,\n                post_js: post_js_function\n            };\n\n        });\n    };\n\n\n\n    function render( widget_row, context ) {\n\n        // Create html template\n        var html_template = doT.template(widget_row.get('html') || '');\n\n        // Compile html template\n        try {\n            var html = html_template(context);\n        } catch(e) {\n            error(e, context.name, 'HTML');\n        }\n\n        // Render html\n        try {\n            var rendered = $(html).attr('data-widget', context.name)\n                .attr('data-widget_id', context.id)\n                .attr('data-bundle_alias', context.namespace)\n                .attr('data-bundle_name', context.bundle_name)\n                .attr('data-widget_row_id', widget_row.get('id'))\n                .data('help', widget_row.get('help'));\n        } catch(e) {\n            error(e, context.name, 'HTML (adding data-* attributes)');\n        }\n                                \n        // If CSS exists and has not yet been applied\n        if (widget_row.get('css') != null && $('style[data-widget="' + context.name + '"]').length == 0) {\n\n            // Create css template\n            var css_template = doT.template(widget_row.get('css') || '');\n\n            // Try to run css template\n            try {\n                var css = css_template(context);\n            } catch(e) {\n                error(e, context.name, 'CSS');\n            }\n\n            // Add css to dom\n            $('<style type="text/css" data-widget="' + context.name + '">' + css + '</style>').appendTo(document.head);\n        }\n\n        return rendered;\n    };\n\n\n\n    function create_post_js_function( widget_row, context, deps_js ) {\n\n        var context_keys = Object.keys(context).sort();\n\n        // Get context values\n        var context_vals = context_keys.map(function(key) {\n            return context[key];\n        });\n\n        // Dependency names and values\n        var dep_names = [],\n            dep_values = [];\n        if (deps_js != null) {\n            deps_js.forEach(function(dep_js) {\n                dep_names.push(dep_js.name);\n                dep_values.push(dep_js.value);\n            });\n        }\n\n        try {\n            /*\n            * Creating an script that looks like this\n            * function(dep1_name, dep2_name, ...) {\n            *   function(input1, input2) {\n            *       post_js\n            *   }.apply(this.this.context_vals);\n            * }.apply(this, this.dep_vals);\n            */\n            var post_js = Function(\n                '(function(' + dep_names.join(',') + ') { \\n' +\n                    '(function(' + context_keys.join(',') + ') { \\n' +\n                        'var w = $("#"+id);\\n\\n' +\n                        widget_row.get('post_js') +\n                        '\\n//# sourceURL=' + widget_row.get('id') + '/' + widget_row.get('name') + '/post_js\\n' +\n                    '}).apply(this, this.context_vals);' +\n                '}).apply(this, this.dep_values);'\n            ).bind({ context_vals: context_vals, dep_values: dep_values });\n        }\n        catch(e) {\n            error(e, widget_row.get('name'), 'Creating post_js function');\n        }\n\n        return post_js;\n\n    };\n\n\n    // detect svg widgets by tag name.  might be better to check the dom to see if we're inside an svg tag?\n    AQ.Widget.is_svg = function( e ) {\n        var svg_tags = ['circle','rect','polygon','g']; // TODO: add more, or change approach?\n        for (var i=0;i<svg_tags.length;i++) {\n            if (e.tagName.toUpperCase() == svg_tags[i].toUpperCase()) {\n                // console.log('svg  widget: ' + svg_tags[i]);\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n\n    AQ.Widget.swap = function( $element, id ) {\n        widget_promises[id].then(function(rendered_widget) {\n\n            // Replace stub\n            // special case for svg elements - http://stackoverflow.com/questions/3642035/jquerys-append-not-working-with-svg-element\n            if (AQ.Widget.is_svg(rendered_widget.html[0])) { // TODO: is there ever a case where there is more than one element in this array?\n                var div = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');\n                div.innerHTML= '<svg xmlns="http://www.w3.org/2000/svg">'+rendered_widget.html[0].outerHTML+'</svg>';\n\n                var frag= document.createDocumentFragment();\n                while (div.firstChild.firstChild)\n                    frag.appendChild(div.firstChild.firstChild);\n\n                $element.replaceWith(frag);\n            }\n            else $element.replaceWith(rendered_widget.html);\n\n            // Run post_js - or this may have to be done with a script tag appended to the widget\n            try {\n                rendered_widget.post_js();\n            }\n            catch(e) {\n                error(e, rendered_widget.widget_name, 'Running post_js function');\n            }\n\n            var w = $('#' + rendered_widget.widget_id);\n\n            // notify the world that a widget has loaded.  debugger uses this to detect widget tree changes\n            w.trigger('widget_loaded', { widget: w });\n\n            // Delete prepeared_promise\n            delete widget_promises[id];\n\n        }).catch(function(error) {\n            //console.error('Widget swap failed - ', error);\n            console.error(error);\n            // Remove stub\n            $element.remove();\n            // Delete promise\n            delete widget_promises[id];\n        });\n    };\n\n\n\n    function error( err, widget_name, step_name ) {\n        console.error("widget('" + widget_name + "', ...) " + step_name + " failed!");\n        //window.setTimeout(function() { throw err; }, 100);\n        throw err;\n    }\n\n\n\n    AQ.Widget.sync = function(rowset_promise, container, widget_maker, handlers) {\n\n        if(handlers === undefined) {\n            handlers = {};\n        }\n\n        if (widget_maker === undefined) {\n            throw 'widget.sync missing widget_maker argument';\n        }\n\n        if (container.length < 1) {\n            throw 'widget.sync failed: The specified container is empty or not found';\n            return;\n        }\n\n        if (container.length > 1) {\n            throw 'widget.sync failed: The specified container contains multiple elements';\n            return;\n        }\n\n        if (!container instanceof jQuery) {\n            throw 'widget.sync failed: The specified container is not a jQuery object';\n            return;\n        }\n\n        if (typeof rowset_promise == 'undefined' ||\n            (!(rowset_promise instanceof Promise) && !(rowset_promise instanceof AQ.Rowset) && !(rowset_promise instanceof AQ.FunctionResultSet))) {\n            throw 'widget.sync failed: rowset_promise must be a "thenable" promise or a resolved AQ.Rowset or a resolved AQ.FunctionResultSet';\n        }\n\n        if (!(rowset_promise instanceof Promise)) {\n            rowset_promise = Promise.resolve(rowset_promise);\n        }\n\n        rowset_promise.then(function(rowset) {\n\n            if (typeof rowset == 'undefined' || typeof rowset.forEach == 'undefined') {\n                throw 'Rowset is not defined. First argument to widget.sync must return a Rowset';\n            }\n\n            var container_id = AQ.uuid();\n\n            container.attr('data-container_id', container_id)\n            containers[container_id] = {\n                container: container,\n                widget_maker: widget_maker,\n                handlers: handlers\n            };\n\n            rowset.forEach(function(row) {\n                container.append(widget_maker(row));\n            });\n\n        }).catch(function(error) {\n            console.error('widget.sync failed: ', error);\n        });\n\n    }\n\n    // duplicate name for backwards compatibility\n    AQ.Widget.widget.sync = AQ.Widget.sync;\n\n    return AQ.Widget.widget;\n\n});\n
\\x6df662ab2db09565b9034bf91634d6d5bd007fdedd1d52aabb6462d076cf9777	3b87935c-120a-4823-81ac-84ce4fac168c
\\x6fe7df9fa0b972c4179e507282363bea6984db19fe86d2ae87daeeb6685387d6	export function track(widgetName, instance) {\n  console.log('track');\n}\n\nexport function untrack(instance) {\n  console.log('untrack');\n}\n
\\x71bf214f3e802d8bfc34d3f40fba0a84aa24a08caa29e100eef93f9f89b3ad87	29d13543-56d0-4aa0-b192-d921bcb2dafb
\\x72679365493aa62487459e1f599908cbb37f2c45450e9e8f2140cb7a91e7de76	676289b8-e862-4540-8493-2880f8183fb9
\\x72d000bb3245310d436f78610cc69a66e287feb4049334727054b3ed1cc26214	widget-tracker
\\x73b6f2117379f5d9a273050320ca19a817128c82c854401356abf4dba4ea4c38	import { Rowset } from './rowset@0.3.1.js';\nimport { Row } from './row@0.3.1.js';\nimport { Column } from './column@0.3.1.js';\n\nfunction relationId(id) {\n    return {\n        url() {\n            return '/relation/' + id.schema_id.name + '/' + id.name;\n        },\n    };\n}\n\nexport class Relation {\n    constructor(schema, name) {\n        this.schema = schema;\n        this.name = name;\n        this.id = { schema_id: this.schema.id, name: this.name };\n    }\n    to_url(id_only) {\n        return id_only\n            ? '/relation/' + this.schema.name + '/' + this.name\n            : this.schema.database.endpoint.url +\n            '/relation/' +\n            this.schema.name +\n            '/' +\n            this.name;\n    }\n    column(name) {\n        return new Column(this, name);\n    }\n    // TODO: [idea] if order_by is used, maintain this in rowset.\n    //  - then we will redo the sort client side and ensure events are put in the right place by diffing the ordered rowset\n    rows(options) {\n        return this.schema.database.endpoint\n            .get(this, options)\n            .then(\n                function (rows) {\n                    if (rows == null) {\n                        throw 'Empty response';\n                    } /*\n              else if (rows.result.length < 1) {\n                  throw 'No rows returned';\n              }*/\n                    const rowset = new Rowset(this, rows, options);\n                    this.schema.database.track(this.to_url(true), rowset);\n                    return rowset;\n                }.bind(this)\n            )\n            .catch(function (err) {\n                throw 'Rows request failed: ' + err;\n            });\n    }\n    row() {\n        // TODO: minimize the number of ways to call row. this code is strange and complicated\n        //  - maybe it gets better with ide type definitions\n\n        // Multiple different ways to call 'row' function\n\n        // 1. Calling with Options object\n        if (typeof arguments[0] == 'object') {\n            var obj = arguments[0];\n            var args = arguments[1] || {};\n\n            // Relation.row({ where: { column_name: 'column_name', op: '=', value: 'value' } })\n            // Maybe it should be this one: Relation.row({ where: { column_name: value } })\n            if (typeof obj.where != 'undefined') {\n                args.where = obj.where;\n            }\n            // Relation.row({ column_name: 'column_name', op: '=', value: 'value' })\n            // Maybe it should be this one: Relation.row({ column_name: value })\n            else {\n                args.where = obj;\n            }\n        }\n        // 2. Calling with column_name and value\n        else if (typeof arguments[0] == 'string') {\n            // Relation.row(column_name, value [, options_obj])\n            var name = arguments[0];\n            var value = arguments[1];\n            var args = arguments[2] || {};\n\n            args.where = { name: name, op: '=', value: value };\n        }\n        // 3. Calling Relation.row() without arguments\n        else {\n            var args = {};\n        }\n\n        return this.schema.database.endpoint\n            .get(this, args)\n            .then(\n                function (row) {\n                    if (row == null) {\n                        throw 'Empty response';\n                    } else if (row.result.length == 0) {\n                        return null; // throw 'No row returned';\n                    } else if (row.result.length > 1) {\n                        throw 'Multiple rows returned';\n                    }\n                    const aqRow = new Row(this, row);\n                    this.schema.database.track(aqRow.to_url(true), aqRow);\n                    return aqRow;\n                }.bind(this)\n            )\n            .catch(function (err) {\n                throw 'Row request failed: ' + err;\n            });\n    }\n}\n\nexport class Table extends Relation {\n    insert(data) {\n        if (typeof data == 'undefined') {\n            // table.insert({}) is equivalent to table.insert()\n            // both will insert default values\n            data = {};\n        }\n\n        // Return inserted row promise\n        return this.schema.database.endpoint\n            .patch(this, data)\n            .then(\n                function (inserted_row) {\n                    if (inserted_row == null) {\n                        throw 'Empty response';\n                    }\n                    if (typeof data.length != 'undefined' && data.length > 1) {\n                        return new Rowset(this, inserted_row, null);\n                    }\n                    return new Row(this, inserted_row);\n                }.bind(this)\n            )\n            .catch(function (err) {\n                throw 'Insert failed: ' + err;\n            });\n    }\n}\n\nexport class View extends Relation {}\n
\\x78278714874f01f0899af92e80ab7d9ad0b890277f277a865b157c3b6a08818b	5197d5c1-081c-470d-95d1-62d6dc204f23
\\x78f9ac018e554365069108352dacabb7fbd15246edf19400677e3b54fe24e126	function
\\x7979452de22156059a18d73cfe29a4e624278e2e7bf5e4f30c407ede103f5c3c	{js}
\\x79b89ec15cf2d7113073ed5483c18e770569f3464958771e5e7b7f61d9d4c431	/*******************************************************************************\n* Widget.js\n*\n* Created by Aquameta Labs, an open source company in Portland Oregon, USA.\n* Project: http://aquameta.com/\n******************************************************************************/\ndefine(['/doT.js', '/jQuery.min.js', '/datum.js'], function(doT, $, AQ, undefined) {\n\n    'use strict';\n\n    doT.templateSettings.strip = false;\n\n    var widget_promises = {};\n    var containers = {};\n    var namespaces = {};\n\n\n    AQ.Widget = {};\n\n\n    AQ.Widget.widget = function ( selector, input, extra ) {\n\n        if (!selector || typeof selector != 'string') {\n            throw "Widget - Selector argument is invalid or missing";\n        }\n\n        // Same namespace as calling widget, instead of global '' namespace\n        var default_namespace = (typeof this != 'undefined' && typeof this.namespace != 'undefined') ? this.namespace : '';\n\n        var is_semantic_dsl_lookup = selector.indexOf('/') != -1;\n\n        // For semantic lookup\n        // * selector is 'semantics/purpose/default_bundle'\n        // * input is AQ.* object\n        // * extra is {} to send to widget\n        if (is_semantic_dsl_lookup) {\n\n            if (!input) {\n                throw "Semantics requires an AQ.* to be passed in";\n            }\n\n            var context = extra || {};\n            var semantics = selector.split('/');\n            var args_object = {};\n\n            // If input is a promise (that will resolve as a Rowset or a Row), resolve it first\n            if (input instanceof Promise) {\n\n                var url_id;\n                var widget_getter = input.then(function(input) {\n\n                    context.datum = input;\n\n                    // These are the same for both Rowset and Row\n                    var endpoint = input.relation.schema.database;\n                    var fn = 'relation_widget';\n                    var type = 'meta.relation_id';\n                    args_object.relation_id = input.relation.id;\n\n                    if (input instanceof AQ.Rowset) {\n                        context.rows = input;\n                        url_id = input.relation.to_url(true);\n                    }\n                    else if (input instanceof AQ.Row) {\n                        context.row = input;\n                        url_id = input.to_url(true);\n                    }\n                    args_object.widget_purpose = semantics[1];\n                    args_object.default_bundle = semantics.length >= 3 ? semantics[2] : 'org.aquameta.core.semantics';\n                    \n                    return endpoint.schema('semantics').function({\n                        name: fn,\n                        parameters: [type,'text','text']\n                    }, args_object, { use_cache: true, meta_data: false });\n\n                });\n\n            }\n            // Else, check which type it is\n            else {\n\n                context.datum = input;\n\n                if (input instanceof AQ.Relation || input instanceof AQ.Table || input instanceof AQ.View) {\n                    var endpoint = input.schema.database;\n                    var fn = 'relation_widget';\n                    var type = 'meta.relation_id';\n                    args_object.relation_id = input.id;\n                    var url_id = input.to_url(true);\n                    context.relation = input;\n                }\n                else if (input instanceof AQ.Row) {\n                    var endpoint = input.relation.schema.database;\n                    var fn = 'relation_widget';\n                    var type = 'meta.relation_id';\n                    args_object.relation_id = input.relation.id;\n                    var url_id = input.to_url(true);\n                    context.row = input;\n                }\n                else if (input instanceof AQ.Rowset) {\n                    var endpoint = input.relation.schema.database;\n                    var fn = 'relation_widget';\n                    var type = 'meta.relation_id';\n                    args_object.relation_id = input.relation.id;\n                    var url_id = input.relation.to_url(true);\n                    context.rows = input;\n                }\n                else if (input instanceof AQ.Column) {\n                    var endpoint = input.relation.schema.database;\n                    var fn = 'column_widget';\n                    var type = 'meta.column_id';\n                    args_object.column_id = input.id;\n                    var url_id = input.relation.to_url(true);\n                    context.column = input;\n                }\n                else if (input instanceof AQ.Field) {\n                    var endpoint = input.row.relation.schema.database;\n                    var fn = 'column_widget';\n                    var type = 'meta.column_id';\n                    args_object.column_id = input.column.id;\n                    var url_id = input.to_url(true);\n                    context.field = input;\n                }\n                \n                args_object.widget_purpose = semantics[1];\n                args_object.default_bundle = semantics.length >= 3 ? semantics[2] : 'org.aquameta.core.semantics';\n                \n                var widget_getter = endpoint.schema('semantics').function({\n                    name: fn,\n                    parameters: [type,'text','text']\n                }, args_object, { use_cache: true, meta_data: false });\n            }\n\n            // Go get this widget - retrieve_promises don't change for calls to the same widget - they are cached by the widget name\n            var widget_retrieve_promise = retrieve(widget_getter, {\n                semantic_selector: selector,\n                url_id: url_id\n            });\n\n        }\n\n        // For regular widget lookup\n        // * selector is '[namespace:]widget_name'\n        // * input is {} to send to widget\n        // * extra is ignored\n        else {\n\n            //var context = typeof input != 'undefined' ? Object.assign({}, input) : {};\n            var context = input || {};\n\n            var name_parts = selector.split(':');\n\n            if (name_parts.length == 1) {\n                // Default namespace lookup\n                context.namespace = default_namespace;\n                context.name = name_parts[0];\n            }\n            else {\n                // Namespaced lookup\n                context.namespace = name_parts[0];\n                context.name = name_parts[1];\n                context.bundle_name = namespaces[context.namespace].bundle_name;\n            }\n\n            // Namespace not found\n            if (!(context.namespace in namespaces)) {\n                throw 'Widget namespace "'+context.namespace+'" has not been imported - Call AQ.Widget.import( bundle_name, namespace, endpoint ) to import bundled widgets to a namespace';\n            }\n    \n            var widget_getter = namespaces[context.namespace].endpoint.schema('widget').function('bundled_widget',\n                [ namespaces[context.namespace].bundle_name, context.name ], {\n                    use_cache: true,\n                    meta_data: false\n                });\n\n            // Go get this widget - retrieve_promises don't change for calls to the same widget - they are cached by the widget name\n            var widget_retrieve_promise = retrieve(widget_getter, {\n                namespace: context.namespace,\n                name: context.name\n            });\n\n        }\n\n        context.id = AQ.uuid();\n\n        // Setup default namespace for child widget\n        context.widget = AQ.Widget.widget.bind({ namespace: context.namespace });\n        context.widget.sync = AQ.Widget.widget.sync;\n\n        // Prepare and render the widget - each prepare_promise is unique because inputs are different - they are cached by the unique uuid created for the context\n        widget_promises[context.id] = prepare(widget_retrieve_promise, context);\n\n        // Return script that calls swap\n        return '<script id="widget-stub_' + context.id  + '" data-widget_id="' + context.id + '">' +\n                  'AQ.Widget.swap($("#widget-stub_' +  context.id  + '"), "' + context.id + '");'  + \n               '</script>';\n\n    }\n\n\n\n    /* Import a bundle name to a local namespace */\n    AQ.Widget.import = function( bundle_name, namespace, endpoint ) {\n\n        namespaces[namespace] = {\n            endpoint: endpoint,\n            bundle_name: bundle_name\n        };\n\n    };\n\n\n    /* Return an array bundle of imported bundle names */\n    AQ.Widget.bundles = function() {\n        return Object.keys(namespaces).map(function(key) {\n            return namespaces[key].bundle_name;\n        });\n    };\n\n\n\n    /* Find the bundle that was imported to this namespace */\n    AQ.Widget.bundle = function( namespace ) {\n        return namespaces[namespace].bundle_name;\n    };\n\n\n\n    /* Find the namespace that uses this bundle */\n    AQ.Widget.namespace = function( bundle_name ) {\n        return Object.keys(namespaces).find(function(namespace) {\n            return namespaces[namespace].bundle_name == bundle_name;\n        });\n    };\n\n\n\n    function retrieve( widget_getter, selector ) {\n\n        if ('semantic_selector' in selector) {\n            var semantic_lookup = true;\n        }\n\n        return widget_getter.then(function(row) {\n\n            // Get all related widget data\n            return Promise.all([\n                row,/* VIEWSIGNORE\n                row.related_rows('id', 'widget.input', 'widget_id', { use_cache: true, meta_data: true }).catch(function(){ return; }), \n                row.related_rows('id', 'widget.widget_view', 'widget_id', { use_cache: true, meta_data: true })\n                    .then(function(widget_views) {\n\n                        var db = row.schema.database;\n                        return widget_views.map(function(widget_view) {\n                            var view_id = widget_view.get('view_id');\n                            return db.schema(view_id.schema_id.name).view(view_id.name);\n                        });\n\n                    }).catch(function(err) { return; }), */\n                row.related_rows('id', 'widget.widget_dependency_js', 'widget_id', { use_cache: true, meta_data: true })\n                    .then(function(deps_js) {\n\n                        if (!deps_js.length) { return; }\n                        return deps_js.related_rows('dependency_js_id', 'widget.dependency_js', 'id', { use_cache: true, meta_data: true });\n\n                    }).then(function(deps) {\n\n                        return Promise.all(\n\n                            deps.map(function(dep) {\n                                return System.import(dep.field('content').to_url()).then(function(dep_module) {\n                                    //console.log('my module', dep_module);\n                                    \n                                    return {\n                                        url: dep.field('content').to_url(),\n                                        name: dep.get('variable') || 'non_amd_module',\n                                        /* TODO: This value thing is a hack. For some reason, jwerty doesn't load properly here */\n                                        value: typeof dep_module == 'object' ? dep_module[Object.keys(dep_module)[0]] : dep_module\n                                        //value: dep_module\n                                    };\n                                });\n                            })\n                        );\n\n                    }).catch(function() { return; })\n            ]);\n        }).catch(function(err) {\n            if (semantic_lookup) {\n                throw 'Widget not found from semantic lookup with ' + selector.semantic_selector + ' on ' + selector.url_id;\n            }\n            else {\n                throw 'Widget does not exist, ' + selector.namespace + ':' + selector.name;\n            }\n        });\n    };\n\n\n\n    function prepare( retrieve_promise, context ) {\n\n        return retrieve_promise.then(function( widget_data ) {\n\n            //console.log('retrieve_promise resolved', widget_data);\n\t\t\tvar [ widget_row,  /* inputs, VIEWSIGNORE views, */ deps_js ] = widget_data;\n\n            context.name = widget_row.get('name');\n\n            var xinput = context;\n            context = Object.assign({\n                    db: widget_row.schema.database,\n                    endpoint: widget_row.schema.database,\n                    input: {},\n                    xinput: xinput\n                }, context);\n\n            delete context.xinput.id;\n            delete context.xinput.name;\n            delete context.xinput.namespace;\n            delete context.xinput.widget;\n\n            // Process inputs\n            if (typeof inputs != 'undefined') {\n\n                inputs.forEach(function(input) {\n                    var input_name = input.get('name');\n\n                    if (typeof context[input_name] == 'undefined') {\n                        if (input.get('optional')) {\n                            var default_code = input.get('default_value');\n                            try {\n\n                                if (default_code) {\n                                    context[input_name] = eval('(' + default_code + ')');\n                                }\n                                else {\n                                    context[input_name] =  undefined;\n                                }\n\n                            }\n                            catch (e) {\n                                error(e, context.name, "Widget default eval failure: " + default_code);\n                                /*\n                                console.error("Widget default eval failure", default_code);\n                                throw e;\n                                */\n                            }\n\n                        }\n                        else {\n                            error('Missing required input ' + input_name, context.name, 'Inputs');\n                        }\n                    }\n                    context.input[input_name] = context[input_name];\n                    delete context.xinput[input_name];\n                });\n            }\n\n            // Load views into context\n            if (typeof views != 'undefined') {\n                views.forEach(function(view) {\n                    context[view.schema.name + '_' + view.name] = view;\n                });\n            }\n\n            var rendered_widget = render(widget_row, context);\n            var post_js_function = create_post_js_function(widget_row, context, deps_js);\n\n            // Return rendered widget and post_js function\n            return {\n                html: rendered_widget,\n                widget_id: context.id,\n                widget_name: context.name,\n                post_js: post_js_function\n            };\n\n        });\n    };\n\n\n\n    function render( widget_row, context ) {\n\n        // Create html template\n        var html_template = doT.template(widget_row.get('html') || '');\n\n        // Compile html template\n        try {\n            var html = html_template(context);\n        } catch(e) {\n            error(e, context.name, 'HTML');\n        }\n\n        // Render html\n        try {\n            var rendered = $(html).attr('data-widget', context.name)\n                .attr('data-widget_id', context.id)\n                .attr('data-bundle_alias', context.namespace)\n                .attr('data-bundle_name', context.bundle_name)\n                .attr('data-widget_row_id', widget_row.get('id'))\n                .data('help', widget_row.get('help'));\n        } catch(e) {\n            error(e, context.name, 'HTML (adding data-* attributes)');\n        }\n                                \n        // If CSS exists and has not yet been applied\n        if (widget_row.get('css') != null && $('style[data-widget="' + context.name + '"]').length == 0) {\n\n            // Create css template\n            var css_template = doT.template(widget_row.get('css') || '');\n\n            // Try to run css template\n            try {\n                var css = css_template(context);\n            } catch(e) {\n                error(e, context.name, 'CSS');\n            }\n\n            // Add css to dom\n            $('<style type="text/css" data-widget="' + context.name + '">' + css + '</style>').appendTo(document.head);\n        }\n\n        return rendered;\n    };\n\n\n\n    function create_post_js_function( widget_row, context, deps_js ) {\n\n        var context_keys = Object.keys(context).sort();\n\n        // Get context values\n        var context_vals = context_keys.map(function(key) {\n            return context[key];\n        });\n\n        // Dependency names and values\n        var dep_names = [],\n            dep_values = [];\n        if (deps_js != null) {\n            deps_js.forEach(function(dep_js) {\n                dep_names.push(dep_js.name);\n                dep_values.push(dep_js.value);\n            });\n        }\n\n        try {\n            /*\n            * Creating an script that looks like this\n            * function(dep1_name, dep2_name, ...) {\n            *   function(input1, input2) {\n            *       post_js\n            *   }.apply(this.this.context_vals);\n            * }.apply(this, this.dep_vals);\n            */\n            var post_js = Function(\n                '(function(' + dep_names.join(',') + ') { \\n' +\n                    '(function(' + context_keys.join(',') + ') { \\n' +\n                        'var w = $("#"+id);\\n\\n' +\n                        widget_row.get('post_js') +\n                        '\\n//# sourceURL=' + widget_row.get('id') + '/' + widget_row.get('name') + '/post_js\\n' +\n                    '}).apply(this, this.context_vals);' +\n                '}).apply(this, this.dep_values);'\n            ).bind({ context_vals: context_vals, dep_values: dep_values });\n        }\n        catch(e) {\n            error(e, widget_row.get('name'), 'Creating post_js function');\n        }\n\n        return post_js;\n\n    };\n\n\n    // detect svg widgets by tag name.  might be better to check the dom to see if we're inside an svg tag?\n    AQ.Widget.is_svg = function( e ) {\n        var svg_tags = ['circle','rect','polygon','g']; // TODO: add more, or change approach?\n        for (var i=0;i<svg_tags.length;i++) {\n            if (e.tagName.toUpperCase() == svg_tags[i].toUpperCase()) {\n                // console.log('svg  widget: ' + svg_tags[i]);\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n\n    AQ.Widget.swap = function( $element, id ) {\n        widget_promises[id].then(function(rendered_widget) {\n\n            // Replace stub\n            // special case for svg elements - http://stackoverflow.com/questions/3642035/jquerys-append-not-working-with-svg-element\n            if (AQ.Widget.is_svg(rendered_widget.html[0])) { // TODO: is there ever a case where there is more than one element in this array?\n                var div = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');\n                div.innerHTML= '<svg xmlns="http://www.w3.org/2000/svg">'+rendered_widget.html[0].outerHTML+'</svg>';\n\n                var frag= document.createDocumentFragment();\n                while (div.firstChild.firstChild)\n                    frag.appendChild(div.firstChild.firstChild);\n\n                $element.replaceWith(frag);\n            }\n            else $element.replaceWith(rendered_widget.html);\n\n            // Run post_js - or this may have to be done with a script tag appended to the widget\n            try {\n                rendered_widget.post_js();\n            }\n            catch(e) {\n                error(e, rendered_widget.widget_name, 'Running post_js function');\n            }\n\n            var w = $('#' + rendered_widget.widget_id);\n\n            // notify the world that a widget has loaded.  debugger uses this to detect widget tree changes\n            w.trigger('widget_loaded', { widget: w });\n\n            // Delete prepeared_promise\n            delete widget_promises[id];\n\n        }).catch(function(error) {\n            //console.error('Widget swap failed - ', error);\n            console.error(error);\n            // Remove stub\n            $element.remove();\n            // Delete promise\n            delete widget_promises[id];\n        });\n    };\n\n\n\n    function error( err, widget_name, step_name ) {\n        console.error("widget('" + widget_name + "', ...) " + step_name + " failed!");\n        //window.setTimeout(function() { throw err; }, 100);\n        throw err;\n    }\n\n\n\n    AQ.Widget.sync = function(rowset_promise, container, widget_maker, handlers) {\n\n        if(handlers === undefined) {\n            handlers = {};\n        }\n\n        if (widget_maker === undefined) {\n            throw 'widget.sync missing widget_maker argument';\n        }\n\n        if (container.length < 1) {\n            throw 'widget.sync failed: The specified container is empty or not found';\n            return;\n        }\n\n        if (container.length > 1) {\n            throw 'widget.sync failed: The specified container contains multiple elements';\n            return;\n        }\n\n        if (!container instanceof jQuery) {\n            throw 'widget.sync failed: The specified container is not a jQuery object';\n            return;\n        }\n\n        if (typeof rowset_promise == 'undefined' ||\n            (!(rowset_promise instanceof Promise) && !(rowset_promise instanceof AQ.Rowset) && !(rowset_promise instanceof AQ.FunctionResultSet))) {\n            throw 'widget.sync failed: rowset_promise must be a "thenable" promise or a resolved AQ.Rowset or a resolved AQ.FunctionResultSet';\n        }\n\n        if (!(rowset_promise instanceof Promise)) {\n            rowset_promise = Promise.resolve(rowset_promise);\n        }\n\n        rowset_promise.then(function(rowset) {\n\n            if (typeof rowset == 'undefined' || typeof rowset.forEach == 'undefined') {\n                throw 'Rowset is not defined. First argument to widget.sync must return a Rowset';\n            }\n\n            var container_id = AQ.uuid();\n\n            container.attr('data-container_id', container_id)\n            containers[container_id] = {\n                container: container,\n                widget_maker: widget_maker,\n                handlers: handlers\n            };\n\n            rowset.forEach(function(row) {\n                container.append(widget_maker(row));\n            });\n\n        }).catch(function(error) {\n            console.error('widget.sync failed: ', error);\n        });\n\n    }\n\n    // duplicate name for backwards compatibility\n    AQ.Widget.widget.sync = AQ.Widget.sync;\n\n    return AQ.Widget.widget;\n\n});\n
\\x878bdb5bba10b8ead3afdb1adb2b578f4f1cd26f413d55a4ec954439d28e3523	8a3607c3-cd7c-477d-8f23-f50b4792afdf
\\x881d5fb60090f59aabba4f287d7596317ca7091d00c2180b6cbc8ab018b9febd	column
\\x89117fd47cebb49b08a4b15651df7f6908d9256e04119bcc7a330f8621ddf3f1	widget/get_module/{text,text,text,text}
\\x8dc605a9d055b88bd84debeb1ba5be43dfb42d9fd41120d9820aa39a5a69bbce	import { Endpoint } from './endpoint@0.3.1.js';\nimport { Schema } from './schema@0.3.1.js';\n\nexport class Database {\n    constructor(url, settings) {\n        this.settings = settings;\n\n        if (typeof this.settings.evented === 'string') {\n            console.warn(\n                'Database: `evented` setting has been deprecated. Use `events=true|false` instead'\n            );\n            delete this.settings.evented;\n        }\n\n        this.settings.events = Object.hasOwn(this.settings, 'events')\n            ? this.settings.events\n            : false;\n        this.endpoint = new Endpoint(url, this, this.settings.events);\n        this.tracked = { relation: {}, row: {}, field: {} };\n\n        if (this.settings.events) {\n            this.schema('event')\n                .function('session_create')\n                .then(\n                    function (result) {\n                        const sessionId = result.get('session_create');\n                        if (sessionId) {\n                            this.endpoint.connectSession(sessionId);\n                            persistSessionId(sessionId);\n                        } else {\n                            console.log('got a null sessionId', sessionId);\n                        }\n                    }.bind(this)\n                );\n        }\n    }\n    schema(name) {\n        return new Schema(this, name);\n    }\n    rowIdToRow(rowId) {\n        const schema = rowId.pk_column_id.relation_id.schema_id.name;\n        const relation = rowId.pk_column_id.relation_id.name;\n        const pkColumn = rowId.pk_column_id.name;\n        const pkValue = rowId.pk_value;\n        if (!schema || !relation || !pkColumn || !pkValue) {\n            throw new Error('Database - rowIdToRow: invalid rowId')\n        }\n        return this.schema(schema).relation(relation).row(pkColumn, pkValue);\n    }\n    getTracked(id) {\n        let idType;\n        if (id.startsWith('/relation/')) {\n            idType = 'relation';\n        } else if (id.startsWith('/row/')) {\n            idType = 'row';\n        } else if (id.startsWith('/field/')) {\n            idType = 'field';\n        }\n        const tracked = this.tracked[idType][id];\n        if (!tracked) {\n            return [];\n        }\n        return tracked;\n    }\n    track(id, obj) {\n        // TODO: db.track should only be called when events are set up on this query\n        let idType;\n        if (id.startsWith('/relation/')) {\n            idType = 'relation';\n        } else if (id.startsWith('/row/')) {\n            idType = 'row';\n        } else if (id.startsWith('/field/')) {\n            idType = 'field';\n        }\n\n        // columns are supposed to have events, but what does that mean?\n        // functions do not have events\n        // schema do not have events\n\n        switch (idType) {\n            case 'relation':\n                this.tracked.relation[id] = this.tracked.relation[id] || [];\n                this.tracked.relation[id].push(obj);\n                break;\n            case 'row':\n                this.tracked.row[id] = obj;\n                break;\n            case 'field':\n                this.tracked.field[id] = obj;\n                break;\n        }\n    }\n}
\\x911fc0c48cb0c70601db5775a9bef1b740dc4cc9f9b46389b9f0563fe7eb94d7	0.2.0
\\x9342af224fa264b0e961df75246597ee455cd08afe11b0a8cea6bb74dc59bf55	util
\\x9aa951bee10ac122c8b0421f5596c012fe3a5640cfb31c53da37946b0bbe15e4	3b7aa094-a6a2-4b14-8132-1ebe37e80143
\\x9ba15f51d72cef2a6a6ca557403e0278dce780a5b65f098de2726ff4ac3f0d23	{css,NULL,NULL,""}
\\x9c8c9f0250b8515b88749472e53e0759e0012cc64993311047d490436cb64239	/${2}/widget.module/${3}@${4}.css
\\x9d79664474502879247ae90c2d7a2b6c4aa4927b1f10f5651309d338c58283b7	/*******************************************************************************\n * Widget.js\n *\n * Created by Aquameta Labs, an open source company in Portland Oregon, USA.\n * Project: http://aquameta.com/\n ******************************************************************************/\n/* eslint-env browser */\n/* globals jQuery define */\ndefine(['/doT.js', '/jQuery.min.js', '/datum.js'], function (\n  doT,\n  $,\n  AQ,\n  undefined // eslint-disable-line\n) {\n  'use strict';\n\n  doT.templateSettings.strip = false;\n\n  var widget_promises = {};\n  var containers = {};\n  var namespaces = {};\n\n  AQ.Widget = {};\n\n  AQ.Widget.widget = function (selector, input, extra) {\n    if (!selector || typeof selector != 'string') {\n      throw 'Widget - Selector argument is invalid or missing';\n    }\n\n    // Same namespace as calling widget, instead of global '' namespace\n    var default_namespace =\n      typeof this != 'undefined' && typeof this.namespace != 'undefined'\n        ? this.namespace\n        : '';\n\n    var is_semantic_dsl_lookup = selector.indexOf('/') != -1;\n\n    // For semantic lookup\n    // * selector is 'semantics/purpose/default_bundle'\n    // * input is AQ.* object\n    // * extra is {} to send to widget\n    if (is_semantic_dsl_lookup) {\n      if (!input) {\n        throw 'Semantics requires an AQ.* to be passed in';\n      }\n\n      var context = extra || {};\n      var semantics = selector.split('/');\n      var args_object = {};\n\n      // If input is a promise (that will resolve as a Rowset or a Row), resolve it first\n      if (input instanceof Promise) {\n        var url_id;\n        var widget_getter = input.then(function (input) {\n          context.datum = input;\n\n          // These are the same for both Rowset and Row\n          var endpoint = input.relation.schema.database;\n          var fn = 'relation_widget';\n          var type = 'meta.relation_id';\n          args_object.relation_id = input.relation.id;\n\n          if (input instanceof AQ.Rowset) {\n            context.rows = input;\n            url_id = input.relation.to_url(true);\n          } else if (input instanceof AQ.Row) {\n            context.row = input;\n            url_id = input.to_url(true);\n          }\n          args_object.widget_purpose = semantics[1];\n          args_object.default_bundle =\n            semantics.length >= 3\n              ? semantics[2]\n              : 'org.aquameta.core.semantics';\n\n          return endpoint.schema('semantics').function(\n            {\n              name: fn,\n              parameters: [type, 'text', 'text'],\n            },\n            args_object,\n            {use_cache: true, meta_data: false}\n          );\n        });\n      }\n      // Else, check which type it is\n      else {\n        context.datum = input;\n\n        if (\n          input instanceof AQ.Relation ||\n          input instanceof AQ.Table ||\n          input instanceof AQ.View\n        ) {\n          var endpoint = input.schema.database;\n          var fn = 'relation_widget';\n          var type = 'meta.relation_id';\n          args_object.relation_id = input.id;\n          var url_id = input.to_url(true);\n          context.relation = input;\n        } else if (input instanceof AQ.Row) {\n          var endpoint = input.relation.schema.database;\n          var fn = 'relation_widget';\n          var type = 'meta.relation_id';\n          args_object.relation_id = input.relation.id;\n          var url_id = input.to_url(true);\n          context.row = input;\n        } else if (input instanceof AQ.Rowset) {\n          var endpoint = input.relation.schema.database;\n          var fn = 'relation_widget';\n          var type = 'meta.relation_id';\n          args_object.relation_id = input.relation.id;\n          var url_id = input.relation.to_url(true);\n          context.rows = input;\n        } else if (input instanceof AQ.Column) {\n          var endpoint = input.relation.schema.database;\n          var fn = 'column_widget';\n          var type = 'meta.column_id';\n          args_object.column_id = input.id;\n          var url_id = input.relation.to_url(true);\n          context.column = input;\n        } else if (input instanceof AQ.Field) {\n          var endpoint = input.row.relation.schema.database;\n          var fn = 'column_widget';\n          var type = 'meta.column_id';\n          args_object.column_id = input.column.id;\n          var url_id = input.to_url(true);\n          context.field = input;\n        }\n\n        args_object.widget_purpose = semantics[1];\n        args_object.default_bundle =\n          semantics.length >= 3 ? semantics[2] : 'org.aquameta.core.semantics';\n\n        var widget_getter = endpoint.schema('semantics').function(\n          {\n            name: fn,\n            parameters: [type, 'text', 'text'],\n          },\n          args_object,\n          {use_cache: true, meta_data: false}\n        );\n      }\n\n      // Go get this widget - retrieve_promises don't change for calls to the same widget - they are cached by the widget name\n      var widget_retrieve_promise = retrieve(widget_getter, {\n        semantic_selector: selector,\n        url_id: url_id,\n      });\n    }\n\n    // For regular widget lookup\n    // * selector is '[namespace:]widget_name'\n    // * input is {} to send to widget\n    // * extra is ignored\n    else {\n      //var context = typeof input != 'undefined' ? Object.assign({}, input) : {};\n      var context = input || {};\n\n      var name_parts = selector.split(':');\n\n      if (name_parts.length == 1) {\n        // Default namespace lookup\n        context.namespace = default_namespace;\n        context.name = name_parts[0];\n      } else {\n        // Namespaced lookup\n        context.namespace = name_parts[0];\n        context.name = name_parts[1];\n        context.bundle_name = namespaces[context.namespace].bundle_name;\n      }\n\n      // Namespace not found\n      if (!(context.namespace in namespaces)) {\n        throw (\n          'Widget namespace "' +\n          context.namespace +\n          '" has not been imported - Call AQ.Widget.import( bundle_name, namespace, endpoint ) to import bundled widgets to a namespace'\n        );\n      }\n\n      var widget_getter = namespaces[context.namespace].endpoint\n        .schema('widget')\n        .function(\n          'bundled_widget',\n          [namespaces[context.namespace].bundle_name, context.name],\n          {\n            use_cache: true,\n            meta_data: false,\n          }\n        );\n\n      // Go get this widget - retrieve_promises don't change for calls to the same widget - they are cached by the widget name\n      var widget_retrieve_promise = retrieve(widget_getter, {\n        namespace: context.namespace,\n        name: context.name,\n      });\n    }\n\n    context.id = AQ.uuid();\n\n    // Setup default namespace for child widget\n    context.widget = AQ.Widget.widget.bind({namespace: context.namespace});\n    context.widget.sync = AQ.Widget.widget.sync;\n\n    // Prepare and render the widget - each prepare_promise is unique because inputs are different - they are cached by the unique uuid created for the context\n    widget_promises[context.id] = prepare(widget_retrieve_promise, context);\n\n    // Return script that calls swap\n    return (\n      '<script id="widget-stub_' +\n      context.id +\n      '" data-widget_id="' +\n      context.id +\n      '">' +\n      'AQ.Widget.swap($("#widget-stub_' +\n      context.id +\n      '"), "' +\n      context.id +\n      '");' +\n      '</script>'\n    );\n  };\n\n  /* Import a bundle name to a local namespace */\n  AQ.Widget.import = function (bundle_name, namespace, endpoint) {\n    namespaces[namespace] = {\n      endpoint: endpoint,\n      bundle_name: bundle_name,\n    };\n  };\n\n  /* Return an array bundle of imported bundle names */\n  AQ.Widget.bundles = function () {\n    return Object.keys(namespaces).map(function (key) {\n      return namespaces[key].bundle_name;\n    });\n  };\n\n  /* Find the bundle that was imported to this namespace */\n  AQ.Widget.bundle = function (namespace) {\n    return namespaces[namespace].bundle_name;\n  };\n\n  /* Find the namespace that uses this bundle */\n  AQ.Widget.namespace = function (bundle_name) {\n    return Object.keys(namespaces).find(function (namespace) {\n      return namespaces[namespace].bundle_name == bundle_name;\n    });\n  };\n\n  function retrieve(widget_getter, selector) {\n    if ('semantic_selector' in selector) {\n      var semantic_lookup = true;\n    }\n\n    return widget_getter\n      .then(function (row) {\n        // Get all related widget data\n        return Promise.all([\n          row /* VIEWSIGNORE\n                row.related_rows('id', 'widget.input', 'widget_id', { use_cache: true, meta_data: true, events: null }).catch(function(){ return; }), \n                row.related_rows('id', 'widget.widget_view', 'widget_id', { use_cache: true, meta_data: true, events: null })\n                    .then(function(widget_views) {\n\n                        var db = row.schema.database;\n                        return widget_views.map(function(widget_view) {\n                            var view_id = widget_view.get('view_id');\n                            return db.schema(view_id.schema_id.name).view(view_id.name);\n                        });\n\n                    }).catch(function(err) { return; }), */,\n          row\n            .related_rows('id', 'widget.widget_dependency_js', 'widget_id', {\n              use_cache: true,\n              meta_data: true,\n              events: null,\n            })\n            .then(function (deps_js) {\n              if (!deps_js.length) {\n                return;\n              }\n              return deps_js.related_rows(\n                'dependency_js_id',\n                'widget.dependency_js',\n                'id',\n                {use_cache: true, meta_data: true, events: null}\n              );\n            })\n            .then(function (deps) {\n              return Promise.all(\n                deps.map(function (dep) {\n                  return System.import(dep.field('content').to_url()).then(\n                    function (dep_module) {\n                      //console.log('my module', dep_module);\n\n                      return {\n                        url: dep.field('content').to_url(),\n                        name: dep.get('variable') || 'non_amd_module',\n                        /* TODO: This value thing is a hack. For some reason, jwerty doesn't load properly here */\n                        value:\n                          typeof dep_module == 'object'\n                            ? dep_module[Object.keys(dep_module)[0]]\n                            : dep_module,\n                        //value: dep_module\n                      };\n                    }\n                  );\n                })\n              );\n            })\n            .catch(function () {\n              return;\n            }),\n        ]);\n      })\n      .catch(function (err) {\n        if (semantic_lookup) {\n          throw (\n            'Widget not found from semantic lookup with ' +\n            selector.semantic_selector +\n            ' on ' +\n            selector.url_id\n          );\n        } else {\n          throw (\n            'Widget does not exist, ' + selector.namespace + ':' + selector.name\n          );\n        }\n      });\n  }\n\n  function prepare(retrieve_promise, context) {\n    return retrieve_promise.then(function (widget_data) {\n      //console.log('retrieve_promise resolved', widget_data);\n      var [widget_row, /* inputs, VIEWSIGNORE views, */ deps_js] = widget_data;\n\n      context.name = widget_row.get('name');\n\n      var xinput = context;\n      context = Object.assign(\n        {\n          db: widget_row.schema.database,\n          endpoint: widget_row.schema.database,\n          input: {},\n          xinput: xinput,\n        },\n        context\n      );\n\n      delete context.xinput.id;\n      delete context.xinput.name;\n      delete context.xinput.namespace;\n      delete context.xinput.widget;\n\n      // Process inputs\n      if (typeof inputs != 'undefined') {\n        inputs.forEach(function (input) {\n          var input_name = input.get('name');\n\n          if (typeof context[input_name] == 'undefined') {\n            if (input.get('optional')) {\n              var default_code = input.get('default_value');\n              try {\n                if (default_code) {\n                  context[input_name] = eval('(' + default_code + ')');\n                } else {\n                  context[input_name] = undefined;\n                }\n              } catch (e) {\n                error(\n                  e,\n                  context.name,\n                  'Widget default eval failure: ' + default_code\n                );\n                /*\n                                console.error("Widget default eval failure", default_code);\n                                throw e;\n                                */\n              }\n            } else {\n              error(\n                'Missing required input ' + input_name,\n                context.name,\n                'Inputs'\n              );\n            }\n          }\n          context.input[input_name] = context[input_name];\n          delete context.xinput[input_name];\n        });\n      }\n\n      // Load views into context\n      if (typeof views != 'undefined') {\n        views.forEach(function (view) {\n          context[view.schema.name + '_' + view.name] = view;\n        });\n      }\n\n      var rendered_widget = render(widget_row, context);\n      var post_js_function = create_post_js_function(\n        widget_row,\n        context,\n        deps_js\n      );\n\n      // Return rendered widget and post_js function\n      return {\n        html: rendered_widget,\n        widget_id: context.id,\n        widget_name: context.name,\n        post_js: post_js_function,\n      };\n    });\n  }\n\n  function render(widget_row, context) {\n    // Create html template\n    var html_template = doT.template(widget_row.get('html') || '');\n\n    // Compile html template\n    try {\n      var html = html_template(context);\n    } catch (e) {\n      error(e, context.name, 'HTML');\n    }\n\n    // Render html\n    try {\n      var rendered = $(html)\n        .attr('data-widget', context.name)\n        .attr('data-widget_id', context.id)\n        .attr('data-bundle_alias', context.namespace)\n        .attr('data-bundle_name', context.bundle_name)\n        .attr('data-widget_row_id', widget_row.get('id'))\n        .data('help', widget_row.get('help'));\n    } catch (e) {\n      error(e, context.name, 'HTML (adding data-* attributes)');\n    }\n\n    // If CSS exists and has not yet been applied\n    if (\n      widget_row.get('css') != null &&\n      $('style[data-widget="' + context.name + '"]').length == 0\n    ) {\n      // Create css template\n      var css_template = doT.template(widget_row.get('css') || '');\n\n      // Try to run css template\n      try {\n        var css = css_template(context);\n      } catch (e) {\n        error(e, context.name, 'CSS');\n      }\n\n      // Add css to dom\n      $(\n        '<style type="text/css" data-widget="' +\n          context.name +\n          '">' +\n          css +\n          '</style>'\n      ).appendTo(document.head);\n    }\n\n    return rendered;\n  }\n\n  function create_post_js_function(widget_row, context, deps_js) {\n    var context_keys = Object.keys(context).sort();\n\n    // Get context values\n    var context_vals = context_keys.map(function (key) {\n      return context[key];\n    });\n\n    // Dependency names and values\n    var dep_names = [],\n      dep_values = [];\n    if (deps_js != null) {\n      deps_js.forEach(function (dep_js) {\n        dep_names.push(dep_js.name);\n        dep_values.push(dep_js.value);\n      });\n    }\n\n    try {\n      /*\n       * Creating an script that looks like this\n       * function(dep1_name, dep2_name, ...) {\n       *   function(input1, input2) {\n       *       post_js\n       *   }.apply(this.this.context_vals);\n       * }.apply(this, this.dep_vals);\n       */\n      var post_js = Function(\n        '(function(' +\n          dep_names.join(',') +\n          ') { \\n' +\n          '(function(' +\n          context_keys.join(',') +\n          ') { \\n' +\n          'var w = $("#"+id);\\n\\n' +\n          widget_row.get('post_js') +\n          '\\n//# sourceURL=' +\n          widget_row.get('id') +\n          '/' +\n          widget_row.get('name') +\n          '/post_js\\n' +\n          '}).apply(this, this.context_vals);' +\n          '}).apply(this, this.dep_values);'\n      ).bind({context_vals: context_vals, dep_values: dep_values});\n    } catch (e) {\n      error(e, widget_row.get('name'), 'Creating post_js function');\n    }\n\n    return post_js;\n  }\n\n  // detect svg widgets by tag name.  might be better to check the dom to see if we're inside an svg tag?\n  AQ.Widget.is_svg = function (e) {\n    var svg_tags = ['circle', 'rect', 'polygon', 'g']; // TODO: add more, or change approach?\n    for (var i = 0; i < svg_tags.length; i++) {\n      if (e.tagName.toUpperCase() == svg_tags[i].toUpperCase()) {\n        // console.log('svg  widget: ' + svg_tags[i]);\n        return true;\n      }\n    }\n    return false;\n  };\n\n  AQ.Widget.swap = function ($element, id) {\n    widget_promises[id]\n      .then(function (rendered_widget) {\n        // Replace stub\n        // special case for svg elements - http://stackoverflow.com/questions/3642035/jquerys-append-not-working-with-svg-element\n        if (AQ.Widget.is_svg(rendered_widget.html[0])) {\n          // TODO: is there ever a case where there is more than one element in this array?\n          var div = document.createElementNS(\n            'http://www.w3.org/1999/xhtml',\n            'div'\n          );\n          div.innerHTML =\n            '<svg xmlns="http://www.w3.org/2000/svg">' +\n            rendered_widget.html[0].outerHTML +\n            '</svg>';\n\n          var frag = document.createDocumentFragment();\n          while (div.firstChild.firstChild)\n            frag.appendChild(div.firstChild.firstChild);\n\n          $element.replaceWith(frag);\n        } else $element.replaceWith(rendered_widget.html);\n\n        // Run post_js - or this may have to be done with a script tag appended to the widget\n        try {\n          rendered_widget.post_js();\n        } catch (e) {\n          error(e, rendered_widget.widget_name, 'Running post_js function');\n        }\n\n        var w = $('#' + rendered_widget.widget_id);\n\n        // notify the world that a widget has loaded.  debugger uses this to detect widget tree changes\n        w.trigger('widget_loaded', {widget: w});\n\n        // Delete prepeared_promise\n        delete widget_promises[id];\n      })\n      .catch(function (error) {\n        //console.error('Widget swap failed - ', error);\n        console.error(error);\n        // Remove stub\n        $element.remove();\n        // Delete promise\n        delete widget_promises[id];\n      });\n  };\n\n  function error(err, widget_name, step_name) {\n    console.error(\n      "widget('" + widget_name + "', ...) " + step_name + ' failed!'\n    );\n    //window.setTimeout(function() { throw err; }, 100);\n    throw err;\n  }\n\n  AQ.Widget.sync = function (\n    rowset_promise,\n    container,\n    widget_maker,\n    handlers\n  ) {\n    if (handlers === undefined) {\n      handlers = {};\n    }\n\n    if (widget_maker === undefined) {\n      throw 'widget.sync missing widget_maker argument';\n    }\n\n    if (container.length < 1) {\n      throw 'widget.sync failed: The specified container is empty or not found';\n      return;\n    }\n\n    if (container.length > 1) {\n      throw 'widget.sync failed: The specified container contains multiple elements';\n      return;\n    }\n\n    if (!container instanceof jQuery) {\n      throw 'widget.sync failed: The specified container is not a jQuery object';\n      return;\n    }\n\n    if (\n      typeof rowset_promise == 'undefined' ||\n      (!(rowset_promise instanceof Promise) &&\n        !(rowset_promise instanceof AQ.Rowset) &&\n        !(rowset_promise instanceof AQ.FunctionResultSet))\n    ) {\n      throw 'widget.sync failed: rowset_promise must be a "thenable" promise or a resolved AQ.Rowset or a resolved AQ.FunctionResultSet';\n    }\n\n    if (!(rowset_promise instanceof Promise)) {\n      rowset_promise = Promise.resolve(rowset_promise);\n    }\n\n    rowset_promise\n      .then(function (rowset) {\n        if (\n          typeof rowset == 'undefined' ||\n          typeof rowset.forEach == 'undefined'\n        ) {\n          throw 'Rowset is not defined. First argument to widget.sync must return a Rowset';\n        }\n\n        var container_id = AQ.uuid();\n\n        container.attr('data-container_id', container_id);\n        containers[container_id] = {\n          container: container,\n          widget_maker: widget_maker,\n          handlers: handlers,\n        };\n\n        if (rowset instanceof AQ.Rowset) {\n          let widgets = [];\n          rowset.forEach(function (row) {\n            const w = $(widget_maker(row));\n            container.append(w);\n            widgets.push([row.to_url(true), w.attr('data-widget_id')]);\n          });\n          rowset.onDelete(function (deletedRowId) {\n            const widget = widgets.find(([rowId]) => rowId === deletedRowId);\n            if (widget) {\n              const id = widget[1];\n              container.find(`#${id}`).remove();\n            }\n          });\n          rowset.onUpdate(function (row) {\n            const rowUrl = row.to_url(true);\n            const index = widgets.findIndex(([rowId]) => rowId === rowUrl);\n            if (index >= 0) {\n              const widget = widgets[index];\n              const id = widget[1];\n              const newWidget = $(widget_maker(row));\n              widgets[index] = [\n                row.to_url(true),\n                newWidget.attr('data-widget_id'),\n              ];\n              container.find(`#${id}`).replaceWith(newWidget);\n            }\n          });\n        } else {\n          rowset.forEach(function (row) {\n            container.append(widget_maker(row));\n          });\n        }\n      })\n      .catch(function (error) {\n        console.error('widget.sync failed: ', error);\n      });\n  };\n\n  // duplicate name for backwards compatibility\n\n  AQ.Widget.widget.sync = AQ.Widget.sync;\n\n  return AQ.Widget.widget;\n});\n
\\x9d968ea75ef0fe7b50bd65851943439c95662c0fe12743393176263cce839c18	\nexport class Endpoint {\n  constructor(url, database, evented) {\n    this.url = url;\n    this.database = database;\n    this.evented = false;\n    this.cache = {};\n    this.sessionId = null; // = getPersistedSessionId();\n    this.socket = null;\n  }\n  connectSession(sessionId) {\n    this.sessionId = sessionId;\n    if (this.socket) {\n      this.socket.attach(sessionId);\n    }\n  }\n  handleEvent(event) {\n    const {\n      subscription_type: subscriptionType,\n      payload,\n      operation,\n      row_id: rowId,\n    } = event;\n    console.log({subscriptionType, payload, operation, rowId});\n\n    switch (subscriptionType) {\n      case 'table': {\n        console.log(subscriptionType + ':' + operation);\n        const rowsets = this.database.getTracked(\n          relationId(rowId.pk_column_id.relation_id).url()\n        );\n        for (const rowset of rowsets) {\n          rowset._triggerEvent(operation, payload, rowId);\n        }\n        break;\n      }\n      case 'column':\n        console.log(subscriptionType + ':' + operation);\n        break;\n      case 'row':\n        console.log(subscriptionType + ':' + operation);\n        break;\n      case 'field':\n        console.log(subscriptionType + ':' + operation);\n        break;\n      default:\n        break;\n    }\n    // TODO: Delete event\n  }\n  _resource(method, meta_id, args, data) {\n    args = args || {};\n\n    // Get use_cache from args or data\n    let use_cache = false;\n    if (!data && args.use_cache) {\n      use_cache = args.use_cache;\n      delete args.use_cache;\n    } else if (data?.use_cache) {\n      use_cache = data.use_cache;\n      delete data.use_cache;\n    }\n\n    // allow un-evented call by passing false for 'events'\n    const passed = Object.hasOwn(args, 'events');\n    const isTruthy = Boolean(args.events);\n    if (!passed || isTruthy) {\n      // If this connection is evented, get event_session_id\n      if (this.evented && this.sessionId) {\n        args.session_id = this.sessionId;\n      }\n    }\n    delete args.events;\n\n    // URLs\n    const id_url = meta_id.to_url(true); // ID part of the URL only\n    const url_without_query = this.url + id_url;\n    const url_with_query = url_without_query + buildQueryString(args);\n\n    // Check cache\n    if (use_cache && url_with_query in this.cache) {\n      return this.cache[url_with_query];\n    }\n\n    // If query string is too long, upgrade GET method to POST\n    if (method == 'GET' && (location.host + url_with_query).length > 1000) {\n      method = 'POST';\n    }\n\n    const headers = new Headers();\n    headers.append('Content-Type', 'application/json');\n\n    const init_obj = {\n      method: method,\n      headers: headers,\n      credentials: 'same-origin',\n    };\n\n    // Don't add data on GET requests\n    if (method !== 'GET') {\n      init_obj.body = JSON.stringify(data);\n    }\n\n    const request = fetch(\n      method === 'GET' ? url_with_query : url_without_query,\n      init_obj\n    )\n      .then(function (response) {\n        // this will never happen\n        // JSON was returned from WebSocket\n        if (typeof response.json == 'undefined') {\n          // TODO: ? Unfortunately this has no HTTP status like the result of fetch\n          return response;\n        }\n\n        // Request object was returned from fetch\n        // Read json stream\n        var json = response.json();\n\n        if (response.status >= 200 && response.status < 300) {\n          return json;\n        }\n\n        // If bad request (code 300 or higher), reject promise\n        return json.then(Promise.reject.bind(Promise));\n      })\n      .catch(function (server_error) {\n        // Construct real Error object\n        const err = new Error(server_error.message.message);\n        err.metadata = server_error.message || {};\n        err.metadata.status_code = server_error.status_code;\n        err.metadata.title = server_error.title;\n\n        // Log error in collapsed group\n        console.groupCollapsed(\n          method,\n          server_error.status_code,\n          server_error.title\n        );\n        // console.error(url_without_query);\n        if ('message' in server_error) {\n          console.error(method == 'GET' ? url_with_query : url_without_query);\n          console.error(server_error.message.message);\n          console.error(server_error.message.context);\n        }\n        console.groupEnd();\n\n        throw err;\n      });\n\n    // Check cache for GET/POST\n    if (use_cache && (method == 'GET' || method == 'POST')) {\n      this.cache[url_with_query] = request;\n    }\n\n    return request;\n  }\n\n  get(meta_id, args) {\n    return this._resource('GET', meta_id, args);\n  }\n\n  post(meta_id, data) {\n    return this._resource('POST', meta_id, {}, data);\n  }\n\n  patch(meta_id, data) {\n    return this._resource('PATCH', meta_id, {}, data);\n  }\n\n  delete(meta_id, args) {\n    return this._resource('DELETE', meta_id, args);\n  }\n}\n\nfunction buildQueryString(options) {\n  const keys = [];\n  if (typeof options != 'undefined') {\n    // Meta data defaults to true;\n    if (typeof options.meta_data == 'undefined') {\n      options.meta_data = true;\n    }\n\n    // Map the keys of the options object to an array of encoded url components\n    const params = Object.entries(options).sort(([a], [b]) =>\n      a.localeCompare(b)\n    );\n    for (let [key, value] of params) {\n      switch (key) {\n        case 'where':\n          // where: { name: 'column_name', op: '=', value: 'value' }\n          // where: [{ name: 'column_name', op: '=', value: 'value' }]\n          if (typeof value.length == 'undefined') value = [value];\n\n          keys.push(\n            value\n              .map(function (where) {\n                return 'where=' + encodeURIComponent(JSON.stringify(where));\n              })\n              .join('&')\n          );\n          break;\n\n        case 'order_by':\n          // So many possibilities...\n          // order_by: '-?column_name'\n          // order_by: ['-?column_name']\n          // order_by: { 'column_name': 'asc|desc' }\n          // order_by: [{ 'column_name': 'asc|desc' }]\n          // order_by: { column: 'column_name', direction: 'asc|desc' }\n          // order_by: [{ column: 'column_name', direction: 'asc|desc' }]\n          if (typeof value.length == 'undefined') value = [value];\n\n          keys.push(\n            key +\n              '=' +\n              encodeURIComponent(\n                value\n                  .map(function (o) {\n                    return (\n                      (typeof o.direction != 'undefined' &&\n                      o.direction != 'asc'\n                        ? '-'\n                        : '') + o.column\n                    );\n                  })\n                  .join(',')\n              )\n          );\n          break;\n\n        case 'limit':\n        // limit: number\n        /* eslint-disable-next-line no-fallthrough */\n        case 'offset':\n          // offset: number\n          var parsedNum = parseInt(value);\n          if (!isNaN(parsedNum)) {\n            keys.push(key + '=' + parsedNum);\n          }\n          break;\n\n        case 'session_id':\n          keys.push(\n            'session_id=' + encodeURIComponent(JSON.stringify(value))\n          );\n          break;\n\n        case 'meta_data':\n        case 'args':\n        case 'exclude':\n        case 'include':\n          keys.push(key + '=' + encodeURIComponent(JSON.stringify(value)));\n          break;\n        default:\n          console.log('query_options: could not find key', key, value);\n      }\n    }\n  }\n\n  // Return the query string by joining the array with &'s\n  return keys.length ? '?' + keys.join('&') : '?';\n}\n
\\x9e5fe93f5295271167972950be9c36010e87ed204ad5a82cc54e2dc48cd7182a	162f535a-9b63-4f55-9073-5bf8610d4479
\\xa0009e5f0f305834c9afed2e596c1f9f9493b777f9c785d4d4963c1fee4e13c5	/${2}/widget.module/${3}@${4}.js
\\xa2b8ae9fd1c755d5810aa83bb8ce85f46ad5ce7c8c2e78380f4ab2309acdb5e8	/{$2}/widget.module/{$3}.css
\\xa39fc99f29d67cb06ef8649e4b2848eb1aa9e96a0b8962ad743929007f050b2a	6d7d94f5-2ca6-4d26-b07a-ccc593ed17ce
\\xad44929be243235f26fe1f9ece07575fc54942d19d849ca864d3677e36d86e48	ca248b74-815c-440a-b216-716df835b269
\\xad9f58e39d308a448c033f2eb4bb8f14b1bdbdef415ada02159e7211539559cc	widget/get_component/{text,text,text}
\\xaeafc0275bc64bd883e673b8bd2b825409dd725924b01b0cea825af5e1ee8d4c	widget-element
\\xaf93afe8678566fba05a114e422bf6db9392bd80eb8f7c6207f5c92d7f8ddba6	ad4a5a8b-769e-4da1-8c80-d0db2327ff8f
\\xb107f8a64f337139abe1a6c7f6d908dd59819a1118b94ba1144bb19a68f4b564	2650a0b5-3b77-4cbf-b391-a25cb08d73a8
\\xb34c9ee559c0e464d5ec32ca089bec29548e34eb1f1c6da9d6b24828890d3429	13aa89ca-03b6-44af-90b1-7d1541b8d1b1
\\xb5bea41b6c623f7c09f1bf24dcae58ebab3c0cdd90ad966bc43a45b44867e12b	true
\\xb6bf7bc8d96f3ea9d132c83b3da8e7760e420138485657372db4d6a981d3fd9e	endpoint
\\xbeecded4f623ef59c53b5b4c9e7efefc9ce150b95aa4be24a011ea15ee143a8e	/${2}/widget.component/${3}.js
\\xc0d2856b74d0df05b9d4456b177950351bd88e98b77f12574dfb7a911acee0d0	field
\\xc192ec46332c12eeaee0f7a283a32e20d67b553f60fae5100bc054f16fc26e5b	import {Field} from './field@0.3.1.js';\nimport {Callbacks} from './util@0.3.1.js';\n\nexport class Row {\n    constructor(relation, response) {\n        this.relation = relation;\n        this.schema = relation.schema;\n        this.row_data = response.result[0].row;\n\n        this.callbacks = new Callbacks();\n        this.cached_fields = {};\n        this.columns = response.columns || null;\n        this.pk_column_name = null;\n        this.pk_value = null;\n        this.id = null;\n        this.to_url = function () {\n            console.error(\n                'You must call a row with "meta_data: true" in order to use the to_url function'\n            );\n            throw 'Datum.js: Programming Error';\n        };\n\n        if (typeof response.pk != 'undefined') {\n            this.pk_column_name = response.pk;\n            this.pk_value = this.get(this.pk_column_name);\n            // this.id = {"pk_column_id":{"relation_id":{"schema_id":{"name":this.schema.name},"name":this.relation.name},"name":this.pk_column_name},"pk_value": this.pk_value}\n            this.id = {\n                pk_column_id: {\n                    relation_id: this.relation.id,\n                    name: this.pk_column_name,\n                },\n                pk_value: this.pk_value,\n            };\n\n            this.to_url = function (id_only) {\n                return id_only\n                    ? '/row/' +\n                    this.relation.schema.name +\n                    '/' +\n                    this.relation.name +\n                    '/' +\n            /*JSON.stringify(this.pk_value)*/ this.pk_value\n                    : this.relation.schema.database.endpoint.url +\n                    '/row/' +\n                    this.relation.schema.name +\n                    '/' +\n                    this.relation.name +\n                    '/' +\n            /*JSON.stringify(this.pk_value)*/ this.pk_value;\n            };\n        }\n    }\n    get(name) {\n        return this.row_data[name];\n    }\n    set(name, value) {\n        this.row_data[name] = value;\n        return this;\n    }\n    to_string() {\n        return JSON.stringify(this.row_data);\n    }\n    clone() {\n        return new Row(this.relation, {\n            columns: this.columns,\n            pk: this.pk_column_name,\n            result: [{ row: this.row_data }],\n        });\n    }\n    field(name) {\n        if (typeof this.cached_fields[name] == 'undefined') {\n            this.cached_fields[name] = new Field(\n                this,\n                name,\n                name === this.pk_column_name\n            );\n        }\n        return this.cached_fields[name];\n    }\n    fields() {\n        if (this.columns != null) {\n            return this.columns.map(\n                function (c) {\n                    return this.field(c.name);\n                }.bind(this)\n            );\n        }\n        return null;\n    }\n    _triggerEvent(eventType, payload) {\n        switch (eventType) {\n            case 'update': {\n                // TODO: update fields\n                break;\n            }\n        }\n        this.callbacks.call(eventType, payload);\n    }\n    onUpdate(fn) {\n        this.callbacks.add('update', fn);\n    }\n    onDelete(fn) {\n        this.callbacks.add('delete', fn);\n    }\n    update() {\n        return this.relation.schema.database.endpoint\n            .patch(this, this.row_data)\n            .then(\n                function (response) {\n                    if (response == null) {\n                        throw 'Empty response';\n                    }\n                    return this;\n                }.bind(this)\n            )\n            .catch(function (err) {\n                throw 'Update failed: ' + err;\n            });\n    }\n    delete() {\n        return this.relation.schema.database.endpoint\n            .delete(this)\n            .then(function (response) {\n                if (response == null) {\n                    throw 'Empty response';\n                }\n            })\n            .catch(function (err) {\n                throw 'Delete failed: ' + err;\n            });\n    }\n    related_rows(\n        self_column_name,\n        related_relation_name,\n        related_column_name,\n        options\n    ) {\n        var relation_parts = related_relation_name.split('.');\n        if (relation_parts.length < 2) {\n            console.error(\n                'Related relation name must be schema qualified (schema_name.relation_name)'\n            );\n            // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n        }\n\n        var schema_name = relation_parts[0];\n        var relation_name = relation_parts[1];\n        var db = this.relation.schema.database;\n\n        options = options || {};\n        options.where =\n            options.where instanceof Array\n                ? options.where\n                : typeof options.where == 'undefined'\n                    ? []\n                    : [options.where];\n        options.where.push({\n            name: related_column_name,\n            op: '=',\n            value: this.get(self_column_name),\n        });\n\n        return db.schema(schema_name).relation(relation_name).rows(options);\n    }\n    related_row(\n        self_column_name,\n        related_relation_name,\n        related_column_name,\n        options\n    ) {\n        var relation_parts = related_relation_name.split('.');\n        if (relation_parts.length < 2) {\n            console.error(\n                'Related relation name must be schema qualified (schema_name.relation_name)'\n            );\n            // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n        }\n\n        var schema_name = relation_parts[0];\n        var relation_name = relation_parts[1];\n        var db = this.relation.schema.database;\n\n        options = options || {};\n        options.where =\n            options.where instanceof Array\n                ? options.where\n                : typeof options.where == 'undefined'\n                    ? []\n                    : [options.where];\n        options.where.push({\n            name: related_column_name,\n            op: '=',\n            value: this.get(self_column_name),\n        });\n\n        return db.schema(schema_name).relation(relation_name).row(options);\n    }\n}\n
\\xc197f1244993f524f2553ae1622cf33d0164c872999ba22478127890a29caf92	/${2}/widget.component/${3}.css
\\xc357d46e099057aeb162c86d2c8f95b8e02cb717cc475339a60442efc8e8cbfa	/${2}/widget.component/${3}.html
\\xca398db5fff8cedce3bac7f3194dbb26dfe2e40312d2fd787d7e82eb946a37c8	/{$2}/widget.module/{$3}.js
\\xcb218518c86e9538f54d6562b2d09a2e8a1fd11dbb99b21c08ab600688c10356	0e0f1e42-ad32-4018-b1ca-74cacb29fde4
\\xd825e1072a3bc0a2a4632451776b58edc0f073e8969fbe2b7f857cf82135b17a	import {Database} from './database@0.3.1.js';\n\nconst datum = new Database('/endpoint/0.3', {});\n\nexport default datum;
\\xd878e447b5403dee94261936853abbb2deb10f78df7896f17cde535f5dfed472	e09abd4c-dafd-452c-b04f-1305d8051363
\\xdd2741e2734916143a6dbf1d1939cbc04396f10356faf54aba282066cec41b5f	944b5a05-be70-45a1-a549-1301d38799e4
\\xdf0ad6e43880f09c90ebf95f19110178aba6890df0010ebda7485029e2b543b4	schema
\\xe0571e916ca1bd02f969a6623a4060b1206936dc70bf5dd8a26870441a1d5a97	b62e91cc-26be-4379-9812-de8888b1bd2e
\\xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855	
\\xe4a5c10be5aed0f4350aff0652378766f5cb5a9a13eca23ce38647ec5a06c774	{css}
\\xe55b6089d27e1be56b381334cca32c52b4d98ae72456be35e065654f14a4f9ab	b119e594-a7d4-4ec3-8507-4f6c84cbddf9
\\xe87156a66c503f69e97ee8f7026005b7e76c0c2fa6dddde3217238f3abaa7a09	rowset
\\xed71999a858ed88a6125e6cd940f37e2483d924c9c2e8b3e9ea82592b5057950	9c587b94-06e3-4f18-adaa-848e1834a60e
\\xef472878118fef9b467cda731ef400e66418e8cb4be193e60d51d7d6674d0852	/{$2}/widget.module/{$3}@{$4}.js
\\xf19d752a945d150a4300f97b4730a823065cabda12208572dffaf380e793de71	import db from '/org.aquameta.core.widget/widget.module/datum@0.3.1.js';\nimport { track, untrack } from './widget-tracker@1.0.0.js';\n\n/**\n * TODO: Could be overkill...\n *  but if widget had an api for managing state, we'd be able to serialized state\n *  and replace a widget with an updated copy\n * \n * Maybe like Lit:\n *  static properties = { a: {}, b: {} }\n */\n\n/**\n * TODO: fsm integration - so many ways to do this\n *  this would help with managing state since most state would need to be in the fsm?\n * this.widgetMachine = machine;\n */\n\n/**\n * TODO:\n * - How would this work with replacing inner contents with new widget contents?\n * - What happens to the state of child elements?\n * - I guess that's the rub, child state is lost because you edited the parent widget. That's fine.\n */\n\n// TODO: Should use an external store for this, so different versions of WidgetElement can still communicate\nconst widgets = new Set();\n\nexport function WidgetElement(meta, BaseClass) {\n    const { error, metadata } = validateMeta(meta);\n    if (error) {\n        console.log(error);\n        metadata.widgetName = meta;\n    }\n    // TODO: Instead of a set, this should be a map to the current tag name\n    widgets.add(metadata.widgetName);\n    if (!BaseClass) {\n        let request = null;\n        return class extends HTMLElement {\n            static widgetName = metadata.widgetName;\n            #widgetBindingMap = {};\n            #widgetBindings = {};\n            constructor() {\n                super();\n                this._metadata = metadata;\n                this.attachShadow({ mode: 'open' });\n                const attributes = {};\n                for (const attr of this.getAttributeNames()) {\n                    attributes[attr] = this.getAttribute(attr);\n                }\n                if (!request) {\n                    // TODO: this needs to be bundle aware\n                    //  - so we get the widget that is bundled by the calling widget\n                    //  - this will get the wrong html/css for this js component\nrequest = db.schema('widget').table('component').row('name', this._metadata.widgetName)\n                        .then(widget => {\n                            this._metadata.widgetId = widget.get('id');\n                            const template = document.createElement('template');\n                            template.innerHTML = getInnerHtml(widget, attributes);\n                            return template;\n                        });\n                }\n            }\n            connectedCallback() {\n                const parentPromise = findParentWidget(this.shadowRoot).then(parent => {\n                    this._metadata.parent = parent;\n                });\n                request.then(template => {\n                    // put widget in dom\n                    this.shadowRoot.appendChild(template.content.cloneNode(true));\n                    // find all widget bindings\n                    for (const [binding, selector] of Object.entries(this.#widgetBindingMap)) {\n                        this.#widgetBindings[binding] = this.shadowRoot.querySelector(selector);\n                    }\n                    // call back to let widget know it is connected\n                    if (this.onWidgetConnected) {\n                        // ensure all metadata is populated before connecting widget\n                        parentPromise.then(() => {\n                            this.onWidgetConnected();\n                        });\n                    }\n                });\n                // TODO: is this `track` useful? We are already creating a tree of widgets when the component connects\n                track(this._metadata, this);\n            }\n            disconnectedCallback() {\n                untrack(this);\n            }\n            widgetBind(bindingMap) {\n                this.#widgetBindingMap = bindingMap;\n                return this.#widgetBindings;\n            }\n        }\n    } else {\n        // TODO: setting a static member on a base class. Does this even work without conflicting with other components?        // TODO: can we add a mixin to this class that won't interfere but will still allow us to get import.meta and track it\n        BaseClass.widgetName = metadata.widgetName;\n        return class extends BaseClass {\n            static widgetName = metadata.widgetName;\n            constructor() {\n                super();\n                this._metadata = metadata;\n            }\n            connectedCallback() {\n                if (super.connectedCallback) {\n                    super.connectedCallback();\n                }\n                // TODO: what if component doesnt have shadow root\n                const parentPromise = findParentWidget(this.shadowRoot).then(parent => {\n                    this._metadata.parent = parent;\n                    if (this.onWidgetConnected) {\n                        this.onWidgetConnected();\n                    }\n                });\n                track(this._metadata, this);\n            }\n            disconnectedCallback() {\n                if (super.disconnectedCallbac) {\n                    super.disconnectedCallback();\n                }\n                untrack(this);\n            }\n        }\n    }\n}\n\n// TODO: Why is this async?\nasync function findParentWidget(root) {\n    if (!root) {\n        return null;\n    }\n    // TODO: don't use getRootNode. traverse manually to find tagNames in widgets Set\n    //  - also not sure its worth it for defining semantics lookup because slots would cause problems\n    let parent = null;\n    let node = root.host.getRootNode().host;\n    while (node && node !== document.body) {\n        if (!node.tagName) {\n            break;\n        }\n        if (widgets.has(node.tagName.toLowerCase())) {\n            parent = node;\n            break;\n        }\n        node = node.getRootNode().host;\n    }\n    return parent;\n}\n\n// TODO: provide a subscription method to intercept this and add a dev\n// parameter e.g. 'test-widget' -> 'test-widget-1'\nexport function register(Element, options) {\n    customElements.define(Element.widgetName, Element, options);\n    return (attributes) => {\n        const el = document.createElement(Element.widgetName);\n        for (const [key, value] of Object.entries(attributes)) {\n            // TODO: If Element is a WidgetElement, we can use the static properties to figure out if each key is a attribute or property\n\n            // TODO: Could support a mix of things here\n            //  * strings are attributes\n            //  * objects are properties\n            //  * objects with object.attribute=true, object.value is a attribute\n            //  * objects with object.attribute=false, object.value is a property\n            if (typeof value !== 'object') {\n                el.setAttribute(key, value);\n            } else if (Object.hasOwn(value, 'attribute')) {\n                if (value.attribute) {\n                    el.setAttribute(key, value.value);\n                } else {\n                    el[key] = value.value;\n                }\n            } else {\n                el[key] = value;\n            }\n        }\n        return el;\n    }\n}\n\n// TODO: figure out most efficient way to add css\n// - Does this causes page bloat?\n// - Is it better to add a css import here?\nfunction getInnerHtml(widget, attributes) {\n    let contents = `<style>${widget.get('css') || ''}</style>${widget.get('html') || ''}`;\n    for (const [key, value] of Object.entries(attributes)) {\n        contents = contents.replaceAll(`{attrs.${key}}`, value);\n    }\n    return contents;\n}\n\nfunction validateMeta(meta) {\n    const metadata = {\n        bundleName: null,\n        widgetName: null,\n    }\n    if (!meta) {\n        return {\n            error: 'WidgetElement must be passed `import.meta` to instantiate',\n            metadata,\n        };\n    }\n    if (typeof meta === 'string') {\n        return {\n            error: `WidgetElement wrapper function should be passed import.meta, not a tag name: ${meta}`,\n            metadata,\n        };\n    }\n    const url = meta.url.replace(window.location.origin, '');\n    const [_, bundle, relation, widget] = url.split('/');\n    if (!bundle || !relation || !widget) {\n        return {\n            error: 'WidgetElement must be imported with bundle url',\n            metadata,\n        };\n    }\n    metadata.bundleName = bundle;\n    metadata.widgetName = widget.replace(/\\.js$/, '');\n    if (relation !== 'widget.component') {\n        return {\n            error: 'WidgetElement must be defined in widget.widget table and imported the standard way',\n            metadata,\n        };\n    }\n    return { error: null, metadata };\n}\n\n
\\xf44205015fcce901547eaa0759a70c4fef9bd87ac8302b9d648685f6a81c9842	import {Column} from './column@0.3.1.js';\n\nexport class Field {\n    constructor(row, name, pk) {\n        this.row = row;\n        this.column = new Column(row.relation, name);\n        this.is_primary_key = pk;\n        this.name = name;\n        this.value = row.get(name);\n        this.id = { row_id: this.row.id, column_id: this.column.id };\n        this.to_url = function (id_only) {\n            if (this.row.pk_value == null) {\n                console.error(\n                    'You must call a row with "meta_data: true" in order to use the to_url function'\n                );\n                throw 'Datum.js: Programming Error';\n            }\n            return id_only\n                ? '/field/' +\n                this.row.relation.schema.name +\n                '/' +\n                this.row.relation.name +\n                '/' +\n          /*JSON.stringify(this.row.pk_value)*/ this.row.pk_value +\n                '/' +\n                this.column.name\n                : this.row.relation.schema.database.endpoint.url +\n                '/field/' +\n                this.row.relation.schema.name +\n                '/' +\n                this.row.relation.name +\n                '/' +\n          /*JSON.stringify(this.row.pk_value)*/ this.row.pk_value +\n                '/' +\n                this.column.name;\n        };\n    }\n    get() {\n        return this.row.get(this.name);\n    }\n    set(value) {\n        this.value = value;\n        return this.row.set(this.name, value);\n    }\n    update() {\n        // TODO: This is wrong\n        return this.row.update();\n    }\n}\n
\\xf46df1e87f9e4c832bc950fe6d8f8c7874f78238203a2f144778799aab763759	a95c1253-ef52-46fa-a1df-d2c2843f4a57
\\xf5259fbfbce9732c4b7628a3244a5ae14e95460b33f80222fcf5dd4fdc21784e	datum
\\xf689a2032ebc32c3f7c9ba811e62f04ffec5b1b4dcd0d2d0743cb1ea324cce49	c4691e07-e6e6-4884-b7f6-fee3cc4b29ca
\\xfbfcb4520935bb8d434483d1d06030e1e1f3d6c6fade43de3f6471980cba8ca6	import { Relation, Table, View } from './relation@0.3.1.js';\nimport { Function, FunctionResult, FunctionResultSet } from './function@0.3.1.js';\n\nexport class Schema {\n    constructor(database, name) {\n        this.database = database;\n        this.name = name;\n        this.id = { name: this.name };\n    }\n    relation(name) {\n        return new Relation(this, name);\n    }\n    table(name) {\n        return new Table(this, name);\n    }\n    view(name) {\n        return new View(this, name);\n    }\n    function(identifier, args, options) {\n        /* Function identifier (name and parameter list) */\n        if (typeof identifier == 'object') {\n            var name = identifier.name;\n            var parameter_type_list = identifier.parameters;\n        }\n        /* Selecting a function without specifying the parameters */\n        else {\n            var name = identifier;\n        }\n\n        options = options || {};\n\n         /* Arguments */\n        options.args = {};\n\n        /* `args = undefined` will pass no arguments into the server-side function */\n        if (typeof args != 'undefined') {\n            /* some_function?args={ kwargs: {} } -- Key/value object */\n            if (!(args instanceof Array) && args instanceof Object) {\n                options.args.kwargs = args;\n            }\n            /* some_function?args={ vals: [] } -- Array */\n            else {\n                if (!(args instanceof Array)) {\n                    /* Regular value is placed into array */\n                    args = [args];\n                }\n                options.args.vals = args;\n            }\n        }\n\n        var fn = new Function(this, name, parameter_type_list);\n\n        return this.database.endpoint\n            .get(fn, options)\n            .then(\n                function (response) {\n                    if (!response) {\n                        throw 'Empty response';\n                    } else if (!response.result.length) {\n                      // it may be okay for result to be empty in some scenarios\n                      throw 'Result set empty';\n                    }\n                    if (response.result.length != 1) {\n                        return new FunctionResultSet(fn, response);\n                    }\n                    const fr = new FunctionResult(fn, response);\n                  return fr;\n                }\n            )\n            .catch(function (err) {\n                throw err;\n            });\n    }\n}\n
\\xfc8fbb48a3a16bfdd85345d0b6aa543ebd805c370e5b763ed75207185093fca3	relation
\\xfd9484c59f1ae3a4d03500dbef82da2ca684a8323153097cac34e11595995900	8d505d41-035b-4aeb-9d24-adfdf82b6fba
