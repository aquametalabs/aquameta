\\x00a6c75f761f2b44df0ffd2cc24af623f040e778c9d8167e276cdee4c2e7c760	// TODO: Should use an external store for this, so different versions of WidgetElement can still communicate (! good point)\nexport const widgets = new Set();\n\nexport const widgetSymbol = Symbol.for("Widget");\n\nexport function isWidgetClass(cl) {\n  return widgetSymbol in cl;\n}\n\nexport function isWidgetInstance(inst) {\n  return widgetSymbol in inst.constructor;\n}\n\nexport function findParentWidget(root) {\n    if (!root) {\n        return null;\n    }\n\n    let node;\n    // Initialize node to the widget's parent node.\n    if (root instanceof ShadowRoot) {\n        node = root.host.parentNode;\n    } else {\n        node = root.parentNode;\n    }\n\n    while (node && node !== document.body) {\n        if (node instanceof ShadowRoot) {\n            node = node.host;\n        }\n        if (isWidgetInstance(node)) {\n            return node;\n        }\n        node = node.parentNode;\n    }\n    return parent;\n}\n\n// Injecting css into each component should be fine because of:\n// https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_shadow_DOM#internal_versus_external_styles\nexport function getInnerHtml(widget) {\n    const html = widget.get('html') || '';\n    const css = widget.get('css') || '';\n    if (css && css !== '') {\n        return `<style>${css}</style>${html}`;\n    }\n    return html;\n}\n\nexport function validateMeta(meta) {\n    const metadata = {\n        bundleName: null,\n        widgetName: null,\n    }\n    if (!meta) {\n        return {\n            error: 'WidgetElement must be passed `import.meta` to instantiate',\n            metadata,\n        };\n    }\n    if (typeof meta === 'string') {\n        return {\n            error: `WidgetElement wrapper function should be passed import.meta, not a tag name: ${meta}`,\n            metadata,\n        };\n    }\n    const url = meta.url.replace(window.location.origin, '');\n    const splitUrl = url.split('/');\n    let bundle, version, relation, widget;\n    if (splitUrl.length === 5) {\n        bundle =  splitUrl[1];\n        version =  splitUrl[2];\n        relation =  splitUrl[3];\n        widget =  splitUrl[4];\n    } else if (splitUrl.length === 4) {\n        // dev\n        bundle =  splitUrl[1];\n        relation =  splitUrl[2];\n        widget =  splitUrl[3];\n    } else {\n        return {\n            error: 'WidgetElement must be imported with bundle url',\n            metadata,\n        };\n    }\n    metadata.bundleName = bundle;\n    metadata.widgetName = widget.replace(/\\.js$/, '');\n    metadata.version = version;\n    if (relation !== 'widget.component') {\n        return {\n            error: 'WidgetElement must be defined in widget.widget table and imported the standard way',\n            metadata,\n        };\n    }\n    return { error: null, metadata };\n}\n\nexport function toKebabCase(name) {\n    return name.replace(/([A-Z])/g, cap => `-${cap.toLowerCase()}`);\n}
\\x01449daf0238c46c3b795317d20c809ccb757cd3e62ac69cc4910f7bdc31518e	import { define, Widget } from '/org.aquameta.core.widget/widget.module/widget.js';\n\nexport default define(\n    import.meta,\n    class JazzyButton extends Widget.Element {\n        static color = Widget.Attr;\n        static row = Widget.Prop;\n        static name = Widget.Prop;\n        static click = Widget.Event.detail(this.name);\n\n        onWidgetConnected() {\n            this.addListener(this, 'click', this.click.dispatch);\n        }\n\n        onWidgetUpdate(prop) {\n            if (prop === 'color') {\n                this.style.setProperty('--color', this.color);\n            }\n        }\n    }\n);
\\x01a90fbb77b594a1517e28d9dbed3bad27054f9bd360c13c829b16b32805444b	import { Rowset } from './rowset.js';\nimport { Row } from './row.js';\nimport { Column } from './column.js';\n\nfunction relationId(id) {\n    return {\n        url() {\n            return '/relation/' + id.schema_id.name + '/' + id.name;\n        },\n    };\n}\n\nexport class Relation {\n    constructor(schema, name) {\n        this.schema = schema;\n        this.name = name;\n        this.id = { schema_id: this.schema.id, name: this.name };\n    }\n    to_url(id_only) {\n        return id_only\n            ? '/relation/' + this.schema.name + '/' + this.name\n            : this.schema.database.endpoint.url +\n            '/relation/' +\n            this.schema.name +\n            '/' +\n            this.name;\n    }\n    column(name) {\n        return new Column(this, name);\n    }\n    // TODO: [idea] if order_by is used, maintain this in rowset.\n    //  - then we will redo the sort client side and ensure events are put in the right place by diffing the ordered rowset\n    rows(options) {\n        return this.schema.database.endpoint\n            .get(this, options)\n            .then(\n                function (rows) {\n                    if (rows == null) {\n                        throw 'Empty response';\n                    } /*\n              else if (rows.result.length < 1) {\n                  throw 'No rows returned';\n              }*/\n                    const rowset = new Rowset(this, rows, options);\n                    this.schema.database.track(this.to_url(true), rowset);\n                    return rowset;\n                }.bind(this)\n            )\n            .catch(function (err) {\n                throw 'Rows request failed: ' + err;\n            });\n    }\n    row() {\n        // TODO: minimize the number of ways to call row. this code is strange and complicated\n        //  - maybe it gets better with ide type definitions\n\n        // Multiple different ways to call 'row' function\n\n        // 1. Calling with Options object\n        if (typeof arguments[0] == 'object') {\n            var obj = arguments[0];\n            var args = arguments[1] || {};\n\n            // Relation.row({ where: { column_name: 'column_name', op: '=', value: 'value' } })\n            // Maybe it should be this one: Relation.row({ where: { column_name: value } })\n            if (typeof obj.where != 'undefined') {\n                args.where = obj.where;\n            }\n            // Relation.row({ column_name: 'column_name', op: '=', value: 'value' })\n            // Maybe it should be this one: Relation.row({ column_name: value })\n            else {\n                args.where = obj;\n            }\n        }\n        // 2. Calling with column_name and value\n        else if (typeof arguments[0] == 'string') {\n            // Relation.row(column_name, value [, options_obj])\n            var name = arguments[0];\n            var value = arguments[1];\n            var args = arguments[2] || {};\n\n            args.where = { name: name, op: '=', value: value };\n        }\n        // 3. Calling Relation.row() without arguments\n        else {\n            var args = {};\n        }\n\n        // TODO: Eventually everything should use the cache if events are enabled. Cache should update itself.\n        // Could be scenarios where we don't want the cache, but it caches by request url, so should be pretty safe\n        // Cache without events should work by caching for a few milliseconds to avoid duplicative requests\n        args.use_cache = true;\n\n        return this.schema.database.endpoint\n            .get(this, args)\n            .then(\n                function (row) {\n                    if (row == null) {\n                        throw 'Empty response';\n                    } else if (row.result.length == 0) {\n                        return null; // throw 'No row returned';\n                    } else if (row.result.length > 1) {\n                        throw 'Multiple rows returned';\n                    }\n                    const aqRow = new Row(this, row);\n                    this.schema.database.track(aqRow.to_url(true), aqRow);\n                    return aqRow;\n                }.bind(this)\n            )\n            .catch(function (err) {\n                throw 'Row request failed: ' + err;\n            });\n    }\n}\n\nexport class Table extends Relation {\n    insert(data) {\n        if (typeof data == 'undefined') {\n            // table.insert({}) is equivalent to table.insert()\n            // both will insert default values\n            data = {};\n        }\n\n        // Return inserted row promise\n        return this.schema.database.endpoint\n            .patch(this, data)\n            .then(\n                function (inserted_row) {\n                    if (inserted_row == null) {\n                        throw 'Empty response';\n                    }\n                    if (typeof data.length != 'undefined' && data.length > 1) {\n                        return new Rowset(this, inserted_row, null);\n                    }\n                    return new Row(this, inserted_row);\n                }.bind(this)\n            )\n            .catch(function (err) {\n                throw 'Insert failed: ' + err;\n            });\n    }\n}\n\nexport class View extends Relation {}\n
\\x01ecd9b6e7c9359290ec464456f8dd92769d420b40945d328dd7aa00c1bddb72	core-row-editable
\\x030554cea25cda33841c63215aea347dabe6221a3dbcc5d79cb9247ae7eb445a	:host {\n    --highlight-color: lightblue;\n    --border-width: 2px;\n}\n\ndiv {\n    display: flex;\n    color: gray;\n    font-size: 16px;\n}\n\ndiv > * {\n    box-sizing: border-box;\n    border: var(--border-width) solid transparent;\n    transition: border-color 0.1s;\n}\n\n#icon {\n    background-color: white;\n    border-right-width: 0;\n    border-top-left-radius: 5px;\n    border-bottom-left-radius: 5px;\n    padding: 5px 0 5px 5px;\n}\n\n::slotted(material-icon) {\n    position: relative;\n    bottom: 2px;\n}\n\n#icon:has(+ input:focus),\ninput:focus {\n    border-color: var(--highlight-color);\n}\n\ninput {\n    background-color: white;\n    border-left-width: 0;\n    padding: 5px 10px 5px 3px;\n    outline: none;\n}\n\nbutton {\n    background-color: lightgray;\n    color: dimgray;\n    cursor: pointer;\n    border-top-right-radius: 5px;\n    border-bottom-right-radius: 5px;\n    padding: 5px 10px;\n    outline: none;\n    transition: all 0.1s;\n}\n\nbutton:hover {\n    background-color: gray;\n}\n\nbutton:hover,\nbutton:focus {\n    background-color: gray;\n    color: black;\n}
\\x034cdfe1cdf1e8a3c593a18e43213ea05fc43a524add2c52b8f4a658a6d90a6a	meta-component-helper
\\x03c8e8ddbe2a10aaa70d5801effc641b53e735160801f7473dfc3fd02f8cbe77	9333968d-c297-4134-9c47-ba675a8f06d6
\\x041abec0914b28277d97a49b988d1121baca6a18f1f34f5cbbecefc6d40aadb3	db204596-15af-435a-9bcc-39db62a3fb3c
\\x06299a8cb58b818cdad6f45ac116b198f1f3981f406a72b01feeb837b95c77bd	af294d94-a60e-460c-a760-48397c39fee8
\\x0c2d4eccb02d94239e9d5fb4025d35b47f7b46547da1a627a795b36344e225d5	semantics/column_purpose
\\x0deec97f8543e35e14d005653bd4edf1e99cab2cdcf189a3bcc4fe105af72509	0bef90c9-8ebc-4400-93bb-61fb97116ff5
\\x0e91a4c50fad5d4a88a25ae10897333dfd4232171bbe2c4ac3ad69d4cecbdac0	2167532b-0811-4a60-8d31-7f4d327f8f4b
\\x0ef7883d9899c3e247f5b3d333c1e52ea6646f8e6ab168395640b46900eccd1c	import { Collection } from './widget-collection.js';\nimport { toKebabCase } from './widget-util.js';\n\nconst eventSymbol = Symbol.for("WidgetEvent");\n\nconst logPrefix = '[widget-event]';\n\nexport function isEventClass(cl) {\n    return eventSymbol in cl;\n}\n\nexport function isEventInstance(inst) {\n    return eventSymbol in inst.constructor;\n}\n\nexport class Event {\n    static [eventSymbol];\n    #eventName;\n    #widget;\n    #props;\n    #listeners = [];\n\n    constructor(name, widget, props) {\n        this.#eventName =  `${widget.constructor.metadata.widgetName}:${toKebabCase(name)}`;\n        this.#widget = widget;\n        this.#props = props;\n        this.dispatch = this.dispatch.bind(this);\n    }\n\n    get widget() {\n        return this.#widget;\n    }\n    \n    get name() {\n        return this.#eventName;\n    }\n\n    dispatch(payload = {}) {\n        let detail;\n        if (payload instanceof CustomEvent) {\n            // Forward event.detail\n            // TODO: Maybe this should not be default behavior of event.dispatch, could be e.g. event.forwardEvent\n            detail = payload.detail;\n        } else if (payload instanceof Event) {\n            detail = {};\n        } else {\n            detail = payload;\n        }\n        for (const prop of this.#props) {\n            detail[prop.name] = this.#widget[prop.name];\n        }\n        this.#widget.dispatchEvent(\n            new CustomEvent(this.#eventName, { detail })\n        );\n    }\n\n    /**\n     * Dispatch event when a particular DOM event or Widget.Event is triggered.\n     *\n     * 1. Bind to DOM event on this widget\n     * this.EVENT.bind('click')\n     *\n     * 2. Bind to Widget.Event on a child widget\n     * this.EVENT.bind(this.$.CHILD.EVENT)\n     *\n     * 3. Bind to DOM event on an element in this widget\n     * this.EVENT.bind('click', this.$.CHILD)\n     */\n    bind(...args) {\n        console.warn(`event.bind() has been removed. use this.addListener() instead. found in ${this.#widget.widgetMetadata.widgetName}`);\n        /*\n        if (args.length === 1) {\n            const [event] = args;\n            if (typeof event === 'string') {\n                // this.EVENT.bind('click')\n                this.#widget.addEventListener(event, this.dispatch);\n                this.#listeners.push([event, this.#widget, this.dispatch]);\n            } else if (event instanceof Event) {\n                // this.EVENT.bind(this.$.CHILD.EVENT)\n                // Do not add to this.#listeners because this event will be tracked in the child event.\n                const parent = event.widget.widgetMetadata.parent;\n                if (this.#widget !== parent) {\n                    throw new Error(`${logPrefix} event can only bind to events from direct child widgets.`)\n                }\n                event.addListener(this.dispatch);\n            } else {\n                throw new Error(`${logPrefix} unrecognized event bind parameter.`)\n            }\n        } else if (args.length === 2) {\n            // this.EVENT.bind('click', this.$.CHILD)\n            const [eventName, element] = args;\n            if (element instanceof HTMLElement) {\n                if (!this.#widget.widgetRoot.contains(element)) {\n                    throw new Error(`${logPrefix} event can only bind to elements contained within this widget.`)\n                }\n                element.addEventListener(eventName, this.dispatch);\n                this.#listeners.push([eventName, element, this.dispatch]);\n            } else if (element instanceof Collection) {\n                throw new Error(`${logPrefix} cannot bind listener to Widget.Collection`);\n            }\n        }\n        */\n    }\n\n    addListener(boundFn) {\n        if (!this.#widget) {\n            console.error('addListener: Something went very wrong in Event');\n        }\n        this.#widget.addEventListener(this.#eventName, boundFn);\n        this.#listeners.push([this.#eventName, this.#widget, boundFn]);\n    }\n\n    removeListener(fn) {\n        this.#widget.removeEventListener(this.#eventName, fn);\n        this.#listeners = this.#listeners.filter(([eventName, widget, boundFn]) => {\n            if (fn === boundFn && eventName === this.#eventName) {\n                return false;\n            }\n            return true;\n        });\n    }\n    \n    removeListeners() {\n        console.log('removing all listeners', this)\n        if (!this.#widget) {\n            console.error('removeListeners: Something went very wrong in Event');\n        }\n        for (const [eventName, element, listener] of this.#listeners) {\n            element.removeEventListener(eventName, listener);\n        }\n        this.#listeners = [];\n    }\n}
\\x0faac57cfb54859d877cd4b17345e4d7bbece848d159ab9ac96a6471485ac7a1	586fb307-865d-47b6-8617-85ba5cf39033
\\x10e413b4dd81705aa11f68bf87ce439b9bb5bc8e9537d9b0650604253aab171b	meta-element
\\x138170e5e335ceb9fd5272bb67c63c2edff0a699ba500a0888805725d05e83b6	widget-event
\\x1391f21f28b89af15a50454b9d68c0f695feb86c68e09dceb428949c731abe98	\nimport { Endpoint } from './endpoint.js';\nimport { Schema } from './schema.js';\n\nexport class Database {\n    constructor(url, settings) {\n        this.settings = settings;\n\n        if (typeof this.settings.evented === 'string') {\n            console.warn(\n                'Database: `evented` setting has been deprecated. Use `events=true|false` instead'\n            );\n            delete this.settings.evented;\n        }\n\n        this.settings.events = Object.hasOwn(this.settings, 'events')\n            ? this.settings.events\n            : false;\n        this.endpoint = new Endpoint(url, this, this.settings.events);\n        this.tracked = { relation: {}, row: {}, field: {} };\n\n        if (this.settings.events) {\n            this.schema('event')\n                .function('session_create')\n                .then(\n                    function (result) {\n                        const sessionId = result.get('session_create');\n                        if (sessionId) {\n                            this.endpoint.connectSession(sessionId);\n                            persistSessionId(sessionId);\n                        } else {\n                            console.log('got a null sessionId', sessionId);\n                        }\n                    }.bind(this)\n                );\n        }\n    }\n    schema(name) {\n        return new Schema(this, name);\n    }\n    rowIdToRow(rowId) {\n        const schema = rowId.schema_name;\n        const relation = rowId.relation_name;\n        const pkColumn = rowId.pk_column_name;\n        const pkValue = rowId.pk_value;\n        if (!schema || !relation || !pkColumn || !pkValue) {\n            throw new Error('Database - rowIdToRow: invalid rowId')\n        }\n        return this.schema(schema).relation(relation).row(pkColumn, pkValue);\n    }\n    getTracked(id) {\n        let idType;\n        if (id.startsWith('/relation/')) {\n            idType = 'relation';\n        } else if (id.startsWith('/row/')) {\n            idType = 'row';\n        } else if (id.startsWith('/field/')) {\n            idType = 'field';\n        }\n        const tracked = this.tracked[idType][id];\n        if (!tracked) {\n            return [];\n        }\n        return tracked;\n    }\n    track(id, obj) {\n        // TODO: db.track should only be called when events are set up on this query\n        let idType;\n        if (id.startsWith('/relation/')) {\n            idType = 'relation';\n        } else if (id.startsWith('/row/')) {\n            idType = 'row';\n        } else if (id.startsWith('/field/')) {\n            idType = 'field';\n        }\n\n        // columns are supposed to have events, but what does that mean?\n        // functions do not have events\n        // schema do not have events\n\n        switch (idType) {\n            case 'relation':\n                this.tracked.relation[id] = this.tracked.relation[id] || [];\n                this.tracked.relation[id].push(obj);\n                break;\n            case 'row':\n                this.tracked.row[id] = obj;\n                break;\n            case 'field':\n                this.tracked.field[id] = obj;\n                break;\n        }\n    }\n}\n
\\x15426302b94cbb1f9418e114777d5321c7765866d2504850611ca0150dc9c260	@import url(https://fonts.googleapis.com/icon?family=Material+Icons);\n\n.material-icons {\n    display: initial!important;\n}
\\x157cb9fd9cdda863d397e487c0e961a3368ba27fd65c65db7cd008b07ced947d	export class Function {\n    constructor(schema, name, args) {\n        this.schema = schema;\n        this.name = name;\n\n        if (args instanceof Array) {\n            this.args = '{' + args.join(',') + '}';\n        } else {\n            this.args = args;\n        }\n\n        this.id = { schema_id: this.schema.id, name: this.name, args: this.args };\n        this.to_url = function (id_only) {\n            var base_url = id_only ? '' : this.schema.database.endpoint.url;\n            if (typeof this.args != 'undefined') {\n                return (\n                    base_url +\n                    '/function/' +\n                    this.schema.name +\n                    '/' +\n                    this.name +\n                    '/' +\n                    this.args\n                );\n            }\n            return base_url + '/function/' + this.schema.name + '/' + this.name;\n        };\n    }\n}\n\nexport class FunctionResult {\n    constructor(fn, response) {\n        this.function = fn;\n        this.schema = fn.schema;\n        this.row_data = response.result[0].row;\n        this.rows = response.result;\n        this.columns = response.columns;\n    }\n    get(name) {\n        return this.row_data[name];\n    }\n    to_string() {\n        return JSON.stringify(this.row_data);\n    }\n    map(fn) {\n        return this.rows\n            .map(\n                function (row) {\n                    return new FunctionResult(this.function, {\n                        columns: this.columns,\n                        result: [row],\n                    });\n                }.bind(this)\n            )\n            .map(fn);\n    }\n    forEach(fn) {\n        return this.rows\n            .map(\n                function (row) {\n                    return new FunctionResult(this.function, {\n                        columns: this.columns,\n                        result: [row],\n                    });\n                }.bind(this)\n            )\n            .forEach(fn);\n    }\n    related_rows(\n        self_column_name,\n        related_relation_name,\n        related_column_name,\n        options\n    ) {\n        var relation_parts = related_relation_name.split('.');\n        if (relation_parts.length < 2) {\n            console.error(\n                'Related relation name must be schema qualified (schema_name.relation_name)'\n            );\n            /* throw "Related relation name must be schema qualified (schema_name.relation_name)"; */\n        }\n\n        var schema_name = relation_parts[0];\n        var relation_name = relation_parts[1];\n        var db = this.function.schema.database;\n\n        options = options || {};\n        options.where =\n            options.where instanceof Array\n                ? options.where\n                : typeof options.where == 'undefined'\n                    ? []\n                    : [options.where];\n        options.where.push({\n            name: related_column_name,\n            op: '=',\n            value: this.get(self_column_name),\n        });\n\n        return db.schema(schema_name).relation(relation_name).rows(options);\n    }\n    related_row(\n        self_column_name,\n        related_relation_name,\n        related_column_name,\n        options\n    ) {\n        var relation_parts = related_relation_name.split('.');\n        if (relation_parts.length < 2) {\n            console.error(\n                'Related relation name must be schema qualified (schema_name.relation_name)'\n            );\n            /* throw "Related relation name must be schema qualified (schema_name.relation_name)"; */\n        }\n\n        var schema_name = relation_parts[0];\n        var relation_name = relation_parts[1];\n        var db = this.function.schema.database;\n\n        options = options || {};\n        options.where =\n            options.where instanceof Array\n                ? options.where\n                : typeof options.where == 'undefined'\n                    ? []\n                    : [options.where];\n        options.where.push({\n            name: related_column_name,\n            op: '=',\n            value: this.get(self_column_name),\n        });\n\n        return db.schema(schema_name).relation(relation_name).row(options);\n    }\n}\n\nexport class FunctionResultSet {\n    constructor(fn, response) {\n        this.function = fn;\n        this.schema = fn.schema;\n        this.columns = response.columns;\n        this.rows = response.result;\n    }\n    map(fn) {\n        return this.rows\n            .map(\n                function (row) {\n                    return new FunctionResult(this.function, {\n                        columns: this.columns,\n                        result: [row],\n                    });\n                }.bind(this)\n            )\n            .map(fn);\n    }\n    forEach(fn) {\n        return this.rows\n            .map(\n                function (row) {\n                    return new FunctionResult(this.function, {\n                        columns: this.columns,\n                        result: [row],\n                    });\n                }.bind(this)\n            )\n            .forEach(fn);\n    }\n    related_rows(\n        self_column_name,\n        related_relation_name,\n        related_column_name,\n        options\n    ) {\n        var relation_parts = related_relation_name.split('.');\n        if (relation_parts.length < 2) {\n            console.error(\n                'Related relation name must be schema qualified (schema_name.relation_name)'\n            );\n            /* throw "Related relation name must be schema qualified (schema_name.relation_name)"; */\n        }\n\n        var schema_name = relation_parts[0];\n        var relation_name = relation_parts[1];\n        var db = this.function.schema.database;\n\n        var values = this.map(function (row) {\n            return row.get(self_column_name);\n        });\n\n        options = options || {};\n        options.where =\n            options.where instanceof Array\n                ? options.where\n                : typeof options.where == 'undefined'\n                    ? []\n                    : [options.where];\n        options.where.push({\n            name: related_column_name,\n            op: 'in',\n            value: values,\n        });\n\n        return db.schema(schema_name).relation(relation_name).rows(options);\n    }\n    related_row(\n        self_column_name,\n        related_relation_name,\n        related_column_name,\n        options\n    ) {\n        var relation_parts = related_relation_name.split('.');\n        if (relation_parts.length < 2) {\n            console.error(\n                'Related relation name must be schema qualified (schema_name.relation_name)'\n            );\n            /* throw "Related relation name must be schema qualified (schema_name.relation_name)"; */\n        }\n\n        var schema_name = relation_parts[0];\n        var relation_name = relation_parts[1];\n        var db = this.function.schema.database;\n\n        var values = this.map(function (row) {\n            return row.get(self_column_name);\n        });\n\n        options = options || {};\n        options.where =\n            options.where instanceof Array\n                ? options.where\n                : typeof options.where == 'undefined'\n                    ? []\n                    : [options.where];\n        options.where.push({\n            name: related_column_name,\n            op: 'in',\n            value: values,\n        });\n\n        return db.schema(schema_name).relation(relation_name).row(options);\n    }\n}
\\x159d4428968c5c779fae276382767b3fc60d2245f445e1d0b8bbec80301fc802	component-storage
\\x164b7118c6ab5c678ce0f4c5d10aaa97e5eb6e71fccf782ed4cb1b0bd0095598	/semantics/${1}/${2}/identifier.js
\\x16ccf899a26641eff821460a4c1b80ad8c26f142c411741a9b1a3f34222a71df	editable
\\x16cedf80ade01c62bdd1ae931d0492330c0b62bf294c08c095ce2fab21a9298d	js
\\x17e7711a30d50125a05ce9223e86fe11e2cafadbed07ab044dbd1d886588bdc5	core-field-display
\\x1963ae273163480c8169eb613b2993f89f7ce0301da45c30fd5a5127923b9034	table, tr, td {\n    border: 1px solid black;\n}\n\ntable {\n    border-collapse: collapse;\n}\n\ntd {\n    padding: 5px;\n}
\\x19640cb8646fba64bb4bfb6daca8dfb22b7c186ac6b7f9d299d8284fd7545a58	8a4fa529-1307-4544-8b1a-fc8cf2539b1f
\\x1b58054a15a62d6fd7eda4fdbbb9c45f785c2c901ac167756eb3308b2476e83f	export default function pathIdentifier(row) {\n    return row.get('path');\n}
\\x1c120beb780f85704e036c7ac577409412a2d202076ab08a6442e378f85d64bf	{css,'','',''}
\\x1e8b1db39250d6446486b0fb92d71bd04e0eda7546fb4661e0bca1025626154f	export function uuid() {\n  const d = new Date().getTime();\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(\n    /[xy]/g,\n    function (c) {\n      const r = (d + Math.random() * 16) % 16 | 0;\n      d = Math.floor(d / 16);\n      return (c == 'x' ? r : (r & 0x7) | 0x8).toString(16);\n    }\n  );\n}\n\nexport function getPersistedSessionId() {\n    return sessionStorage.getItem('sessionId') || null;\n}\n\nexport function persistSessionId(sessionId) {\n    if (sessionId) {\n        sessionStorage.setItem('sessionId', sessionId);\n    }\n}\n\nexport class Callbacks {\n    constructor() {\n        this.map = new Map();\n    }\n    call(cbType, payload) {\n        const callbacks = this.map.get(cbType) || [];\n        for (const callback of callbacks) {\n            callback(payload);\n        }\n    }\n    add(cbType, cb) {\n        this.map.set(\n            cbType,\n            this.map.has(cbType) ? this.map.get(cbType).concat(cb) : [cb]\n        );\n    }\n    remove(cbType, cb) {\n        const callbacks = this.map.get(cbType);\n        if (callbacks) {\n            this.map.set(\n                cbType,\n                callbacks.filter((callback) => callback !== cb)\n            );\n        }\n    }\n}
\\x1f7a5108d5ad09104352d4df2b49e24811c0a139ef210d08b7db5562b766f4ba	core-code-lit
\\x1fe42a8b529104e4082de13b45d0aa102bad6d9699982a933639b8909d769a66	:host {\n    color: black;\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n}\n\n#status-saved {\n    background-color: green;\n    border-radius: 5px;\n    color: white;\n    padding: 5px;\n}\n\n:host(:not([status=saved])) #status-saved,\n:host([has-unsaved-changes]) #status-saved {\n    display: none;\n}\n\n#status-error {\n    background-color: red;\n    border-radius: 5px;\n    color: white;\n    padding: 5px;\n}\n\n:host(:not([status=error])) #status-error,\n:host([has-unsaved-changes]) #status-saved {\n    display: none;\n}\n\n#status-unsaved {\n    color: gold;\n}\n\n:host(:not([has-unsaved-changes])) #status-unsaved {\n    display: none;\n}\n\n@media (prefers-color-scheme: dark) {\n    :host {\n        background-color: #3d3d3d;\n    }\n}\n\n#editor-container,\n#tabs-container {\n    height: 0;\n    flex: 1;\n}\n\n#editor-container:empty,\n#tabs-container:empty {\n    display: none;\n    flex: 0;\n}\n\n#editor-container core-field-edit-code,\n#tabs-container static-tabs {\n    height: 100%;\n}\n\n.label {\n    color: black;\n    margin: 5px;\n    text-transform: uppercase;\n}\n\n#editor-status-bar {\n    display: flex;\n    justify-content: space-between;\n    padding: 4px;\n}\n\n@media (prefers-color-scheme: dark) {\n    :host {\n        color: white;\n    }\n\n    #vim-status-bar {\n        color: white;\n    }\n\n    .label {\n        color: white;\n    }\n}\n\n#vim-status-bar {\n    padding: 5px;\n}
\\x1ff55f48c208bfe88e20bf6f6e17b716fac287ea8d00c0c345992e9fa91bcbc6	export class MetaElement extends HTMLElement {}
\\x2012b59ad444cdab78e35ce53bc4ae5f920c256b5b8a4a3633b485a0e95515c3	179da1b7-9b8a-4d6b-8f50-07545ffd71d7
\\x218937ac37225e2af7cfa65468f3aac039f862eeb892365107e07ed03ad5307b	import { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\nimport { MetaComponentHelper } from '/com.mickey.ui/1.0.0/widget.module/meta-component-helper.js';\nimport SemanticIdentifier from './semantic-identifier.js';\n\n// TODO: How can meta-field be used in a table element that might otherwise remove nonstandard child elements?\n// Does it need to be removed from template before adding to the DOM? Then track text node.\n// Or do you have to resort to meta-field attributes with custom components that use <td is="custom-component">\n\nexport default define(\n    import.meta,\n    class MetaRow extends Widget.LightElement {\n        static row = Widget.Prop;\n        static rowIdentifier = Widget.Prop;\n        static click = Widget.Event.detail(this.row);\n        static identifierSet = Widget.Event.detail(this.row);\n\n        meta = new MetaComponentHelper(this, 'meta-field', 'meta-row');\n\n        onWidgetConnected() {\n            this.meta.init({\n                remove: false,\n                attrs: ['column', 'columns'],\n            });\n            this.addListener(this, 'click', this.click.dispatch);\n            const semanticIdentifier = this.findWidget(SemanticIdentifier);\n            if (semanticIdentifier) {\n                this.addListener(semanticIdentifier.identifierChanged, this.identifierChanged);\n            }\n        }\n\n        identifierChanged(e) {\n            this.rowIdentifier = e.detail.identifier;\n            this.identifierSet.dispatch();\n        }\n\n        onWidgetUpdate(prop) {\n            if (prop === 'row' && this.row) {\n                this.meta.children.forEach(node => {\n                    if (node.attrs.columns) {\n                        node.element.fields = this.getFieldData(node.attrs.columns);\n                    } else if (node.attrs.column) {\n                        node.element.field = this.getFieldData(node.attrs.column);\n                    }\n                });\n                this.meta.childAttributes.forEach(node => {\n                    node.element[node.property] = this.row;\n                });\n            }\n        }\n\n        getFieldData(columns) {\n            if (Array.isArray(columns)) {\n                let foundField = false;\n                const fields = {};\n                for (const column of columns) {\n                    if (!(column in this.row.row_data)) { // datum needs a 'has'\n                        console.error(`row does not have ${column} field`);\n                        continue;\n                    }\n                    fields[column] = this.row.get(column);\n                    foundField = true;\n                }\n                if (!foundField) {\n                    return [];\n                }\n                return fields;\n            } else {\n                const column = columns;\n                if (!(column in this.row.row_data)) { // datum needs a 'has'\n                    console.error(`row does not have ${column} field`);\n                    return;\n                }\n                return this.row.get(column);\n            }\n        }\n    }\n);
\\x21c85de5e27592f8505f4bed3b707b0f3da43e51fe441e5edfbc6fd712941a73	54357919-9d95-45e8-a7b6-ab7686f69769
\\x2202862c9d9e33142c76eba677483baac8065142ca778a93c0fdc8dd32068813	const COMPONENT_STORAGE_EVENT_NAME = 'GLOBAL COMPONENT STORAGE EVENT';\n\nexport class ComponentStorage {\n    #key;\n    #listeners = [];\n    #onStorageBound = null;\n\n    constructor(key) {\n        this.#key = key;\n    }\n\n    get(key) {\n        const data = this.#getData();\n        return data[key];\n    }\n\n    set(key, value) {\n        const data = this.#getData();\n        if (data[key] !== value) {\n            data[key] = value;\n            this.#sync(data);\n        }\n    }\n\n    remove(key) {\n        const data = this.#getData();\n        if (key in data) {\n            delete data[key];\n            this.#sync(data);\n        }\n    }\n        \n    #getData() {\n        const data = localStorage.getItem(this.#key);\n        if (!data) {\n            return {};\n        }\n        try {\n            const parsed = JSON.parse(data);\n            return parsed;\n        } catch (e) {\n            console.error(e);\n            return {};\n        }\n    }\n\n    #sync(data) {\n        localStorage.setItem(this.#key, JSON.stringify(data));\n        this.#triggerListeners(data);\n    }\n\n    #triggerListeners() {\n        document.dispatchEvent(new CustomEvent(COMPONENT_STORAGE_EVENT_NAME));\n    }\n\n    addEventListener(_string, callback) {\n        this.#listeners.push(callback);\n        if (!this.#onStorageBound) {\n            this.#onStorageBound = this.#onStorage.bind(this);\n\n            // TODO: storage in the same tab should be a custom event name just for this component\n\n            // TODO: storage in a different tab should diff data to see if there are actual changes?\n\n            // Listen for events on other pages.\n            window.addEventListener('storage', this.#onStorageBound);\n            \n            // Listen for events on this page.\n            document.addEventListener(COMPONENT_STORAGE_EVENT_NAME, this.#onStorageBound);\n        }\n    }\n\n    removeEventListener(_string, callback) {\n        this.#listeners = this.#listeners.filter(listener => listener === callback);\n        if (!this.#listeners.length) {\n            window.removeEventListener('storage', this.#onStorageBound);\n            document.removeEventListener(COMPONENT_STORAGE_EVENT_NAME, this.#onStorageBound);\n            this.#onStorageBound = null;\n        }\n    }\n\n    #onStorage() {\n        const data = this.#getData();\n        for (const listener of this.#listeners) {\n            listener(data);\n        }\n    }\n}
\\x2234784ea80fc4699ba6e1a1d9a13900538724f5e80d5877770c896580b9bc2f	import { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\n\nexport default define(\n    import.meta,\n    class StaticEventTab extends Widget.Element {\n        static event = Widget.Attr;\n        static label = Widget.Attr;\n        static activated = Widget.Event.detail(this.event, this.label);\n\n        onWidgetConnected() {\n            if (!this.event) {\n                console.error('static-action-tab must have an `event` attribute');\n                return;\n            }\n            this.addListener(this, 'click', this.activated.dispatch);\n        }\n    }\n);\n
\\x2374d239fd3800de1ab330786c6246eb40ae5d878a8aa74b882ba7444aab8196	2e9c362d-17e3-451c-9830-2484290dfbb3
\\x237b8327d977decee5d9b6083a77d1c1e2f5158bf4940196c920f8d1fd83caf5	2a7a3c28-cf8d-4d18-82a1-d6a6124ab8af
\\x23fb720267aa330017d8e2919107ea5cba2ca2ec21a274a7a5eef1d51b4d4d8e	/widgeting
\\x24d97669e358b6dc3f186e613d1ce8b2a5b424a40eba9d8d5de35420b9d68656	import { register, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\n\nexport default register(\n    class CoreRowEditable extends Widget.Element(import.meta) {\n        static row = Widget.Prop;\n    }\n);
\\x262121c5372be8af3ae6ff0d3d138d9e6e1249335222c7f0e02535e35073bb0b	edit
\\x26652d293ba1e763c2e3d0642e2d3b5f15ec89f08c83b27112a6672a513d84b8	import db from '/org.aquameta.core.widget/0.3.1/widget.module/datum.js';\n\nlet promise;\nconst names = new Map();\n\nasync function getPurpose(id) {\n    if (!promise) {\n        promise = db.schema('semantics').relation('relation_purpose').rows()\n            .then(rows => {\n                const purposes = rows.map(i => i);\n                for (const purpose of purposes) {\n                    names.set(purpose.get('id'), purpose.get('purpose'));\n                }\n            })\n    }\n    await promise;\n    return names.get(id);\n}\n\nexport default async function(row) {\n    const purpose = await getPurpose(row.get('purpose_id'));\n    const relId = row.get('relation_id');\n    return `${purpose} ${relId.schema_name}.${relId.name}`\n}
\\x26d6db2fe58a6472e3c4667e28fc77037520c3d01f2457d644bf2b5fc2c9fb92	29e50312-a731-4ebd-b84e-7ea0bb28f6f5
\\x27926b8cc04e2a2153e369287ecd4b383c34b1a0846f31b2a74caeebf218b852	109c3934-88c5-4e27-ad86-2130cd2504c3
\\x2b22c63d173b492f1deca778fce25e946305e461b22961d0ee11347550980b9e	<div>\n    <span id="icon">\n        <slot name="icon"></slot>\n    </span>\n    <input type="text" data-input-placeholder="placeholder" />\n    <button data-button-text="innerText"></button>\n</div>
\\x2da552e9506d1b632ae8278d682a90e3851cd29ef1a3499f8eed59728b6dc2fe	/${2}/widget.module/${3}.css
\\x2e6586e81521aafbf5181820066e52b56b9db004f76ac57aa584e1b48978687b	import { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\nimport dynamicTabContent from './dynamic-tab-content.js';\nimport dynamicTab from './dynamic-tab.js';\n\nexport default define(\n    import.meta,\n    class DynamicTabs extends Widget.Element {\n        static $ = {\n            tabs: Widget.Collection('#tabs'),\n            tabContents: Widget.Collection('#tab-contents'),\n        };\n        static activeTab = Widget.Prop;\n\n        onWidgetUpdate(prop, oldValue, newValue) {\n            if (prop === 'activeTab') {\n                this.$.tabs.setProp(oldValue, { isActive: false });\n                this.$.tabContents.setProp(oldValue, { isActive: false });\n                this.$.tabs.setProp(newValue, { isActive: true });\n                this.$.tabContents.setProp(newValue, { isActive: true });\n            }\n        }\n\n        onOpenTab(event) {\n            this.activeTab = event.detail.tabName;\n        }\n\n        onCloseTab(event) {\n            const {tabName} = event.detail;\n            const closingTab = this.$.tabs.get(tabName);\n            let newActiveTab = null;\n            const closingTabWasActive = closingTab.isActive;\n            if (closingTabWasActive) {\n                const fallback = closingTab.previousSibling || closingTab.nextSibling;\n                if (fallback) {\n                    newActiveTab = fallback.tabName;\n                }\n            }\n            this.$.tabs.delete(tabName)\n            this.$.tabContents.delete(tabName)\n            if (closingTabWasActive) {\n                this.activeTab = newActiveTab;\n            }\n        }\n\n        // TODO: Maybe a weird pattern to call a function on a child.\n        //  I guess would be better to just pass data down from bundle-workspace\n        //  But then need to do like a DOM diff thing to make sure widgets are synced to data.\n        //  Need some sort of widget sync thing anyway.\n        trigger(identifier, elementFn) {\n            if (!this.$.tabs.has(identifier)) {\n                const tab = dynamicTab({ tabName: identifier });\n                this.addListener(tab.open, this.onOpenTab);\n                this.addListener(tab.close, this.onCloseTab);\n                this.$.tabs.set(identifier, tab);\n    \n                const tabContent = dynamicTabContent();\n                const el = elementFn();\n                if (el instanceof Promise) {\n                    el.then(element => {\n                        tabContent.appendChild(element);\n                    })\n                } else {\n                    tabContent.appendChild(el);\n                }\n                this.$.tabContents.set(identifier, tabContent);\n            }\n\n            this.activeTab = identifier;\n        }\n    }\n);
\\x2e947b4c72abb933069c1e8f33422db867d07941458a7e7c6c3df1ac2ddeb306	6f84f745-9a55-413b-b84c-945c10b312d5
\\x2f46f4defc2af4aed1e5839c1adad2b4d98ff6d77348faefc6f709de995a4405	core-row-edit-code
\\x30a0f959dc358319792f33f2da89f7d02f70ecb49ebe7a4edc997eb1c4f73122	import { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\nimport db from '/org.aquameta.core.widget/0.3.1/widget.module/datum.js';\nimport coreFieldEditCode from './core-field-edit-code.js';\nimport staticTabs from './static-tabs.js';\nimport { ComponentStorage } from '../widget.module/component-storage.js';\n\nexport default define(\n    import.meta,\n    class CoreCode extends Widget.Element {\n        static $ = {\n            editor: Widget.Deferred('#editor-container'),\n            tabs: Widget.Deferred('#tabs-container'),\n            useVim: '#use-vim',\n        };\n\n        static activeTab = Widget.Prop.initial(0);\n        static status = Widget.Attr.initial('init');\n        static hasUnsavedChanges = Widget.Attr.initial(false);\n\n        static lastSaved = Widget.Prop.initial(null);\n        static observer = Widget.Prop;\n        static request = Widget.Prop;\n        static row = Widget.Prop;\n        static useVim = Widget.Prop.initial(true);\n        #editorConfig = {};\n        #storage = new ComponentStorage(this);\n\n        onWidgetConnected() {\n            this.addListener(this.$.useVim, 'change', this.#toggleVim);\n            this.addListener(this.#storage, 'storage', this.#onStorageChange);\n            this.#onStorageChange();\n        }\n\n        #onStorageChange(data) {\n            const useVim = this.#storage.get('useVim');\n            this.useVim = typeof useVim === 'undefined' ? true : useVim;\n        }\n\n        onWidgetDisconnected() {\n            if (this.hasUnsavedChanges) {\n                const answer = confirm('This row has unsaved changes. Would you like to save before closing?\\n\\nSelect cancel to discard changes.');\n                if (answer) {\n                    // TODO: unfortunately, nowhere to put the error message if this fails\n                    this.saveRow();\n                }\n            }\n        }\n\n        onWidgetUpdate(prop) {\n            switch (prop) {\n                case 'row':\n                    this.#destroyEditors();\n                    this.#createEditors(getDefaultColumns(this.row));\n                    break;\n                case 'request':\n                    this.request.then(row => {\n                        this.row = row;\n                    })\n                    break;\n                case 'useVim':\n                    if (this.$.editor) {\n                        this.$.editor.useVim = this.useVim;\n                    }\n                    if (this.$.tabs) {\n                        for (const editor of this.$.tabs.tabContents) {\n                            editor.useVim = this.useVim;\n                        }\n                    }\n                    this.#storage.set('useVim', this.useVim);\n                    break;\n                case 'activeTab':\n                    if (this.$.tabs) {\n                        this.$.tabs.activeTab = this.activeTab;\n                    }\n                    break;\n                case 'hasUnsavedChanges':\n                    if (this.hasUnsavedChanges) {\n                        this.addListener(window, 'beforeunload', this.onBeforeUnload);\n                    } else {\n                        this.removeListener(window, 'beforeunload');\n                    }\n                    break;\n            }\n        }\n\n        onBeforeUnload(e) {\n            if (this.hasUnsavedChanges) {\n                e.preventDefault();\n            }\n        }\n\n        #toggleVim(e) {\n            this.useVim = this.$.useVim.checked;\n        }\n\n        #createEditors(columns) {\n            if (columns.length === 1) {\n                this.$.editor = this.#createEditor(columns[0]);\n            } else {\n                const tabs = [];\n                for (const column of columns) {\n                    const editor = this.#createEditor(column, true);\n                    tabs.push({\n                        label: column,\n                        content: editor,\n                    });\n                }\n                this.$.tabs = this.#createStaticTabs(tabs);\n            }\n        }\n\n        #createEditor(column, tabs = false) {\n            const editor = coreFieldEditCode({\n                field: this.row.field(column),\n                type: negotiateFileType(this.row, column),\n                useVim: this.useVim,\n            });\n            this.addListener(editor.change, this.fieldChanged);\n            this.addListener(editor.save, this.saveRow);\n            if (tabs) {\n                this.addListener(editor.nextTab, this.nextTab);\n                this.addListener(editor.previousTab, this.previousTab);\n            }\n            return editor;\n        }\n\n        #createStaticTabs(tabs) {\n            const staticTabEl = staticTabs({ tabs, activeTab: this.activeTab })\n            this.addListener(staticTabEl.tabActivated, this.tabActivated);\n            return staticTabEl;\n        }\n\n        #destroyEditors() {\n            this.$.editor = null;\n            this.$.tabs = null;\n        }\n\n        tabActivated(e) {\n            this.activeTab = e.detail.tabIndex;\n         }\n\n        fieldChanged() {\n            // this.$.editor is defined since this event callback is called from the editor\n            if (this.$.editor) {\n                this.hasUnsavedChanges = this.$.editor.hasUnsavedChanges;\n            }\n            if (this.$.tabs) {\n                for (const editor of this.$.tabs.tabContents) {\n                    if (editor.hasUnsavedChanges) {\n                        this.hasUnsavedChanges = true;\n                        return;\n                    }\n                }\n                this.hasUnsavedChanges = false;\n            }\n        }\n\n        async saveRow() {\n            // core-field-edit-code should call this.field.set instead\n            if (this.$.editor) {\n                this.row.set(this.$.editor.field.name, this.$.editor.value);\n            } else if (this.$.tabs) {\n                for (const editor of this.$.tabs.tabContents) {\n                    this.row.set(editor.field.name, editor.value);\n                }\n            }\n            try {\n                if (this.row) {                   await this.row.update();\n                } else if (this.field) {\n                    await this.field.update();\n                }\n                this.status = 'saved';\n                this.lastSaved = new Date().toLocaleString();\n                this.hasUnsavedChanges = false;\n            } catch (e) {\n                this.status = 'error';\n                console.error(e);\n            }\n        }\n\n        nextTab() {\n            this.activeTab = Math.min(this.activeTab + 1, this.$.tabs.tabContents.length - 1);\n        }\n\n        previousTab() {\n            this.activeTab = Math.max(0, this.activeTab - 1);\n        }\n    }\n);\n\nfunction negotiateFileType(row, column) {\n    const relation = `${row.schema.name}.${row.relation.name}`;\n    if (column === 'content' && relation === 'endpoint.resource') {\n        const resourcePath = row.get('path');\n        if (resourcePath && resourcePath.includes('.')) {\n            if (resourcePath.endsWith('.js.map')) {\n                return 'json';\n            }\n            if (resourcePath.endsWith('.sql')) {\n                return 'pgsql';\n            }\n        }\n        const mimetype = getMimetype(row, column);\n        switch (mimetype) {\n            case null:\n                break;\n            case 'text/html':\n                return 'html';\n            case 'text/css':\n                return 'css';\n            case 'application/javascript':\n            case 'text/javascript':\n                return 'javascript';\n            case 'text/plain':\n            case 'text/richtext':\n                return 'text';\n        }\n    } else if (column === 'content' && relation === 'documentation.bundle_doc') {\n        return 'markdown';\n    } else if (column === 'content' && relation === 'widget.dependency_js') {\n        return 'javascript';\n    } else if (column === 'content' && relation === 'widget.dependency_css') {\n        return 'css';\n    } else if (column === 'content' && relation === 'widget.module') {\n        const rowType = row.get('type');\n        if (rowType === 'js') {\n            return 'javascript';\n        }\n        return rowType;\n    }\n    switch (column) {\n        case 'html':\n        case 'css':\n            return column;\n        case 'post_js':\n        case 'js':\n            return 'javascript';\n        case 'sql':\n        case 'pgsql':\n            return 'pgsql';\n        case 'md':\n        case 'markdown':\n            return 'markdown';\n        case 'text':\n            return 'text';\n        case 'help':\n            return 'markdown';\n    }\n    return 'text';\n}\n\n// TODO: load mimetypes in more robust way\nlet mimetypes = [];\ndb.schema('endpoint').table('mimetype').rows().then(rows => mimetypes = rows.map(i => i));\nfunction getMimetype(row, column) {\n    const mimetypeId = row.get('mimetype_id');\n    if (mimetypeId) {\n        const mimetypeRow = mimetypes.find(m => m.get('id') === mimetypeId);\n        if (mimetypeRow) {\n            return mimetypeRow.get('mimetype');\n        }\n    }\n    return null;\n}\n\n// TODO: Remove this by dropping extra widget columns\nfunction getDefaultColumns(row) {\n    const rel = row.relation;\n    const cols = row.columns.map(c => c.name);\n    const relName = `${rel.schema.name}.${rel.name}`;\n    switch (relName) {\n        case 'widget.widget':\n            return ['html', 'css', 'post_js', 'help'];\n        case 'endpoint.resource':\n            return ['path', 'content'];\n        case 'widget.dependency_js':\n        case 'widget.dependency_css':\n            return ['version', 'content'];\n        case 'widget.component':\n            return ['html', 'css', 'js', 'help'];\n        case 'widget.module':\n            return ['content'];\n        case 'documentation.bundle_doc':\n            return ['title', 'content'];\n    }\n    return cols;\n}\n
\\x31150644a58f815ec902a383ea5983bd8aa1671608ee7691a4ae0cbf366a5859	7ad9377f-f803-4eae-87a3-965b1b757ad5
\\x3202850e2fc1416d839a487a9859f119d232fec15b98fec1820f1e733d0ae752	4451f440-4abb-4099-9a2b-3bfaf223b37f
\\x321f0f72aa53dbbcc4ae76ecaeead9ef94c78fca890c678b1d9703736b819953	:host {\n    display: block;\n    height: 100%;\n}\n\n@media (prefers-color-scheme: dark) {\n    :host {\n        background-color: #3d3d3d;\n        color: white;\n    }\n}\n\n/*\n* {\n    box-sizing: border-box;\n}\n*/\n\nh1 {\n    display: inline-block;\n    font-size: xx-large;\n    vertical-align: middle;\n}\n\n#link material-icon::part(icon) {\n    font-size: xx-large;\n}\n\n#link, #link:visited {\n    color: white;\n    text-decoration: none;\n}\n\n#header {\n    padding: 0 10px;\n}\n\nnav {\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    padding: 0 10px 5px;\n}\n\nmaterial-icon {\n    font-size: 16px;\n}\n\nstatic-event-tab::part(label) {\n    font-size: 16px;\n    vertical-align: middle;\n}\n\n#vertical {\n    display: flex;\n    height: 100%;\n    flex-direction: column;\n}\n\n#horizontal {\n    display: flex;\n    flex: 1;\n    flex-direction: row;\n    height: 0;\n}\n\n#contents {\n    max-width: 500px;\n    min-width: 350px;\n    overflow-y: auto;\n    width: 30%;\n}\n\n#details {\n    flex: 1;\n}\n\ndynamic-tabs {\n    height: 100%;\n}
\\x329afca82c29e8866bc1cac16a6eb626d069c8da0775d27581733c9a5aab97bf	import { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\nimport db, { DatumMachine } from '/org.aquameta.core.widget/0.3.1/widget.module/datum.js';\n\nimport './meta-rows.js';\nimport './meta-row.js';\nimport './meta-field.js';\nimport './semantic-identifier.js';\n\n/**\n * I think the next step is to rewrite datum\n * - it should work with flat_types\n * - it should have metadata by default, metadata useful for semantics\n * - it should have a better api\n * - it should be written as individual modules\n * - it should have callbacks for events\n * - it should open a socket when a request has events=true, not once for the whole page\n * - maybe it could know when to close the socket, too. when all evented queries are removed or when a timeout has been reached\n * - it should have type definitions\n */\n\n// There are 5 things\n// * Context - state data. This is where context data is kept\n// * State - finite state position. This is the state we are in.\n// * Transition - movement between one position and another.\n// * Event - intitatior for a state transition. named the same as their transition. Dispatch these to invoke a transition.\n// * Action - side-effects that are called during state transition. onEnter/onExit\n\nexport default define(\n    import.meta,\n    class BundleContents extends Widget.Element {\n        static $ = {\n            metaRows: 'meta-rows'\n        };\n        static bundleName = Widget.Attr;\n        static rows = Widget.Prop;\n        static activated = Widget.Event;\n        static state = Widget.Fsm(DatumMachine);\n\n        onWidgetConnected() {\n            this.addListener(this.$.metaRows.added, this.rowAdded);\n            this.addListener(this.$.metaRows.rowsHaveIdentifiers, this.onRowSyncDone);\n        }\n\n        onRowSyncDone() {\n            this.$.metaRows.sort((a, b) => a.localeCompare(b));\n        }\n\n        onWidgetUpdate(prop) {\n            if (prop === 'bundleName') {\n                this.state.dispatch(\n                    // In this context, `request` is called an "event"\n                    DatumMachine.request,\n                    db.schema('bundle').relation('bundle').row('name', this.bundleName)\n                        .then(row => row.related_rows('id', 'bundle.head_db_stage', 'bundle_id')),\n                );\n            }\n        }\n        \n        // This is where actions go\n        onWidgetStateChange(contextChanges, transitionData) {\n            // TODO: See how far you can get without onWidgetStateChange\n            //  * Might be able to just use this.widgetSync\n            //  * Then could maybe have onWidgetStateChange be called for every individual change, instead of bulk\n            //  * Or maybe you could do\n            // this.widgetSync(this.state.context.loading, this.updateLoadingStatus);\n            // this.bindWidgetContext('loading', this.updateLoadingStatus);\n        }\n\n        rowAdded(event) {\n            const {element} = event.detail;\n            // TODO: Is it weird to be using Events for DOM events? not sure 'click' is a good name. It should be activated that is bound to a few different dom events\n            this.addListener(element.click, this.rowActivated);\n        }\n\n        rowActivated(event) {\n            const metaRow = event.target;\n            const identifier = metaRow.querySelector('semantic-identifier').identifier;\n            this.activated.dispatch({ ...event.detail, identifier});\n        }\n    }\n)\n
\\x32ee4fc697b63201eb1a9a106fdc517a8c47c990b421a0d037b03c6b22744574	c6bc431c-9f84-4dba-809b-8f19d0eefb1c
\\x3385c3da79d6d33cd2f8b51b7389a8ed6f289d91c1fe6d32a8c39e73075bdbad	0984df08-f5b0-441d-b09a-3315d5525011
\\x347f8b2cdc581df61e5d107c29cbaa626c274e943143e24e99444368212c9e70	<span class="material-icons" part="icon" data-icon="innerText"></span>
\\x3549b0028b75d981cdda2e573e9cb49dedc200185876df299f912b79f69dabd8	database
\\x36e64f19f57a05c8cd5b6bf7eff72703b4bbab19def7832eb4e686e7fa482eef	css
\\x3760e0a1c7a30bad60c2d489a4d9ce43b06d909b9615e56c18c3f1fd600cc1ca	7352243a-da40-498c-b0d9-e8fb5449f875
\\x3a660d00838a23385ad48b9b0fc436c9a9757988254544f31f19615284ae1aa9	b8ea810e-c92e-495d-ac73-4f7aababc5da
\\x3a977f7685dc91e51e197b3feaa9fb9a13b5f0cc5fc07344dcc397f84dd76677	7c8ed3e3-e83d-416b-a836-492620b88090
\\x3b0e735bb094f4159106949505ef91b36b5c14062624418d2ffda78206dd7975	export class Column {\n    constructor(relation, name) {\n        this.relation = relation;\n        this.name = name;\n        this.id = { relation_id: relation.id, name: name };\n    }\n}
\\x3c46d3be0ffade123fc36912f61074d73d0af563cdc26fe15f2bae8d86c2d4e5	<div id="editor-status-bar">\n    <div>\n        <input id="use-vim" type="checkbox" data-use-vim="checked">\n        <label for="use-vim">vim</label>\n    </div>\n    <div id="save-status">\n        <span data-last-saved="innerText"></span>\n        <span id="status-unsaved">*</span>\n        <span id="status-saved">saved</span>\n        <span id="status-error">error</span>\n    </div>\n</div>\n<div id="editor-container"></div>\n<div id="tabs-container"></div>
\\x3cde5b4927b71d6e6258adff1f8e12173a08b4695e5337306a13b28ad65cc576	/${2}/${4}/widget.module/${3}.css
\\x3ce98f9b9c6702495cf42e712a9844a75a577e357109c323d87d6ccdad2d2a0a	66bb9bf1-a70a-4b16-81d4-ad39f848226b
\\x3d365a67f46f33c84cbce9a0728b8dff3b7aa291cf1f9a4da5fe1841d8d61c02	/poc
\\x3db855761f48c2b74390a036f8be66ef68d7862ecb34a1e74a8dcc20f0aaf050	semantic-identifier
\\x3e5beb81bb1006deb3feec525e4c2ea6178bf1b7130848c9083649eb5d152165	eb1a4499-be4f-4e05-85d4-e9ae0c4b4403
\\x3eeefbf62ba7330a092372a92c015f65f2162bc12dcdac1078401bc179f9cc53	\nimport db from '/org.aquameta.core.widget/0.3.1/widget.module/datum.js';\nimport { isPropClass, Attr } from './widget-prop.js';\nimport { isFsmClass } from './widget-fsm.js';\nimport { isEventClass,  isEventInstance } from './widget-event.js';\nimport { getInnerHtml, findParentWidget, toKebabCase, widgetSymbol } from './widget-util.js';\nimport { Collection, Deferred } from './widget-collection.js';\n\nconst logPrefix = '[widget-element]';\n\nexport { Collection, Deferred };\n    \nclass WidgetElement extends HTMLElement {\n    // Static members.\n    static [widgetSymbol];\n    static metadata;\n    static useShadowDom = true;\n\n    // Private instance members.\n    #metadata;\n    #propVariableBindings = new Map();\n    #reflectingAttribute = null;\n    #root = null;\n    #stateVariableBindings = new Map();\n    #subscriptions = [];\n    #widgetConnected = false;\n    #widgetRequest = null;\n    #widgetUpdates = [];\n\n    // Static methods.\n    static init() {\n        if (Object.hasOwnProperty(this, 'init')) {\n            return;\n        }\n        Object.defineProperty(this.prototype, 'init', {enumerable: false, configurable: false});\n\n        const props = [];\n        const events = [];\n        for (const [memberName, memberData] of Object.entries(this)) {\n            if (memberName === 'metadata') { \n                continue;\n            } else if (memberName === '$') { \n                Object.defineProperty(this.prototype, memberName, this.getElementBindingPropertyDescriptor(memberName, memberData));\n            } else if (memberName === 'state') {\n                // Initialize state machine.\n                if (!isFsmClass(this.state.type)) {\n                    throw new Error('static state must be an Fsm')\n                }\n                Object.defineProperty(this.prototype, memberName, this.getFsmPropertyDescriptor(memberName, this.state));\n            } else if (isPropClass(memberData.type)) {\n                props.push([memberName, memberData]);\n            } else if (isEventClass(memberData.type)) {\n                events.push([memberName, memberData]);\n            }\n        }\n        // Initialize base prop data.\n        const propDataMap = new Map();\n        this.propNameMap = new Map();\n        for (const [propName, propData] of props) {\n            const prop = new propData.type(propName, propData.value);\n            propDataMap.set(propData, prop);\n            Object.defineProperty(this.prototype, propName, this.getPropertyDescriptor(propName, prop));\n        }\n        // Initialize event data.\n        this.eventNameMap = new Map();\n        for (const [eventName, eventData] of events) {\n            const props = eventData.details.map(propData => propDataMap.get(propData));\n            Object.defineProperty(this.prototype, eventName, this.getEventPropertyDescriptor(eventName, eventData, props));\n        }\n    }\n\n    static getElementBindingPropertyDescriptor(name, data) {\n        const bindings = [];\n        const nullBindings = {};\n        for (const [name, binding] of Object.entries(data)) {\n            bindings.push({\n                name,\n                selector: binding instanceof Object ? binding.selector : binding,\n                type: typeof binding === 'string' ? 'string' : binding.type,\n            });\n            Object.defineProperty(nullBindings, name, {\n                enumerable: true,\n                configurable: false,\n                value: null,\n            });\n        }\n        this.bindingData = {\n            name: `__${name}`,\n            bindings,\n            nullBindings,\n        };\n        return {\n            enumerable: false,\n            configurable: false,\n            get() {\n                return this[this.constructor.bindingData.name];\n            }\n        };\n    }\n\n    static getFsmPropertyDescriptor(name, fsmData) {\n        const fsm = {\n            name: `__${name}`,\n            type: fsmData.type,\n            machine: fsmData.machine,\n        };\n        this.fsmData = fsm;\n        return {\n            configurable: false,\n            enumerable: true,\n            get() {\n                return this[this.constructor.fsmData.name];\n            }\n        };\n    }\n\n    static getEventPropertyDescriptor(name, eventData, props = []) {\n        const event = {\n            name: `__${name}`,\n            type: eventData.type,\n            props: props,\n        };\n        this.eventNameMap.set(name, event);\n        return {\n            configurable: true,\n            enumerable: true,\n            get() {\n                const event = this.#getEvent(name);\n                return this[event.name];\n            },\n            set(val) {\n                const event = this.#getEvent(name);\n                this[event.name] = val;\n            }\n        };\n    }\n\n    static getPropertyDescriptor(name, propImpl) {\n        // TODO: Do we need to store props/state in these proxy variables?\n        // Not necessarily, but we need the call to #updateProp to add widget logic (onWidgetUpdate, reflecting state)\n        const prop = {\n            name: `__${name}`,\n            attrName: toKebabCase(name),\n            impl: propImpl,\n            type: propImpl.constructor,\n            shouldReflect: propImpl instanceof Attr,\n        };\n        this.propNameMap.set(name, prop);\n\n        // Getters/Setters overwrite instance methods.\n        return {\n            configurable: true,\n            enumerable: true,\n            get() {\n                const prop = this.#getProp(name);\n                return this[prop.name];\n            },\n            set(newValue) {\n                // Update prop value and possibly reflect to attribute.\n                this.#updateProp(name, newValue);\n            }\n        };\n    }\n\n    static get observedAttributes() {\n        this.init();\n        const attrs = [];\n        for (const [propName, prop] of this.propNameMap) {\n            if (prop.type === Attr) {\n                attrs.push(prop.attrName);\n            }\n        }\n        return attrs;\n    }\n\n    // Public instance methods.\n    constructor() {\n        super();\n        this.#metadata = this.constructor.metadata;\n        if (this.constructor.useShadowDom) {\n            this.attachShadow({ mode: 'open' });\n            this.#root = this.shadowRoot;\n        } else {\n            this.#root = this;\n        }\n\n        // Setup null bindings.\n        if (this.constructor.bindingData) {\n            const {name, nullBindings} = this.constructor.bindingData;\n            this[name] = nullBindings;\n        }\n\n        // Create events bound to the widget.\n        for (const [eventName, event] of this.constructor.eventNameMap) {\n            this[eventName] = new event.type(eventName, this, event.props);\n        }\n\n        // Create state machine bound to the widget.\n        if (this.constructor.fsmData) {\n            const fsm = this.constructor.fsmData;\n            const machine = new fsm.type(fsm.machine, this.#onStateUpdate.bind(this));\n            this[fsm.name] = machine;\n        }\n\n        // Initiate request.\n        if (!this.#widgetRequest) {\n            // TODO: this needs to be bundle aware\n            //  - so we get the widget that is bundled by the calling widget\n            //  - this will get the wrong html/css for this js component\n            this.#widgetRequest = db.schema('widget').table('component').row('name', this.#metadata.widgetName)\n                .then(widget => {\n                    this.#metadata.widgetId = widget.get('id');\n                    const template = document.createElement('template');\n                    template.innerHTML = getInnerHtml(widget);\n                    return template;\n                });\n        }\n    }\n\n    connectedCallback() {\n        // Find widget parent. Useful for semantics and Widget.Events.\n        this.#metadata.parent = findParentWidget(this.#root);\n\n        this.#widgetRequest.then(template => {\n            // Put widget in the DOM.\n            this.#root.appendChild(template.content.cloneNode(true));\n\n            // Populate element bindings.\n            if (this.constructor.$) {\n                const { bindingData } = this.constructor;\n                const widgetBindings = {};\n                for (const binding of bindingData.bindings) {\n                    const element = this.#root.querySelector(binding.selector);\n                    if (!element) {\n                        throw new Error(`${logPrefix} Could not find widget binding during initialization. Direct bindings in Widget HTML should be static.`);\n                    }\n                    Object.defineProperty(widgetBindings, binding.name, this.#getBindingPropertyDescriptor(binding, element));\n                }\n                this[bindingData.name] = widgetBindings;\n            }\n\n            // Initialize props.\n            for (const [name, prop] of this.constructor.propNameMap) {\n                // Populate variable bindings.\n                const dataAttr = `data-${prop.attrName}`;\n                const elements = Array.from(this.#root.querySelectorAll(`[${dataAttr}]`));\n                const variableBindings = [];\n                for (const element of elements) {\n                    const variable = element.getAttribute(dataAttr);\n                    if (variable === "innerHTML") {\n                        throw new Error(`${logPrefix} innerHTML is not allowed in a variable binding`);\n                    }\n                    variableBindings.push({ element, variable });\n                }\n                this.#propVariableBindings.set(name, variableBindings);\n\n                // Set initial values.\n                if (prop.impl.hasInitialValue) {\n                    // Only set initial value if prop has not been set yet.\n                    if (typeof this[name] === 'undefined') {\n                        this[name] = prop.impl.initialValue;\n                    }\n                }\n\n                // variableBindings get populated after the initial call to #updateProp.\n                // Set them all here to complete the initalization process.\n                const propVariableBindings = this.#propVariableBindings.get(name);\n                if (propVariableBindings) {\n                    for (const binding of propVariableBindings) {\n                        if (typeof this[prop.name] !== 'undefined') {\n                            binding.element[binding.variable] = this[prop.name];\n                        }\n                    }\n                }\n            }\n\n            if (this.state) {\n                for (const context of Object.keys(this.state.context)) {\n                    const dataAttr = `data-context-${toKebabCase(context)}`;\n                    const elements = Array.from(this.#root.querySelectorAll(`[${dataAttr}]`));\n                    const variableBindings = elements.map(element => {\n                        const variable = element.getAttribute(dataAttr);\n                        if (variable === "innerHTML") {\n                            throw new Error(`${logPrefix} innerHTML is not allowed in a variable binding`);\n                        }\n                        return { element, variable };\n                    });\n                    this.#stateVariableBindings.set(context, variableBindings);\n                }\n            }\n\n            // Widget is connected (in DOM, bindings created, etc.).\n            this.#widgetConnected = true;\n\n            // Callback to let widget know it is connected.\n            if (this.onWidgetConnected) {\n                this.onWidgetConnected();\n            }\n\n            // We set all #widgetUpdate values before calling on onWidgetConnected,\n            // but the intention is that you do not do anything with props/attrs outside\n            // of onWidgetUpdate. This simplifies the concept of what work is done where.\n\n            // Callback to inform widget of prop updates.\n            if (this.onWidgetUpdate) {\n                // These include initial attribute values from upgrading the component,\n                // as well as props/attrs that we set before inserting the element into the DOM.\n                for (const update of this.#widgetUpdates) {\n                    this.onWidgetUpdate(...update);\n                }\n            }\n            this.#widgetUpdates = [];\n        });\n    }\n\n    disconnectedCallback() {\n        // TODO: Not sure this is necessary - these things are in the DOM and will be removed\n        // Remove bindings bound to the widget.\n        /*\n        if (this.$) {\n            for (const name of Object.keys(this.$)) {\n                console.log('removing binding', name)\n                if (this.$[name] instanceof Collection) {\n                    console.log('got collection');\n                    this.$[name].clear();\n                } else if (this.$[name] instanceof Deferred) {\n                    console.log('got deferred');\n                    this.$[name].delete();\n                }\n            }\n        }\n        */\n\n        // Remove this component's listeners;\n        for (const subscription of this.#subscriptions) {\n            if (subscription.length === 2) {\n                const [event, callbackBound] = subscription;\n                event.removeListener(callbackBound);\n            } else if (subscription.length === 3) {\n                const [target, event, callbackBound] = subscription;\n                target.removeEventListener(event, callbackBound);\n            }\n        }\n        this.#subscriptions = [];\n\n        // Remove events listeners bound from other widgets.\n        for (const eventName of Object.keys(this.constructor.eventNameMap)) {\n            this[eventName].removeListeners();\n        }\n\n        if (this.onWidgetDisconnected) {\n            this.onWidgetDisconnected();\n        }\n    }\n\n    attributeChangedCallback(attrName, _oldValue, newValue) {\n        // attributeChangedCallback is also called before connecting the component to initialize attributes.\n        if (attrName === this.#reflectingAttribute) {\n            return;\n        }\n\n        // Attributes are kebab-cased.\n        const propName = this.#getPropNameFromAttr(attrName);\n\n        // Update prop without reflecting to attribute. This also initializes attribute values.\n        this.#updateProp(propName, newValue, true);\n    }\n\n    subscribe(...args) {\n        console.warn('using old subscribe method');\n        this.addListener(...args);\n    }\n\n    unsubscribe(...args) {\n        console.warn('using old unsubscribe method');\n        this.removeListener(...args);\n    }\n\n    addListener(...args) {\n        if (args.length === 2) {\n            const [event, callback] = args;\n            if (!isEventInstance(event)) {\n                throw new Error(`${logPrefix} event must be and Event`)\n            }\n            if (typeof callback !== 'function') {\n                throw new Error(`${logPrefix} callback must be a function`)\n            }\n            const callbackBound = callback.bind(this);\n            event.addListener(callbackBound);\n            this.#subscriptions.push([event, callbackBound]);\n        } else if (args.length === 3) {\n            const [target, event, callback] = args;\n            if (typeof target === 'undefined') {\n                throw new Error(`${logPrefix} event target is undefined`)\n            }\n            if (typeof callback !== 'function') {\n                throw new Error(`${logPrefix} callback must be a function`)\n            }\n            const callbackBound = callback.bind(this);\n            target.addEventListener(event, callbackBound);\n            this.#subscriptions.push([target, event, callbackBound]);\n        }\n    }\n\n    removeListener(...args) {\n        const argIsTwo = args.length === 2;\n        const argIsThree = args.length === 3;\n        this.#subscriptions = this.#subscriptions.filter(subscription => {\n            if (subscription.length === 2 && argIsTwo) {\n                const [subEvent, subCallbackBound] = subscription;\n                if (args[0] === subEvent) {\n                    subEvent.removeListener(subCallbackBound);\n                    return false;\n                }\n            } else if (subscription.length === 3 && argIsThree) {\n                const [subTarget, subEvent, subCallbackBound] = subscription;\n                if (args[0] === subTarget && args[1] === subEvent) {\n                    subTarget.removeEventListener(subEvent, subCallbackBound);\n                    return false;\n                }\n            }\n            return true;\n        });\n    }\n\n    findWidget(definition) {\n        return this.#root.querySelector(definition.metadata.widgetName);\n    }\n\n    get widgetRoot() {\n        return this.#root;\n    }\n\n    get widgetMetadata() {\n        return this.#metadata;\n    }\n\n    #getEvent(name) {\n        return this.constructor.eventNameMap.get(name);\n    }\n    \n    #getProp(attr) {\n        return this.constructor.propNameMap.get(attr);\n    }\n\n    #getPropNameFromAttr(attrName) {\n        for (const [propName, prop] of this.constructor.propNameMap) {\n            if (prop.attrName === attrName) {\n                return propName;\n            }\n        }\n    }\n\n    #getBindingPropertyDescriptor(data, element) {\n        if (data.type === Deferred) {\n            const deferred = new Deferred(element);\n            return {\n                enumerable: true,\n                configurable: false,\n                get() {\n                    return deferred.get();\n                },\n                set(element) {\n                    deferred.set(element);\n                }\n            };\n        } else {\n            return {\n                enumerable: true,\n                configurable: false,\n                value: data.type === Collection ? new Collection(element) : element,\n            };\n        }\n    }\n\n    #onStateUpdate(contextUpdates, transitionData) {\n        const updates = Object.keys(contextUpdates);\n\n        for (const context of updates) {\n            for (const binding of this.#stateVariableBindings.get(context)) {\n                binding.element[binding.variable] = this.state.context[context];\n            }\n        }\n\n        // Change state attribute after template populated.\n        // CSS rules use this attribute value and jank needs to be minimized.\n        this.setAttribute('state', transitionData.current);\n\n        // TODO: Try to avoid using onWidgetStateChange to make the FSM api super smooth.\n        // onWidgetStateChange is a little bit of a hassle?\n        if (this.onWidgetStateChange) {\n            this.onWidgetStateChange(updates, transitionData);\n        }\n    }\n    \n    // Private instance methods.\n    #updateProp(publicName, newValue, prohibitReflect = false) {\n        // publicName is the attr or prop name that the user uses.\n        // privateName is the hidden prop that we proxy.\n        const prop = this.#getProp(publicName);\n        const privateName = prop.name\n\n        const oldValue = this[privateName];\n        this[privateName] = newValue;\n\n        // Attributes are always strings and usually short, so this should not be a performance hit.\n        if  (prop.type === Attr && oldValue === newValue) {\n            return;\n        }\n\n        const valueIsEmpty = typeof newValue === 'undefined'\n            || newValue === null\n            || newValue === false;\n\n        if (prop.shouldReflect) {\n            // Reflection can be overriden by passing prohibitReflect=true.\n            if (!prohibitReflect) {\n                this.#reflectingAttribute = prop.attrName;\n                if (valueIsEmpty) {\n                    this.removeAttribute(prop.attrName);\n                } else {\n                    this.setAttribute(prop.attrName, newValue);\n                }\n                this.#reflectingAttribute = null;\n            }\n        }\n\n        // #updateProp is called once before #widgetConnected.\n        // In this case, the variableBindings are not yet populated.\n        const propVariableBindings = this.#propVariableBindings.get(publicName);\n        if (propVariableBindings) {\n            for (const binding of propVariableBindings) {\n                binding.element[binding.variable] = newValue;\n            }\n        }\n\n        // Perform widget update or enqueue update for when widget connects.\n        if (this.onWidgetUpdate) {\n            if (this.#widgetConnected) {\n                try {\n                    this.onWidgetUpdate(publicName, oldValue, newValue)\n                } catch (e) {\n                    e.message = `[${this.constructor.widgetName}] onWidgetUpdate - ${e.message}`;\n                    throw e;\n                }\n            } else {\n                this.#widgetUpdates.push([publicName, oldValue, newValue]);\n            }\n        }\n    }\n}\n\nclass WidgetLightElement extends WidgetElement {\n    static useShadowDom = false;\n}\n\nexport { WidgetElement, WidgetLightElement };\n
\\x3f22d932ebd091f6c277773c390c3205930a32e83a1fd8ee4a3f2ee6bfe3ba96	cd1b183b-f5e1-40a9-a4be-01909a9b3d7f
\\x40315a6d0e19564e3d06eb4ad09762bb61308700432f5dac792c115a065017e6	// Note: Add `?events=false` to a url to stop all events\nconst query = new Set(location.search.slice(1).split('&'));\n\nexport class Socket {\n  constructor(handleEvent) {\n    this.handleEvent = handleEvent;\n    this.isAttached = false;\n    this.sessionId = null;\n    this.intendedSessionId = null;\n    this._socket = io('/');\n    this._socket.on('event', this.onMessage.bind(this));\n    this._socket.on('connect', () => {\n      if (!this.isAttached) {\n        if (this.sessionId) {\n          this.attach(this.sessionId);\n        } else if (this.intendedSessionId) {\n          this.attach(this.intendedSessionId);\n        }\n        // else { connectSession has not been called yet }\n      }\n    });\n    this._socket.on('disconnect', () => {\n      this.isAttached = false;\n      // socket.io will handle reconnecting\n    });\n    this.cache = {};\n  }\n  onMessage(event) {\n    let response;\n    try {\n      response = JSON.parse(event);\n    } catch (e) {\n      console.error('socket: error while parsing event', e);\n      return;\n    }\n\n    switch (response.type) {\n      case 'attached':\n        this.isAttached = true;\n        this.sessionId = response.sessionId;\n        this.intendedSessionId = null;\n        console.log('socket attached', response.sessionId);\n        break;\n\n      case 'event':\n        this.handleEvent(response.data);\n        break;\n    }\n  }\n  attach(sessionId) {\n    if (!this.sessionId) {\n      this.intendedSessionId = sessionId;\n    }\n    if (this._socket.connected) {\n      if (!sessionId) {\n        console.error('socket error: invalid session id', sessionId);\n      }\n      this._socket.emit('attach', sessionId);\n    }\n    // else { socket will attempt to attach when connected }\n  }\n}
\\x41bd1d65dc641c2bb9e0c3d1a86779fbf829613164911aeb8a2413edf8867cdf	import { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\nimport './material-icon.js';\n\nexport default define(\n    import.meta,\n    class DynamicTab extends Widget.Element {\n        static $ = {\n            container: '#container',\n            close: '#close',\n        };\n        static tabName = Widget.Prop;\n        static isActive = Widget.Attr.initial(false);\n        static open = Widget.Event.detail(this.tabName);\n        static close = Widget.Event.detail(this.tabName);\n\n        onWidgetConnected() {\n            this.addListener(this.$.container, 'click', this.open.dispatch);\n            this.addListener(this.$.close, 'click', this.onCloseClicked);\n        }\n\n        onCloseClicked(e) {\n            e.stopPropagation();\n            this.close.dispatch();\n        }\n    }\n);
\\x42f447e8d85e4e80e0b16fdbf2fafa2a238552c92359d333ccf68695f17b66eb	\n<!doctype html>\n<html>\n    <head>\n        <title>widget stuff</title>\n        <base href="/com.mickey.ui/" />\n        <style>\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body>\n        <jazzy-form></jazzy-form>\n    </body>\n    <script type="module" src="widget.component/jazzy-form.js"></script>\n</html>\n
\\x44136fa355b3678a1146ad16f7e8649e94fb4fc21fe77e8310c060f61caaff8a	{}
\\x47742101f57ce5a74d2290e77e562481ca9f2de5f3872e80ea15e27870e64406	\nimport { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\nimport db from '/org.aquameta.core.widget/0.3.1/widget.module/datum.js';\n\nexport default define(\n    import.meta,\n    class SemanticWidget extends Widget.LightElement {\n        static purpose = Widget.Attr;\n        static bundle = Widget.Attr;\n        static rowId = Widget.Prop;\n        static row = Widget.Prop;\n        static fieldId = Widget.Prop;\n        static field = Widget.Prop;\n        static bundles = Widget.Prop;\n\n        onWidgetConnected() {\n            // TODO: Best case would be to have these widgets stored on the row object\n            //  but then datum would need to subscribe to semantics so we don't use old mappings\n\n            // TODO: Another option would be to load all semantics ahead of time for quicklookups\n            //  then with events, the cache can be busted when semantics change\n            const bundles = [];\n            if (this.bundle) {\n                bundles.push(this.bundle);          }\n            const parent = this.widgetMetadata.parent;\n            if (parent) {\n                bundles.push(parent.widgetMetadata.bundleName);\n            }\n            this.bundles = bundles;\n        }\n\n        onWidgetUpdate(prop, _oldValue, newValue) {\n            switch (prop) {\n                case 'rowId': {\n                    const relationId = newValue.pk_column_id.relation_id;\n                    Promise.all([\n                        db.rowIdToRow(newValue),\n                        this.getRelationWidget(relationId, this.purpose),\n                    ])\n                        .then(([row, widget]) => {\n                            this._row = row;\n                            this.createWidget(widget);\n                        });\n                    break;\n                }\n                case 'row': {\n                    this._row = newValue;\n                    const relationId = newValue.relation.id;\n                    this.getRelationWidget(relationId, this.purpose)\n                        .then(widget => {\n                            this.createWidget(widget);\n                        });\n                    break;\n                }\n                case 'fieldId': {\n                    const columnId = newValue.column_id;\n                    Promise.all([\n                        db.rowIdToRow(newValue.id.row_id),\n                        this.getColumnWidget(columnId, this.purpose),\n                    ])\n                        .then(([row, widget]) => {\n                            // TODO: This should be row.field(columnId.name) - so we can use field metadata\n                            this._field = row.get(columnId.name);\n                            this.createWidget(widget);\n                        });\n                    break;\n                }\n                case 'field': {\n                    this._field = newValue;\n                    const columnId = newValu.column.id;\n                    this.getColumnWidget(columnId, this.purpose)\n                        .then(widget => {\n                            this.createWidget(widget);\n                        });\n                    break;\n                }\n            }\n        }\n\n        async getRelationWidget(relationId, purpose) {\n            let widget = null;\n            if (this.bundles.length) {\n                // TODO: semantic.relation_widget should return bundleName and widgetName so browser can import them\n                // TODO: it should also 404 when the widget does not exist, we can create fallback on client side\n                try {\n                    const rowWidget = await db.schema('semantics').function({\n                        name: 'row_component',\n                        parameters: ['meta.relation_id', 'text', 'pg_catalog._text'],\n                    },\n                        {\n                            relation_id: relationId,\n                            purpose: purpose,\n                            bundles: `{${this.bundles.join(',')}}`,\n                            // bundles, // ?\n                            // bundles: JSON.stringify(bundles), // ?\n                        },\n                        {\n                            use_cache: true,\n                            meta_data: false\n                        });\n                    if (rowWidget) {\n                        widget = rowWidget.get('row_component');\n                    }\n                } catch (e) {\n                    console.error(e);\n                }\n            }\n            if (!widget) {\n                // TODO: core component library bundle\n                widget = {\n                    bundleName: 'com.mickey.ui',\n                    name: `core-row-${purpose}`,\n                };\n            }\n            this.bundle = widget.bundleName;\n            await import(`/${widget.bundleName}/widget.component/${widget.name}.js`)\n            return widget;\n        }\n\n        async getColumnWidget(columnId, purpose) {\n            let widget = null;\n            if (this.bundles.length) {\n                try {\n                    const fieldWidget = await db.schema('semantics').function({\n                        name: 'field_widget',\n                        parameters: ['meta.column_id', 'text', 'pg_catalog._text'],\n                    },\n                        {\n                            column_id: columnId,\n                            purpose: purpose,\n                            bundles: this.bundles,\n                        },\n                        {\n                            use_cache: true,\n                            meta_data: false\n                        });\n                    if (fieldWidget) {\n                        widget = fieldWidget.get('field_widget');\n                    }\n                } catch (e) {\n                    console.error(e);\n                }\n            }\n            if (!widget) {\n                widget = {\n                    bundleName: 'com.mickey.ui',\n                    name: `core-field-${purpose}`,\n                };\n            }\n            this.bundle = widget.bundleName;\n            await import(`/${widget.bundleName}/widget.component/${widget.name}.js`)\n            return widget;\n        }\n        \n        createWidget(widget) {\n            const element = document.createElement(widget.name);\n            this.appendChild(element);\n            if (this._row) {\n                element.row = this._row;\n            } else if (this._field) {\n                element.field = this._field;\n            }\n        }\n    }\n);\n
\\x47dd56c2c7a7f7aac789ff6a0190ecc9f7508548c7e4f5118bef1622b478fbeb	socket
\\x48df75a94a5847ac2dfca7275d58d447cd9a77d10caa85097524a6c6a8be29f3	1f1aefb2-285f-41b5-97a3-3d7d6f61962e
\\x4938388f0c68650a2120ab03dfbf8e39b08edca0d086b3c3fd02e84e501a5fab	var w = $("#"+id);
\\x4c2c60f9e5c2ef5ce0404bddd4d7d24881d2ce1a0a3a27371973f9922453abd1	<table>\n    <tr>\n        <td>Column</td>\n        <td>Field</td>\n    </tr>\n</table>
\\x4c6a7767fc5d8085ceb9970d68927892ac0b6f0bb8e869c8faa6065f16fe42fa	b3cae204-badb-40a5-99d4-df40ea7932d2
\\x4fd17c420516c1ccf188e3b4f5950940f11b2cd3e89fe429d5236bc755a88fb1	meta-relation
\\x5039cad4e8875f8d05a1d66cc737cea637ea6bb725c434e51af60d647e720415	import { LitElement, html, css } from 'https://unpkg.com/lit@2.6.1/index.js?module';\nimport { provideFASTDesignSystem, fastCheckbox, fastTabs } from 'https://jspm.dev/@microsoft/fast-components@2';\n\nimport {monaco, monacoVim} from '/org.aquameta.ui.editor/0.35.0/widget.module/monaco-editor.js'\nimport { register, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\n\nimport db from '/org.aquameta.core.widget/0.3.1/widget.module/datum.js';\n\nprovideFASTDesignSystem()\n    .register(\n        fastCheckbox(),\n        fastTabs(),\n    );\n\n// bugs\n// - first tab to open won't be full height\n\n// todo\n// - turn these into docs\n// - rewrite editor in Widget\n// - editor look and feel\n//      - update vim status line to be visually better\n//      - button/shortcut to enter fullscreen mode (should be on parent component, not core-code)\n//\t\t- clear out editor-status-line when the row changes\n//      - build monaco with json support? not sure if it has this, but .js.map should work\n//      - build monaco with source maps\n//      - allow prohibiting reloads with a setting\n// - editor widget integration\n//      - add endpoint.create_html_resource(bundle_name text) to make a better field default\n//      - update widget to have json column for mock input data\n//      - live view of widget with a binding for "run"\n//          - mock data as a json column {attributes, properties, children, parent?}\n//          - can import with a query param to bust cache? custom-comp-13 -> import(`...?13`)\n//      - ast\n//          - parse ast to have view of bundle dependencies\n//          - auto-import widget. can have drop down/autcomplete thing with widgets from the same bundle at top\n//          - parse imports and show a list of widgets you depend on. click on one to show the help column for that widget\n//          - command to switch html/css/js import toggle between relative and absolute with bundle name\n//          - snippet plugin for monaco\n//              - snippet for adding meta-rows\n//              - snippet to add endpoint call\n//      - mobile/touch friendly view of html/css\n//      - all widgets can be hot-reloaded\n//          - give endpoint.resource a new column called debugger-enabled (or a one-to-one ui.debugger_enabled(resource_id))\n//              - not sure how that would work, all of widget is pull, we don't inject anything into resources currently\n//              - user would have to include debugger in addition to setting the debugger to be enabled\n//          - only resources with debugger_enabled will subscribe to the widget table\n// - widget\n//      - widget.widget(help) is not backed-up?\n//      - why, in other frameworks, do you need a key for list elements to help reorder?\n//          - we could do this automatically for meta-rows since every row has an id, but why is it strictly necessary?\n// - datum\n//      - fix for flat_types\n//      - add bundle metadata to row\n// - content delivery\n//      X dependencies add cache control header - extend resource_function\n//          - blocked on creating bundle releases\n//      X use bundle name in imports\n//          X removes unique index on widget name, etc.\n//          - could statically analyze these to make sure you're defining bundle dependencies\n//              - would have to enable endpoint.resource_function lookup from browser via function\n//              - this argues that endpoint.resource_function_lookup should be a function that the client or server can call\n//          X could we add a base tag for relatively importing from same bundle? what would happen to reused components?\n//              - then if you want to expose a component to consumers of your bundle, you'll need to make urls fully-qualified\n//              - but locally these can be easier to write\n//              - and could statically add the bundle name to urls when you go to ship\n// - semantics\n//      - dynamically import semantics functions\n//          - are these queries specific to a bundle? you want to be able to define and override these\n//          - import {rowLabel, listLabel} from '/org.aquameta.core.endpoint/endpoint.resource/semantics.js';\n//          - import('/${bundle}/${schema}.${relation}/semantics.js').then(semantics => {});\n//          - either way, want to expose the semantics function to the client, not just a component\n//      X semantics tags\n//          X <ul is="meta-rows"> <li is="meta-row"> <span is="meta-semantics" purpose="unique-in-table"/> </li> </ul>\n//      X better semantic purposes\n//          X not how it's being display, that is really the ui's job\n//          X but what the call to semantics is for, i.e. the purpose, e.g.:\n//              - a unique identifier for a row within this table (id or name or  name+version) unique-in-table, or table-wide, or just table\n//              - a unique identifier for this row within the bundle (same as above but including the table name) unique-in-bundle, bundle-wide, bundle\n//              - a unique identifier for this row within the database (same as above but including the bundle name) unique-in-database, database-wide, database\n// - better widget names\n//      X meta for database-related things - get-rows, call-function, etc. - org.aquameta.core.meta or maybe still core.ide\n//      X core for core ide - code editor, bundle editor, etc. - org.aquameta.core.ide\n//      - aqua for generic component library stuff - static-tab-layout, tab-layout, refresh-list, etc. - org.aquameta.ui.aqua\n// - component abstractions/other uses\n//      X if only one columns supplied, do not display editor in a tab\n//      - generalize editor for other uses - read-only mode for diffs, show whatever *text* columns are passed in\n//      - core-code fires the save event so parent component can add name field\n// - intellisense\n//      - in js, in datum, auto-complete schema/relation/fields/function names and params\n//      - in html (if we have), could select tag names from name column\n//      - add typescript file (?) for datum for autocomplete\n//      - can ts-lit-plugin be added to monaco?\n// - replacing current editor\n//      X potentially integrate with bundle so you can switch to bundle contents\n//      - run demo component on other side of screen\n//          - tag value is name of component\n//          - attributes/properties/events are all documented\n//          - column for demo values\n//          - might need to export default? or can look through exports to find a class that extends HTMLElement\n//          - have loader that imports component and demo values then customElements.define to tag value + a counter ('<mickey-app-xxx')\n//          - auto-reload\n//      X basic web component that pulls in html and css\n//          X would probably need helpers to deal with attributes/properties\n//          X then html field is a <template>...</template> to put in the shadow dom (or it has that new declarative attribute)\n//          - would be great to allow SSR without server-side js, but might need declarative shadow root for that?\n//              - or at least do SSR by including all necessary HTML/CSS/JS in first page load, reduce round trips\n\nregister(\n    class MetaCode extends Widget.Element(import.meta, LitElement) {\n        static properties = {\n            activeTab: {},\n            columns: {},\n            dataRow: { state: true },\n            editors: {},\n            hasUnsavedChanges: { state: true },\n            lastSaved: { state: true },\n            observer: { state: true },\n            request: {},\n            row: {},\n            status: { state: true },\n            useVim: {state: true},\n            vimMode: {},\n        };\n        static styles = css`\n            :host {\n                color: black;\n                display: flex;\n                flex-direction: column;\n                height: 100%;\n                min-height: 800px;\n                width: 100%;\n            }\n            @media (prefers-color-scheme: dark) {\n                :host {\n                    background-color: #3d3d3d;\n                }\n            }\n            .code-container {\n                height: 100%;\n                width: 100%;\n            }\n            fast-tabs {\n                flex-grow: 1;\n            }\n            #solo-editor {\n                display: grid;\n                flex: 1;\n            }\n            .label {\n                color: black;\n                margin: 5px;\n                text-transform: uppercase;\n            }\n            #editor-status-bar {\n                display: flex;\n                justify-content: space-between;\n                padding: 4px;\n            }\n            .saved {\n                background-color: green;\n                border-radius: 5px;\n                color: white;\n                padding: 5px;\n            }\n            .failed {\n                background-color: red;\n                border-radius: 5px;\n                color: white;\n                padding: 5px;\n            }\n            .unsaved {\n                color: gold;\n            }\n            @media (prefers-color-scheme: dark) {\n                :host {\n                    color: white;\n                }\n                #vim-status-bar {\n                    color: white;\n                }\n                .label {\n                    color: white;\n                }\n            }\n            #vim-status-bar {\n                padding: 5px;\n            }\n            .monaco-editor {\n                height: 100%!important;\n            }\n        `;\n        constructor() {\n            super();\n            this.columns = this.columns || [];\n            this.editors = {};\n            this.hasUnsavedChanges = false;\n            this.lastSaved = null;\n            this.status = '';\n            this.useVim = true;\n            window.matchMedia('(prefers-color-scheme: dark)').addListener(() => {\n                this.destroyEditors();\n                this.updateEditor();\n            });\n        }\n        connectedCallback() {\n            super.connectedCallback();\n            this.getDataRow();\n\n            this.onBeforeUnloadBound = this.onBeforeUnload.bind(this);\n            this.onModelChangeBound = debounce(this.onModelChange.bind(this), 200);\n            this.onVisibilityChangeBound = this.onVisibilityChange.bind(this);\n\n            this.observer = new IntersectionObserver(this.onVisibilityChangeBound);\n            this.observer.observe(this.renderRoot.host);\n        }\n        disconnectedCallback() {\n            window.removeEventListener('beforeunload', this.onBeforeUnloadBound);\n\n            this.observer.unobserve(this.renderRoot.host);\n\n            this.onVisibilityChangeBound = null;\n            this.onBeforeUnloadBound = null;\n            this.onModelChangeBound = null;\n\n            if (this.hasUnsavedChanges) {\n                const answer = confirm('This row has unsaved changes. Would you like to save before closing?\\n\\nSelect cancel to discard changes.');\n                if (answer) {\n                    // TODO: unfortunately, nowhere to put the error message if this fails\n                    this.saveRow();\n                }\n            }\n        }\n        onVisibilityChange(entries) {\n            for (const entry of entries) {\n                if (entry.target === this.renderRoot.host) {\n                    if (entry.isIntersecting) {\n                        this.updateEditor();\n                    } else {\n                        this.#disableVim();\n                    }\n                }\n            }\n        }\n        onBeforeUnload(e) {\n            if (this.hasUnsavedChanges) {\n                e.preventDefault();\n            }\n        }\n        onModelChange() {\n            for (const [col, editor] of Object.entries(this.editors)) {\n                if (editor.getValue() !== this.dataRow.get(col)) {\n                    this.hasUnsavedChanges = true;\n                    return;\n                }\n            }\n            this.hasUnsavedChanges = false;\n        }\n        async getDataRow() {\n            if (this.request) {\n                this.dataRow = await this.request;\n            } else if (this.row) {\n                this.dataRow = this.row;\n            }\n            if (this.dataRow) {\n                this.getColumns();\n            }\n        }\n        getColumns() {\n            // create tabs and panels dynamically\n            if (!this.columns.length) {\n                this.columns = overrideColumns(this.dataRow.relation, this.dataRow.columns.map(c => c.name));\n            }\n            if (!this.activeTab) {\n                this.activeTab = this.columns[0];\n            }\n        }\n        updateEditor() {\n            if (!(this.activeTab in this.editors)) {\n                const lang = negotiateFileType(this.dataRow, this.activeTab);\n                this.editors[this.activeTab] = createEditor(\n                    this.renderRoot.querySelector(`#${this.activeTab}-code`),\n                    (this.dataRow.get(this.activeTab) ?? '').toString(),\n                    lang,\n                    {\n                        saveRow: this.saveRow.bind(this),\n                        nextTab: this.updateTab.bind(this, null, 'next'),\n                        previousTab: this.updateTab.bind(this, null, 'previous'),\n                    },\n                );\n                this.editors[this.activeTab].onDidChangeModelContent(this.onModelChangeBound);\n            }\n            if (this.useVim) {\n                this.#enableVim();\n            }\n            this.editors[this.activeTab].focus();\n        }\n        #toggleVim() {\n            this.useVim = !this.useVim;\n            if (this.useVim) {\n                this.#enableVim();\n            } else {\n                this.#disableVim();\n            }\n            this.editors[this.activeTab].focus();\n        }\n        #enableVim() {\n            if (this.vimMode) {\n                this.vimMode.dispose();\n            }\n            this.vimMode = monacoVim.initVimMode(\n                this.editors[this.activeTab],\n                this.renderRoot.querySelector('#vim-status-bar'),\n            );\n            monacoVim.VimMode.Vim.defineEx('write', 'w', () =>\n                this.saveRow());\n            monacoVim.VimMode.Vim.defineEx('NextTab', 'NextTab', () =>\n                this.updateTab(null, 'next'));\n            monacoVim.VimMode.Vim.defineEx('PreviousTab', 'PreviousTab', () =>\n                this.updateTab(null, 'previous'));\n            monacoVim.VimMode.Vim.map('gt', ':NextTab<Enter>', 'normal');\n            monacoVim.VimMode.Vim.map('gT', ':PreviousTab<Enter>', 'normal');\n        }\n        #disableVim() {\n            if (this.vimMode) {\n                this.vimMode.dispose();\n            }\n            this.vimMode = null;\n        }\n        destroyEditors() {\n            for (const key in this.editors) {\n                this.editors[key].dispose();\n            }\n            this.editors = {};\n            if (this.vimMode) {\n                this.vimMode.dispose();\n            }\n        }\n        async saveRow() {\n            for (const [col, editor] of Object.entries(this.editors)) {\n                this.dataRow.set(col, editor.getValue());\n            }\n            try {\n                const done = await this.dataRow.update();\n                this.status = 'saved';\n                this.lastSaved = new Date().toLocaleString();\n                this.hasUnsavedChanges = false;\n            } catch (e) {\n                this.status = 'failed';\n                console.error(e);\n            }\n        }\n        updateTab(id, dir = null) {\n            if (id !== null) {\n                this.activeTab = id;\n            } else {\n                const index = this.columns.indexOf(this.activeTab);\n                if (dir === 'next') {\n                    this.activeTab = this.columns[Math.min(index + 1, this.columns.length - 1)];\n                } else {\n                    this.activeTab = this.columns[Math.max(index - 1, 0)];\n                }\n            }\n        }\n        onTabChange(event) {\n            if (event.detail) {\n                // if there are unsaved changes in the editor, we will get 2 onTabChange events\n                // the first event will have no event.detail\n                this.updateTab(event.detail.id);\n            }\n        }\n        update(changedProperties) {\n            super.update();\n            if (changedProperties.has('activeTab') || changedProperties.has('dataRow')) {\n                this.updateEditor();\n            } else if (changedProperties.has('request') || changedProperties.has('row')) {\n                this.destroyEditors();\n                this.getDataRow();\n            }\n            if (changedProperties.has('hasUnsavedChanges')) {\n                if (this.hasUnsavedChanges) {\n                    window.addEventListener('beforeunload', this.onBeforeUnloadBound);\n                } else {\n                    window.removeEventListener('beforeunload', this.onBeforeUnloadBound);\n                }\n            }\n        }\n        render() {\n            return html`\n                <style>\n                    @import url("/org.aquameta.ui.editor/0.35.0/widget.module/monaco-editor.css");\n                </style>\n                <div id="editor-status-bar">\n                    <fast-checkbox @change=${this.#toggleVim} checked=${this.useVim}>\n                        vim\n                    </fast-checkbox>\n                    <div>\n                        <span>${this.lastSaved}</span>\n                        ${this.hasUnsavedChanges\n                            ? html`<span class="unsaved">*<span>`\n                            : html`<span class=${this.status}>${this.status}</span>`}\n                    </div>\n                </div>\n                ${this.columns.length\n                    ? this.columns.length > 1\n                        ? html`<fast-tabs @change=${this.onTabChange} activeid=${this.activeTab}>\n                                ${this.columns.map(col => html`\n                                    <fast-tab id=${col} slot="tab">\n                                        <span class="label">${col}</span>\n                                    </fast-tab>\n                                    <fast-tab-panel slot="tabpanel">\n                                        <div id="${col}-code" class="code-container"></div>\n                                    </fast-tab-panel>\n                                `)}\n                            </fast-tabs>`\n                        : html`<div id="solo-editor">\n                                <div id="${this.columns[0]}-code" class="code-container"></div>\n                            </div>`\n                    : 'none'\n                }\n                <div>\n                    <div id="vim-status-bar"></div>\n                </div>\n            `;\n        };\n    }\n);\n\nfunction createEditor(element, value = '', language = 'text', callbacks) {\n    if (!element) {\n        console.error('could not find element when creating editor');\n        return;\n    }\n\n    const editor = monaco.editor.create(element, {\n        value,\n        language,\n        scrollBeyondLastLine: false,\n        theme: window.matchMedia('(prefers-color-scheme: dark)').matches\n            ? "vs-dark"\n            : "vs",\n    });\n\n    editor.addAction({\n        // An unique identifier of the contributed action.\n        id: "save-widget-action-id",\n        // A label of the action that will be presented to the user.\n        label: "Save the damn widget!",\n        // An optional array of keybindings for the action.\n        keybindings: [\n            monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS,\n            // chord\n            monaco.KeyMod.chord(\n                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyK,\n                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS,\n            ),\n        ],\n        precondition: null,\n        keybindingContext: null,\n        contextMenuGroupId: "navigation",\n        contextMenuOrder: 1.5,\n        run: callbacks.saveRow,\n    });\n\n\n    editor.addAction({\n        id: "next-tab-action-id",\n        label: "Next Tab",\n        keybindings: [\n            monaco.KeyMod.chord(\n                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyK,\n                monaco.KeyCode.RightArrow,\n            ),\n        ],\n        precondition: null,\n        keybindingContext: null,\n        contextMenuGroupId: "navigation",\n        contextMenuOrder: 1.5,\n        run: callbacks.nextTab,\n    });\n\n    editor.addAction({\n        id: "previous-tab-action-id",\n        label: "Previous Tab",\n        keybindings: [\n            monaco.KeyMod.chord(\n                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyK,\n                monaco.KeyCode.LeftArrow,\n            ),\n        ],\n        precondition: null,\n        keybindingContext: null,\n        contextMenuGroupId: "navigation",\n        contextMenuOrder: 1.5,\n        run: callbacks.previousTab,\n    });\n\n    return editor;\n}\n\nfunction negotiateFileType(row, column) {\n    const relation = `${row.schema.name}.${row.relation.name}`;\n    if (column === 'content' && relation === 'endpoint.resource') {\n        const resourcePath = row.get('path');\n        if (resourcePath && resourcePath.includes('.')) {\n            if (resourcePath.endsWith('.js.map')) {\n                return 'json';\n            }\n            if (resourcePath.endsWith('.sql')) {\n                return 'pgsql';\n            }\n        }\n        const mimetype = getMimetype(row, column);\n        switch (mimetype) {\n            case null:\n                break;\n            case 'text/html':\n                return 'html';\n            case 'text/css':\n                return 'css';\n            case 'application/javascript':\n            case 'text/javascript':\n                return 'javascript';\n            case 'text/plain':\n            case 'text/richtext':\n                return 'text';\n        }\n    } else if (column === 'content' && relation === 'documentation.bundle_doc') {\n        return 'markdown';\n    } else if (column === 'content' && relation === 'widget.dependency_js') {\n        return 'javascript';\n    } else if (column === 'content' && relation === 'widget.dependency_css') {\n        return 'css';\n    } else if (column === 'content' && relation === 'widget.module') {\n        const rowType = row.get('type');\n        if (rowType === 'js') {\n            return 'javascript';\n        }\n        return rowType;\n    }\n    switch (column) {\n        case 'html':\n        case 'css':\n            return column;\n        case 'post_js':\n        case 'js':\n            return 'javascript';\n        case 'sql':\n        case 'pgsql':\n            return 'pgsql';\n        case 'md':\n        case 'markdown':\n            return 'markdown';\n        case 'text':\n            return 'text';\n        case 'help':\n            return 'markdown';\n    }\n    return 'text';\n}\n\n// TODO: load mimetypes in more robust way\nlet mimetypes = [];\ndb.schema('endpoint').table('mimetype').rows().then(rows => mimetypes = rows.map(i => i));\nfunction getMimetype(row, column) {\n    const mimetypeId = row.get('mimetype_id');\n    if (mimetypeId) {\n        const mimetypeRow = mimetypes.find(m => m.get('id') === mimetypeId);\n        if (mimetypeRow) {\n            return mimetypeRow.get('mimetype');\n        }\n    }\n    return null;\n}\n\nfunction debounce(fn, t) {\n    let timerId = null;\n    return () => {\n        if (timerId !== null) {\n           clearInterval(timerId);\n        }\n        timerId = setTimeout(fn, t);\n    };\n}\n\n// TODO: Remove this by dropping extra widget columns\nfunction overrideColumns(rel, cols) {\n    const relName = `${rel.schema.name}.${rel.name}`;\n    switch (relName) {\n        case 'widget.widget':\n            return ['html', 'css', 'post_js', 'help'];\n        case 'endpoint.resource':\n            return ['path', 'content'];\n        case 'widget.dependency_js':\n        case 'widget.dependency_css':\n            return ['version', 'content'];\n        case 'widget.component':\n            return ['html', 'css', 'js', 'help'];\n        case 'widget.module':\n            return ['content'];\n        case 'documentation.bundle_doc':\n            return ['title', 'content'];\n    }\n    return cols;\n}
\\x5097bbf120203044ce21c8c0bcdaed65d4e95f5cd2621a576968023898e18991	bbef90a3-c332-42a6-8e1c-9fd2acd7fae4
\\x537095f31a9bfdbf6ba2d59167b7f25aab8101b317fa085a0c6d2b7902ef61df	import { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\n\nexport default define(\n    import.meta,\n    class StaticTabContent extends Widget.Element {\n        static tabId = Widget.Attr;\n        static isActive = Widget.Attr.initial(false);\n    }\n);
\\x54ec6defd2d10c0780df09d485f8f087d31b7dad856d0a36e2fb780981b6b21c	d4689207-4549-4fdb-bd5f-eb931dd1b183
\\x5510612f04b7c038d0e63849a383b0c968b0b27d2dcbaaf92b70b7e5d4c4053f	static-event-tabs
\\x55d63158223097dc9da41ed4655d13bebb1efffc47fb269c8deaa64ce064aa4b	static-tabs
\\x5614391dee25a88fc447278570f6502b5aacd63035d5d2e7a2a2936557acbcab	dfe57840-41ac-4ae5-8078-06a9e3482eac
\\x57b7ae727bd7eee2f11972c06951ab9d1e631943f73f35005eb4e30dade434b3	:host {\n    display: inline-block;\n    padding: 5px;\n    margin-right: 5px;\n}\n\n:host([is-active]) {\n    background-color: gray;\n}\n\n#container {\n    display: inline-block;\n    cursor: pointer;\n}\n\n#name,\nmaterial-icon::part(icon) {\n    font-size: 16px;\n    vertical-align: middle;\n}\n\n/*\n#close {\n    display: inline-block;\n    border: 1px solid gray;\n    border-radius: 100%;\n    height: 18px;\n    font-size: 14px;\n    padding: 1px;\n    text-align: center;\n    vertical-align: middle;\n    width: 18px;\n}\n*/\n\n#close:hover {\n    color: black;\n}
\\x57f5e094443cb6e5232713547478b374937275b24f5b94a9f639284e9d46ddf0	jazzy-form
\\x58844e01f8b9bd0a6b06e354dc2776d595cc4736f7e57ff1ee7a665849ca45a0	import { register, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\n\nexport default register(\n    class CoreFieldEdit extends Widget.Element(import.meta) {\n        static row = Widget.Prop;\n    }\n);
\\x588da0ec9475642b88f9c7f108e09fee427e8cc0fa243dbb8754e78f200664f8	8bc29965-1ab2-45ab-bdd6-ad2f36a2659d
\\x5998d71f098364f1f84af6a5bccd1368535545b9f2d58b403656027cc573d55e	core-field-edit
\\x5adf965e0b1cab9851bd63ffd254d4094567e2f233650cdf66bf2b708ebee469	{html}
\\x5b5e94ea4e61662c5603cb06161216aad01945a16461086d27557a25518c9407	/semantics/${1}\\.${2}/identifier.js
\\x5b71d4c9c794489724965d1e17aea7a275e7335e23a777dba869a84b4bd348c3	ceca44b3-1b84-4b15-b3d0-9a2290f78738
\\x5d95d9b541dcc2150f4e8dea99738465863277dbe164e674be6a71e2f378e71a	:host {\n  display: block;\n}\n\n:host(:not([is-active])) {\n  display: none;\n}
\\x5eeb60accfd1a234b90566058b9293f221ff2902c2eb5a385626c61e210403fd	c978bda1-18e1-4dd5-9d99-c6b6ba43f858
\\x6178c198fe6a2da4210b38ab0d680d1f97f7125b592591fac229f814ffa5f115	<div id="container">\n    <ul class="state-success">\n        <meta-rows data-context-data="rows">\n            <meta-row>\n                <li>\n                    <meta-field column="row_id">\n                        <semantic-identifier meta-field="rowId" pattern="{relation}: {id}"></semantic-identifier>\n                    </meta-field>\n                </li>\n            </meta-row>\n        </meta-rows>\n    </ul>\n    <div id="state-requesting">\n        loading\n    </div>\n    <div id="state-failed">\n        <p data-context-error="innerText"></p>\n        Error loading bundle contents\n    </div>\n</div>
\\x61cd79d0b8c4ec03ba3c3ed46a942040626a1991483b28ad1de1e1a7a9cd2c3f	e308c3df-5174-4114-8fa0-99c4acbc66ce
\\x61dc015a4727286587b2bf8445580ce913e39bab886fb6100084fe1b694dda94	024eec64-2370-484b-abeb-d173c7f62909
\\x62c551570a643c33afe2703c6b55b38364f5a5d7eab548008962b2b857db4695	372c9f7d-213b-404f-a3db-b373d4df137f
\\x634768dae1474506e4bf7d341890542b09987d7e6aea5d446c02e37581a56954	row
\\x6514c87590aaa900df8110407b0c3486c0958411c684d329a1fada3c9210a494	import { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\n\nexport default define(\n    import.meta,\n    class CoreRowEdit extends Widget.Element {\n        static $ = {\n            span: 'span',\n        };\n        static row = Widget.Prop;\n\n        onWidgetUpdate(prop) {\n            if (prop === 'row') {\n                this.$.span.innerText = JSON.stringify(this.row.row_data);\n            }\n        }\n    }\n);
\\x653b4faefe561bcba665d0526183ace08ba73b3b90a6b872b5c5f48e6b230383	4826c0c8-7ad7-40d0-99ae-414117961029
\\x673a549bfe2504e89e624d9e00577b2b0c92da0a5282ba94209ec4c691ad3bf2	16bc42d2-c294-4595-9667-d417d072aa41
\\x68ecc767c997d370d4f04c8cffdd6dc8925a2dc37452e06c4f9109582b806207	:host {\n    display: block;\n    height: 100%;\n}\n\n:host(:not([is-active])) {\n    display: none;\n}\n\nsemantic-widget {\n    height: 100%;\n}\n
\\x6a4d2a82ddc7244a742df6c8dca26003d2beb0a1bf4626196e0147f1a0489df1	export default function(row) {\n    return row.get('path_pattern');\n}
\\x6b4eea124b488c311b6397e015dd27d982125b1d3d634347967208ca720649b8	export class Collection {\n    #container;\n    #map = new Map();\n\n    constructor(container) {\n        this.#container = container;\n    }\n\n    get size() {\n        return this.#map.size;\n    }\n\n    get container() {\n        return this.#container;\n    }\n\n    has(key) {\n        return this.#map.has(key);\n    }\n\n    get(key) {\n        return this.#map.get(key);\n    }\n\n    set(key, element) {\n        if (this.#map.has(key)) {\n            this.delete(key);\n        }\n        this.#map.set(key, element);\n        this.#container.appendChild(element);\n        return this;\n    }\n\n    delete(key) {\n        if (!this.#map.has(key)) {\n            return false;\n        }\n        const element = this.#map.get(key);\n        element.remove();\n        return this.#map.delete(key);\n    }\n\n    clear() {\n        const keys = this.keys();\n        for (const key of keys) {\n            this.delete(key);\n        }\n        this.#container.innerHTML = '';\n    }\n\n    keys() {\n        return this.#map.keys();\n    }\n\n    values() {\n        return this.#map.values();\n    }\n\n    entries() {\n        return this.#map.entries();\n    }\n\n    forEach(...args) {\n        this.#map.forEach(...args);\n    }\n\n    *[Symbol.iterator]() {\n        for (const entry of this.#map) {\n            yield entry;\n        }\n    }\n\n    setProp(id, props) {\n        const element = this.get(id);\n        if (element) {\n            for (const [key, value] of Object.entries(props)) {\n                element[key] = value;\n            }\n            return true;\n        }\n        return false;\n    }\n}\n\nexport class Deferred {\n    #container;\n    #element = null;\n\n    constructor(container) {\n        this.#container = container;\n    }\n\n    empty() {\n        return this.#element === null;\n    }\n\n    get() {\n        return this.#element;\n    }\n\n    set(element) {\n        this.remove();\n        if (element instanceof HTMLElement) {\n            this.#container.appendChild(element);\n            this.#element = element;\n        }\n    }\n\n    remove() {\n        if (this.#element) {\n            this.#element.remove();\n            this.#element = null;\n        }\n    }\n\n    setProp(props) {\n        if (this.#element) {\n            for (const [key, value] of Object.entries(props)) {\n                this.#element[key] = value;\n            }\n        }\n    }\n}
\\x6bd4504d13385ee98e04ec5d322b8ff6e66d9967edbd14a6966ac894544f0eb0	75500360-4ccb-4b71-8ba8-734cc687c396
\\x6df662ab2db09565b9034bf91634d6d5bd007fdedd1d52aabb6462d076cf9777	3b87935c-120a-4823-81ac-84ce4fac168c
\\x6e7b77decff440f29f1e9e73c267253dfc639f7a92b2d89e0461a612a0222c58	/* @import url("/org.aquameta.core.widget/widget.module/widget-fsm.css"); */\n/* TODO: this won't work because these rules need to be dynamic */\n\n:host {\n    display: inline-block;\n    width: 100%;\n}\n\n/* TODO: pull this into widget-element */\n:host(:not([state="success"])) #state-success,\n:host(:not([state="success"])) .state-success {\n    display: none;\n}\n\n:host(:not([state="requesting"])) #state-requesting,\n:host(:not([state="requesting"])) .state-requesting {\n    display: none;\n}\n\n:host(:not([state="failed"])) #state-failed,\n:host(:not([state="failed"])) .state-failed {\n    display: none;\n}\n\n* {\n    box-sizing: border-box;\n}\n\nmeta-rows {\n    height: 100%;\n    width: 100%;\n}\n\nul {\n    display: inline-block;\n    height: 100%;\n    list-style: none;\n    padding: 0;\n    margin: 0;\n    width: 100%;\n}\n\nli {\n    cursor: pointer;\n    padding: 2px 4px;\n    width: 100%;\n}\n\nli:hover {\n    background-color: gray;\n}\n
\\x6f874475d164c409163b9499117fe468f61912d96f59ece94db8cd7ffad8c763	cbe87a3b-96bc-41b7-8d98-b036ecf333b4
\\x6fb8718cc28a1a3884e2ffbf461a8358a7c9110f8e7e90a85cd1e8f4dcfb0265	{js,'','',''}
\\x70dc52e6813260328016ae54d86a454487851bacac449915d4a8b8b67b4a859a	dynamic-tab-content
\\x711a96bbb34e22fc32f96e2fd60ecf800934acf6cb6834ff4fa73706ec38160e	widget-prop
\\x72679365493aa62487459e1f599908cbb37f2c45450e9e8f2140cb7a91e7de76	676289b8-e862-4540-8493-2880f8183fb9
\\x728375dff76823a157ab6018ded79c0708bb7ddaf550384799e5f27848dc4820	9fd5b730-bd32-4848-bb93-ae334fd36209
\\x72d000bb3245310d436f78610cc69a66e287feb4049334727054b3ed1cc26214	widget-tracker
\\x7329622881a8cd75cf7a9f4d3bc8f6df0f74d794095fc8b6b750e4a85943c90b	widget/widget
\\x7351624004d2cc0e8b55652c077404585169867771c838488c0572a257f565e1	import { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\n\nexport default define(\n    import.meta,\n    class DynamicTabContent extends Widget.Element {\n        static isActive = Widget.Attr.initial(false);\n    }\n);
\\x73f3fd192436c8c9c5cdd21c49d49c5a4617ac0fdc646fac465d563132da63ee	button {\n    padding: 5px;\n    color: black;\n    background-color: var(--color, blue);\n}
\\x7410f03e1c5ab107fb15467ae4c39e37995c0933553358aaf853b6c53c5c3482	static-tab
\\x742d0a0eb0d081a8d0089cc73aff5ebf4d960c25b4774781c74bbd440d0db1a2	import {Database} from './database.js';\nimport {Fsm, Machine} from './widget-fsm.js';\n\nconst datum = new Database('/endpoint/0.3', {});\nexport default datum;\n\nexport class DatumMachine extends Machine {\n    static init = Fsm.State.initial;\n    static requesting = Fsm.State;\n    static success = Fsm.State;\n    static failure = Fsm.State;\n\n    // TODO: Really want to be able to make some of the transitions private.\n    // A user should never call `this.dispatch(DatumMachine.succeeded);`\n\n\n    // TODO: This API doesn't account for wanting to make the same event work for multiple transitions\n    // i.e. init -> requesting, succeeded -> requesting, error -> requesting\n    // reload and retry are not correct here\n    // static request = Fsm.Transition([this.init, this.succeeded, this.error], this.requesting);\n\n\n    static request = Fsm.Transition(this.init, this.requesting);\n    static succeeded = Fsm.Transition(this.requesting, this.success);\n    static failed = Fsm.Transition(this.requesting, this.failure);\n    static reload = Fsm.Transition(this.success, this.requesting);\n    static retry = Fsm.Transition(this.failure, this.requesting);\n\n    context = {\n        data: null,\n        loading: false,\n        error: null,\n    }\n\n    request(dbRequest) {\n        this.dbRequest = dbRequest;\n        this.dbRequest\n            .then(\n                rows => this.dispatch(DatumMachine.succeeded, rows.map(i => i)),\n                error => this.dispatch(DatumMachine.failed, error),\n            );\n\n        return {\n            data: null,\n            loading: true,\n            error: null,\n        };\n    }\n    succeeded(data) {\n        return {\n            data,\n            loading: false,\n        };\n    }\n    failed(error) {\n        return {\n            loading: false,\n            error,\n        };\n    }\n    reload() {\n        this.dbRequest = this.dbRequest.reload();\n        this.dbRequest\n            .then((rows) => {\n                this.dispatch(DatumMachine.succeeded, rows.map(i => i));\n            })\n            .catch((error) => {\n                this.dispatch(DatumMachine.failed, error);\n            });\n        return {\n            data: null,\n            loading: true,\n        };\n    }\n    retry() {\n        this.dbRequest = this.dbRequest.reload()\n        this.dbRequest\n            .then((rows) => {\n                this.dispatch(DatumMachine.succeeded, rows.map(i => i));\n            })\n            .catch((error) => {\n                this.dispatch(DatumMachine.failed, error);\n            });\n        return {\n            loading: true,\n            error: null,\n        }\n    }\n}
\\x77117913b79c698d810c0688c22dbc936a846a6cb9333db0b1a86cca424b2f67	\nimport { monaco, monacoVim } from '/org.aquameta.ui.editor/0.35.0/widget.module/monaco-editor.js'\nimport { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\n\nexport default define(\n    import.meta,\n    class CoreFieldEditor extends Widget.Element {\n        static $ = {\n            editor: '#editor',\n            vimStatusBar: '#vim-status-bar',\n        };\n        static field = Widget.Prop;\n        static useVim = Widget.Attr.initial(true);\n        static editorConfig = Widget.Prop.initial({});\n        static type = Widget.Attr;\n        static isActive = Widget.Attr;\n        static hasUnsavedChanges = Widget.Prop;\n\n        static change = Widget.Event;\n        static save = Widget.Event;\n        static nextTab = Widget.Event;\n        static previousTab = Widget.Event;\n\n        #observer = null;\n        #editor = null;\n\n        vimMode = null;\n\n        constructor() {\n            super();\n            // TODO: Window resize listener\n            // TODO: Avoid unnecessary layout() calls, can see some jank\n            this.#observer = new IntersectionObserver(this.#onVisibilityChange.bind(this));\n        }\n\n        onWidgetConnected() {\n            this.addListener(\n                window.matchMedia('(prefers-color-scheme: dark)'),\n                'change',\n                this.#destroyAndRebuildEditor\n            );\n            this.#observer.observe(this);\n        }\n\n        onWidgetDisconnected() {\n            this.#observer.unobserve(this);\n        }\n\n        onWidgetUpdate(prop) {\n            switch (prop) {\n                case 'field':\n                    this.#destroyAndRebuildEditor()\n                    this.value = this.field.get();\n                case 'useVim':\n                    this.#configureEditor();\n                    break;\n                case 'isActive':\n                    if (this.isActive) {\n                        this.#updateEditor();\n                    } else {\n                        this.#clearEditorConfig();\n                    }\n                    break;\n                case 'hasUnsavedChanges':\n                    this.change.dispatch();\n                    break;\n            }\n        }\n\n        #destroyAndRebuildEditor() {\n            this.#destroyEditor();\n            this.#updateEditor();\n        }\n\n        #onModelChange() {\n            this.value = this.#editor.getValue();\n            this.hasUnsavedChanges = this.value !== this.field.get();\n        }\n\n        #onVisibilityChange(entries) {\n            for (const entry of entries) {\n                if (entry.target === this) {\n                    if (entry.isIntersecting) {\n                        this.#updateEditor();\n                    } else {\n                        this.#clearEditorConfig();\n                    }\n                }\n            }\n        }\n\n        #updateEditor() {\n            if (!this.#editor) {\n                this.#editor = createEditor(\n                    this.$.editor,\n                    this.field.get(),\n                    this.type,\n                    {\n                        saveRow: this.save.dispatch,\n                        nextTab: this.nextTab.dispatch,\n                        previousTab: this.previousTab.dispatch,\n                    },\n                );\n                this.#editor.onDidChangeModelContent(this.#onModelChange.bind(this));\n            }\n            this.#configureEditor();\n        }\n\n        #configureEditor() {\n            this.#clearEditorConfig();\n            if (this.useVim) {\n                if (this.vimMode) {\n                    this.vimMode.dispose();\n                }\n                this.vimMode = monacoVim.initVimMode(\n                    this.#editor,\n                    this.$.vimStatusBar,\n                );\n                monacoVim.VimMode.Vim.defineEx('write', 'w', this.save.dispatch);\n                monacoVim.VimMode.Vim.defineEx('NextTab', 'NextTab', this.nextTab.dispatch);\n                monacoVim.VimMode.Vim.defineEx('PreviousTab', 'PreviousTab', this.previousTab.dispatch);\n                monacoVim.VimMode.Vim.map('gt', ':NextTab<Enter>', 'normal');\n                monacoVim.VimMode.Vim.map('gT', ':PreviousTab<Enter>', 'normal');\n            }\n            setTimeout(() => this.#editor.layout());\n            this.#editor.focus();\n        }\n\n        #clearEditorConfig() {\n            if (this.vimMode) {\n                this.vimMode.dispose();\n            }\n            this.vimMode = null;\n        }\n\n        #destroyEditor() {\n            this.#clearEditorConfig();\n            if (this.#editor) {\n                this.#editor.dispose();\n                this.#editor = null;\n            }\n        }\n\n        layout() {\n            this.#editor.layout();\n        }\n    }\n);\n\nfunction createEditor(element, value = '', language = 'text', callbacks) {\n    if (!element) {\n        console.error('could not find element when creating editor');\n        return;\n    }\n\n    const editor = monaco.editor.create(element, {\n        value,\n        language,\n        scrollBeyondLastLine: false,\n        theme: window.matchMedia('(prefers-color-scheme: dark)').matches\n            ? "vs-dark"\n            : "vs",\n    });\n\n    editor.addAction({\n        // An unique identifier of the contributed action.\n        id: "save-widget-action-id",\n        // A label of the action that will be presented to the user.\n        label: "Save the damn widget!",\n        // An optional array of keybindings for the action.\n        keybindings: [\n            monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS,\n            // chord\n            monaco.KeyMod.chord(\n                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyK,\n                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS,\n            ),\n        ],\n        precondition: null,\n        keybindingContext: null,\n        contextMenuGroupId: "navigation",\n        contextMenuOrder: 1.5,\n        run: callbacks.saveRow,\n    });\n\n\n    editor.addAction({\n        id: "next-tab-action-id",\n        label: "Next Tab",\n        keybindings: [\n            monaco.KeyMod.chord(\n                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyK,\n                monaco.KeyCode.RightArrow,\n            ),\n        ],\n        precondition: null,\n        keybindingContext: null,\n        contextMenuGroupId: "navigation",\n        contextMenuOrder: 1.5,\n        run: callbacks.nextTab,\n    });\n\n    editor.addAction({\n        id: "previous-tab-action-id",\n        label: "Previous Tab",\n        keybindings: [\n            monaco.KeyMod.chord(\n                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyK,\n                monaco.KeyCode.LeftArrow,\n            ),\n        ],\n        precondition: null,\n        keybindingContext: null,\n        contextMenuGroupId: "navigation",\n        contextMenuOrder: 1.5,\n        run: callbacks.previousTab,\n    });\n\n    return editor;\n}\n\nfunction debounce(fn, t) {\n    let timerId = null;\n    return () => {\n        if (timerId !== null) {\n            clearInterval(timerId);\n        }\n        timerId = setTimeout(fn, t);\n    };\n}\n
\\x7729d0d2f0b69e8b7751868d56a514d573a9a88012f672b6ef141cbde3a92c29	0d38fbf4-c175-4426-854a-a73672ee6572
\\x77f1ea9901740c22db6bb28f7968d40f38b6b1dfeef68ca28267448ff1b16cf0	5f0ac5b6-3958-4e6b-bc03-d74e23a08493
\\x78278714874f01f0899af92e80ab7d9ad0b890277f277a865b157c3b6a08818b	5197d5c1-081c-470d-95d1-62d6dc204f23
\\x782e3591c7622a9faf70fc9f33e20835155c1d10486aac33874696f0671ff5f0	4fa4b945-64f5-4917-9b5c-9a475320fe20
\\x78f9ac018e554365069108352dacabb7fbd15246edf19400677e3b54fe24e126	function
\\x7979452de22156059a18d73cfe29a4e624278e2e7bf5e4f30c407ede103f5c3c	{js}
\\x799779aabedcb8dd12725fac3ce9ec020e47d3155c84544b3b18b47dbe297eb4	dynamic-tabs
\\x7a52311de0de8f0f48dcc12ca48aafc24f7a908fb8e6dfcc388e59cd98d7887d	export default function(row) {\n    return row.get('purpose');\n}
\\x7a67f0b02af0e553415b8ad13b4725d8bc8c1d2bf2b37ebe76f66238dc1614ba	@import url("/org.aquameta.ui.editor/0.35.0/widget.module/monaco-editor.css");\n\n:host {\n    display: flex;\n    flex-direction: column;\n}\n\n#editor {\n    flex-grow: 1;\n    flex-basis: auto;\n    height: 0;\n}\n\n#editor .monaco-editor,\n#editor .monaco-editor .overflow-guard {\n    height: 100%!important;\n}\n\n:host(:not([use-vim])) #vim-status-bar {\n    display: none;\n}
\\x7b5b03ec1d7eb6361367a5fbc6f31bd66b08598a348bc1fc2b71991cad5b1ddf	\n// jspm.dev serves packages in dev mode\n// unpkg serves packages in production\nimport {LitElement, html, css} from 'https://unpkg.com/lit@2.6.1/index.js?module';\nimport {when} from 'https://unpkg.com/lit@2.6.1/directives/when.js?module';\nimport {provideFASTDesignSystem, fastCombobox, fastOption} from 'https://jspm.dev/@microsoft/fast-components@2';\n\nimport { register, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\n\nimport './core-code.js';\n\nprovideFASTDesignSystem()\n    .register(\n        fastCombobox(),\n    fastOption(),\n    );\n\nexport default register(\n class EditorApp extends Widget.Element(import.meta, LitElement) {\n    static properties = {\n        nameFunction: {state: true},\n        selectedRow: {state: true},\n        sort: {},\n        columns: { state: true },\n        rows: { state: true },\n        table: {},\n    };\n    static styles = css`\n        @media (prefers-color-scheme: dark) {\n            :host {\n                background-color: #3d3d3d;\n            }\n        }\n        :host {\n            box-sizing: border-box;\n            display: flex;\n            height: 100%;\n            flex-direction: column;\n            padding: 16px;\n            width: 100%;\n        }\n        #container {\n            border: 1px solid grey;\n            flex-grow: 1;\n        }\n    `;\n    constructor() {\n        super();\n        this.selectedRow = null;\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        switch (this.table) {\n            case 'widget.widget':\n                this.columns = ['html', 'css', 'post_js', 'help'];\n                this.nameFunction = row => row.get('name');\n                break;\n            case 'widget.dependency_js':\n            case 'widget.dependency_css':\n                this.columns = ['content'];\n                this.nameFunction = row => `${row.get('name')} ${row.get('version')}`;\n                break;\n            case 'endpoint.resource':\n                this.columns = ['content'];\n                this.nameFunction = row => row.get('path');\n                break;\n            case 'widget.component':\n                this.columns = ['html', 'css', 'js', 'help'];\n                this.nameFunction = row => row.get('name');\n                break;\n            case 'widget.module':\n                this.columns = ['content'];\n                this.nameFunction = row => `${row.get('name')} ${row.get('version')}`;\n                break;\n            default:\n                console.error('table columns not implemented');\n        }\n    }\n    onComboboxChange(e) {\nconst select = this.renderRoot.querySelector('fast-combobox');\n        const value = select.options[select.selectedIndex].value;\n        if (!value) {\n            return;\n        }\n        const row = this.rows.find(row => row.get('id') === value);\n        if (row) {\n            this.selectedRow = row;\n        }\n    }\n    render() {\n        return html`\n            <fast-combobox @change=${this.onComboboxChange} autocomplete="both">\n                ${this.rows && this.rows.map(row => html`\n                    <fast-option value=${row.get('id')}>\n                        ${this.nameFunction(row)}\n                    </fast-option>\n                `)}\n            </fast-combobox>\n            ${when(this.selectedRow, () => html`\n                <div id="container">\n                    <core-code\n                        .row=${this.selectedRow}\n                        .columns=${this.columns}\n                    ></core-code>\n                </div>\n            `)}\n        `;\n    }\n}\n);\n
\\x7f974bd38173d1f7b7ece8f48d2edf426d9089cc2f935d1c37da9e02f0554e41	<div id="tabs"></div>\n<div id="tab-contents"></div>
\\x7f9c8506ec92d59f2d84d551c4cfe67f3c3d7cb5d960f97279500d8d578a4548	/${2}/${4}/widget.module/${3}.js
\\x813ee21a51c5c524236d6063366903e9cc9cfd331b092eb95a5805b113b9b4aa	const propSymbol = Symbol.for("WidgetProp");\n\nexport function isPropClass(cl) {\n    return propSymbol in cl;\n}\n\nclass BaseProp {\n    static [propSymbol];\n    #name;\n    #initialValue;\n    #hasInitialValue = false;\n    constructor(name, initialValue) {\n        this.#name = name;\n        if (typeof initialValue !== 'undefined') {\n            this.#initialValue = initialValue;\n            this.#hasInitialValue = true;\n        }\n    }\n    get name() {\n        return this.#name;\n    }\n    get hasInitialValue() {\n        return this.#hasInitialValue;\n    }\n    get initialValue() {\n        return this.#initialValue;\n    }\n}\n\nexport class Attr extends BaseProp {}\nexport class Prop extends BaseProp {}\n
\\x81f35f712b5949461cdd3f97edc32db1a3a6525c299f84a7c72cf29dc9d2d101	88fe0f88-271e-40d0-83d1-87e46f3b79f8
\\x825292e4fcb76371ac87fec15b4374b83be9479e3f06ea177ab5b86349409506	<!doctype html>\n<html>\n    <head>\n        <title>bundles</title>\n        <base href="/com.mickey.ui/" />\n        <style>\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body>\n        <bundle-workspace></bundle-workspace>\n    </body>\n    <script>\n        const bundleWorkspace = document.querySelector('bundle-workspace');\n        const bundlePicker = document.createElement('bundle-picker');\n\n        function setBundleName(event) {\n            const {name} = event.detail;\n            bundleWorkspace.setAttribute('bundle-name', name);\n            document.title = `bundles: ${name}`;\n            bundlePicker.removeEventListener('bundle-picker-selected', setBundleName);\n            bundlePicker.remove();\n        }\n        \n        function setWorkspace() {\n            const bundleName = window.location.hash.replace(/^#/, '');\n            if (bundleName) {\n                bundleWorkspace.setAttribute('bundle-name', bundleName);\n                document.title = `bundles: ${bundleName}`;\n            } else {\n                bundleWorkspace.setAttribute('bundle-name', bundleName);\n                bundlePicker.addEventListener('bundle-picker-selected', setBundleName);\n                document.body.appendChild(bundlePicker);\n            }\n        }\n\n        window.addEventListener('hashchange', setWorkspace);\n        setWorkspace();\n    </script>\n    <script type="module" src="widget.component/bundle-workspace.js"></script>\n</html>
\\x82bed12bea8fa8d843f85128b54bc769a8da13150a18450960eb780c12f950e4	4f63c7d9-9b89-46d1-9007-9b1490f44104
\\x82ec49c2e7e84d6f661f59f078df11a893d5a60023e939451b47735ec8b0a2e3	dynamic-tab
\\x83b91b7f49c2b24abcb8c5daad65dab278311963f75988b96436e99350727e3b	core-field-edit-code
\\x8447923654915760fd3cecdc85ed954557de389e5501c81aa1a8a101667d7a79	bundle-workspace
\\x844ac22efc453c995e067b05d712a0abff918ef1f305b16b37054aa12eaaf56e	<!doctype html>\n<html>\n    <head>\n        <title>widget editor</title>\n        <base href="/com.mickey.ui/" />\n        <style>\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body>\n        <meta-relation $relation="widget.module" $order="name">\n            <editor-app meta-relation="rows" table="widget.module"></editor-app>\n        </meta-relation>\n    </body>\n    <script type="module" src="widget.component/editor-app.js"></script>\n    <script type="module" src="widget.component/meta-relation.js"></script>\n</html>
\\x878bdb5bba10b8ead3afdb1adb2b578f4f1cd26f413d55a4ec954439d28e3523	8a3607c3-cd7c-477d-8f23-f50b4792afdf
\\x87f97cff112188c5da8d25251624a64a6403a8ad3cd621995fdb5bed5070c668	import { define, Widget} from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\n\nexport default define(\n    import.meta,\n    class StaticTab extends Widget.Element {\n        static tabIndex = Widget.Attr;\n        static label = Widget.Prop;\n        static isActive = Widget.Attr.initial(false);\n        static activated = Widget.Event.detail(this.tabIndex);\n\n        onWidgetConnected() {\n            this.addListener(this, 'click', this.activated.dispatch);\n        }\n    }\n);
\\x881d5fb60090f59aabba4f287d7596317ca7091d00c2180b6cbc8ab018b9febd	column
\\x88bfb12f0ebadab4803eba0da2438a37ec080df09dfb321a6767e28910db403a	semantics/relation_purpose
\\x89117fd47cebb49b08a4b15651df7f6908d9256e04119bcc7a330f8621ddf3f1	widget/get_module/{text,text,text,text}
\\x8ac140ceb6ca8d6e51a987a9828b9f97b95bbc3ae6bdb0558e2631cb8da232b8	widget
\\x8c5f0db10fce8a3e68700bcf37c3a44e134e373047b7706072821e1e9f125c62	d287e090-022d-4af8-a251-2fbca7be5d92
\\x8dd308e64584bd1706d1fa160504e0a5921f373eede2723f4acd9ac1d37bff55	import { define, Widget } from '/org.aquameta.core.widget/widget.module/widget.js';\n\nexport default define(\n    import.meta,\n    class MyWidget extends Widget.Element {\n        static $ = {\n            input: 'input',\n            button: 'button',\n        };\n        static inputPlaceholder = Widget.Attr;\n        static buttonText = Widget.Attr;\n        static submit = Widget.Event;\n\n        onWidgetConnected() {\n            this.addListener(this.$.button, 'click', this.onSubmit);\n            this.addListener(this.$.input, 'keydown', this.onKeydown)\n        }\n\n        onSubmit() {\n            this.submit.dispatch({ value: this.$.input.value });\n        }\n\n        onKeydown(e) {\n            if (e.key === 'Enter') {\n                this.submit.dispatch({ value: this.$.input.value });\n            }\n        }\n    }\n);
\\x8deba395aab9b8dbc5dda845abdfa0efec294e1ec2a43d1b52bcd70ae073bb8e	import { Attr, Prop } from './widget-prop.js';\nimport { Fsm } from './widget-fsm.js';\nimport { Event } from './widget-event.js';\nimport { findParentWidget, isWidgetClass, isWidgetInstance, validateMeta } from './widget-util.js';\nimport { WidgetElement, WidgetLightElement, Collection, Deferred } from './widget-element.js';\n\n/**\n * TODO: Make more FSM-based components\n * - some built-in FSMs\n * - try writing a form FSM\n * - FSM as a way to validate complex state\n */\n\n/**\n * TODO: Make more database components\n * - datum/endpoint obviously need a rewrite, but maybe just adding all the metadata (bundle, semantics, fkey, etc.) I want will mitigate that for now\n * - datum needs a new API, db.rows(), db.function(), db.related(rows, otherRows)(?) etc.\n * - how to mix multiple requests into a single component, can we still use an FSM for this?\n */\n\n/**\n * Widget provides a number of useful things to make writing custom components easier\n * e.g. Prop, Attr, Event, $, Context, Machine\n * All this state is managed, so we can provide things like hot-reloading, too.\n * \n * Additionally it provides things that make Aquameta easier\n * e.g. Db, sync, \n * But do these things have to be static properties? Need to be careful here to not\n * pollute the Widget namespace with a ton of functionality. Sure, everything could be\n * static properties, but then Widgets just become configuration. This is great in one\n * way, but no one likes to write static configuration, especially when it becomes\n * intertwined and complicated.\n * \n * Focus: Go down the FSM path. This may solve issues or provide APIs that solve\n * the Db/sync stuff\n */\n\n/**\n * TODO: FSM\n * - How would this work with replacing inner contents with new widget contents?\n * - What happens to the state of child elements?\n * - I guess that's the rub, child state is lost becuse you edited the parent widget. That's fine.\n * \n *\n * - For the complicated use cases, the database should be a FSM that you integrate as a child in your FSM\n */\n\n/**\n * TODO:\n * - Get rid of meta-rows, meta-row, meta-field (Can we?)\n * - Then don't need all the complicated \n * - For the simple use case of just getting data and putting it in the DOM.\n * \n * static user = Widget.Prop;\n * static errorMessage = Widget.Prop;\n * static user = Widget.Db('endpoint.user', this.user, this.errorMessage);\n * static $ = { container: '#container' };\n * \n * this.syncData(this.$.container);\n * \n * <ul id="container"></ul>\n * \n * <template data="user">\n *   <li>\n *     <meta-field="id"></meta-field> - <meta-field="name"></meta-field>\n *     or something without a custom component? (this example wouldn't work)\n *     <template field="id"></template>\n *   </li>\n * </template>\n * \n * <template data="errorMessage">\n *   <li>\n *     Oh no!\n *   </li>\n * </template>\n */\n\n// Widget-namespaced functions creates metadata used to create Events and BaseProps.\nexport const Widget = {\n    Element: WidgetElement,\n    LightElement: WidgetLightElement,\n    get Attr() {\n        return {\n            type: Attr,\n            initial(val) {\n                this.value = val;\n                return this;\n            }\n        };\n    },\n    BaseElement(BaseClass, options) {\n        return getBaseClass(BaseClass);\n    },\n    get Prop() {\n        return {\n            type: Prop,\n            initial(val) {\n                this.value = val;\n                return this;\n            }\n        };\n    },\n    get Event() {\n        return {\n            type: Event,\n            details: [],\n            detail(...vals) {\n                this.details = vals;\n                return this;\n            },\n        };\n    },\n    Collection(selector) {\n        return {\n            type: Collection,\n            selector,\n        }\n    },\n    Deferred(selector) {\n        return {\n            type: Deferred,\n            selector,\n        }\n    },\n    Fsm(machine) {\n        return {\n            type: Fsm,\n            machine,\n        };\n    },\n};\n\n// Add bare-essential widget functionality to interop with Widget.Element.\n// TODO: Metadata and stuff needs to be added.\nfunction getBaseClass(BaseClass) {\n    // TODO: setting a static member on a base class. Does this even work without conflicting with other components?\n    // TODO: can we add a mixin to this class that won't interfere but will still allow us to get import.meta and track it\n    BaseClass.widgetName = metadata.widgetName;\n    return class extends BaseClass {\n        static widgetName = metadata.widgetName;\n\n        #metadata;\n        constructor() {\n            super();\n            this.#metadata = metadata;\n        }\n        connectedCallback() {\n            if (super.connectedCallback) {\n                super.connectedCallback();\n            }\n            this.#metadata.parent = findParentWidget(this.shadowRoot || this);\n            if (this.onWidgetConnected) {\n                this.onWidgetConnected();\n            }\n\n        }\n        disconnectedCallback() {\n            if (super.disconnectedCallback) {\n                super.disconnectedCallback();\n            }\n            if (this.onWidgetDisconnected) {\n                this.onWidgetDisconnected();\n            }\n        }\n        get metadata() {\n            return this.#metadata;\n        }\n    }\n}\n\nexport function isWidget(element, type = null) {\n    if (!isWidgetInstance(element)) {\n        return false;\n    }\n\n    if (type === null) {\n        return true;\n    }\n\n    if (\n        element.widgetMetadata.widgetName === type.metadata.widgetName &&\n        element.widgetMetadata.bundleName === type.metadata.bundleName\n    ) {\n        return true;\n    }\n\n    return false;\n}\n\n// TODO: provide a subscription method to intercept this and add a dev\n// parameter e.g. 'test-widget' -> 'test-widget-1'\nexport function register(...args) {\n    console.warn('deprecated usage of register');\n    return define(...args);\n}\n\nexport function define(meta, Element, options) {\n    const { error, metadata } = validateMeta(meta);\n    if (error) {\n        console.log(error);\n        metadata.widgetName = meta;\n    }\n    Element.metadata = metadata;\n    customElements.define(Element.metadata.widgetName, Element, options);\n    function createElement(attributes = null) {\n        const el = document.createElement(Element.metadata.widgetName);\n        if (isWidgetClass(Element) && attributes !== null) {\n            for (const [key, value] of Object.entries(attributes)) {\n                el[key] = value;\n            }\n        } else if (attributes !== null) {\n            throw new Error(`[register] cannot create element with attribute object for non-Widget component`)\n        }\n        return el;\n    }\n    createElement.metadata = metadata;\n    return createElement;\n}\n
\\x8ecee74981539d4b4eb8529c83d9a4afff4ee2591d430e8b2c37af5e1d13e8b0	<!doctype html>\n<html>\n    <head>\n        <title>widget editor</title>\n        <base href="/com.mickey.ui/" />\n        <style>\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body>\n        <meta-relation $relation="widget.component" $order="name">\n            <editor-app meta-relation="rows" table="widget.component"></editor-app>\n        </meta-relation>\n    </body>\n    <script type="module" src="widget.component/editor-app.js"></script>\n    <script type="module" src="widget.component/meta-relation.js"></script>\n</html>
\\x8fc2ab24d24e99d5b79cafdfd7aae2c6cc221807b070fd4b0452399b86050af0	b515e5d7-aa89-4c2e-bedc-8ca733fd0da7
\\x8fce2576fe6651597d915aaed368052c84e6eafffe67b9e161537d538e960d29	b315e0cd-bcfc-4386-92a3-f97f3ca3fafe
\\x905391bbf068a234ce32477dd6eec8db90ffc7d4f4d3a5cff72c63d3698e51ee	endpoint/resource_function
\\x914e6de0932b09f76b7e7007bf4907a8433883121d8111fb69d25ce85ca9fe84	<button>\n    <slot>\n        <span data-name="innerText">jazzy</span>\n    </slot>\n</button>
\\x91d20c966f6f93e8f0fed12944a388f1fa025d0fc28f868a0590fc4d60beaa7a	export default function(row) {\n    const relId = row.get('relation_id');\n    return `fn(${relId.schema_name}.${relId.name})`;\n}
\\x92aef7bddc4085bdb7d5e56e7f2dfc86e64fe7fb98e1b0655bd019a34ee8f2db	import { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\n\nimport './bundle-contents.js';\nimport './static-event-tabs.js';\nimport './static-event-tab.js';\nimport './dynamic-tabs.js';\nimport './material-icon.js';\nimport './pill-form.js';\nimport semanticWidget from './semantic-widget.js';\n\nconst eventWidgetMap = {\n    docs: 'bundle-docs',\n    stage: 'bundle-stage',\n    commits: 'bundle-commits',\n    untracked: 'bundle-untracked',\n    remotes: 'bundle-remotes',\n    semantics: 'bundle-semantics',\n    export: 'bundle-export',\n    config: 'bundle-config',\n};\n\nexport default define(\n    import.meta,\n    class BundleWorkspace extends Widget.Element {\n        static $ = {\n            staticEventTabs: 'static-event-tabs',\n            bundleContents: 'bundle-contents',\n            dynamicTabs: 'dynamic-tabs',\n            link: 'a#link',\n            searchForm: 'pill-form',\n        };\n        static bundleName = Widget.Attr;\n\n        onWidgetConnected() {\n            this.addListener(this.$.staticEventTabs.activated, this.onTabActivated);\n            this.addListener(this.$.bundleContents.activated, this.onBundleRowActivated);\n            this.addListener(this.$.searchForm.submit, this.onSearchSubmit);\n        }\n\n        onWidgetUpdate(prop) {\n            if (prop === 'bundleName') {\n                this.$.link.href = `/bundle#${this.bundleName}`;\n            }\n        }\n\n    \tonTabActivated(event) {\n            const createElement = async () => {\n                const widgetName = eventWidgetMap[event.detail.event];\n                const createEl = await import(`./${widgetName}.js`)\n                return createEl({ bundleName: this.bundleName });\n            }\n            this.$.dynamicTabs.trigger(event.detail.label, createElement);\n\t    }\n\n    \tonBundleRowActivated(event) {\n            const { identifier, row } = event.detail;\n            this.$.dynamicTabs.trigger(identifier, function createSemanticWidgetElement() {\n                return semanticWidget({\n                    purpose: 'edit',\n                    bundle: 'com.mickey.ui', // TODO: automatically get this, e.g. row.bundleName?\n                    rowId: row.get('row_id'),\n                });\n            });\n\t    }\n\n        onSearchSubmit(e) {\n            const searchTerm = e.detail.value;\n            if (!searchTerm) {\n                return;\n            }\n            const createElement = async () => {\n                const createEl = await import('./bundle-search.js')\n                return createEl({ bundleName: this.bundleName, searchTerm });\n            }\n            this.$.dynamicTabs.trigger(`Search: ${searchTerm}`, createElement);\n        }\n    }\n);
\\x9342af224fa264b0e961df75246597ee455cd08afe11b0a8cea6bb74dc59bf55	util
\\x937256ebaeda75bec5651d4e66330ab281deac7461c413635ce8716a05764746	ec38b57f-4992-447f-87b4-1ecad2dee97a
\\x93f5872184121c2f0691bb56461c508e85be821bdf6a3db58c91c089de532984	b4d541e5-7741-4096-a462-73905fc156ae
\\x94cbbaaf3383fe8e0b3f7cf396197c6317bf0492e5159bb48a7d6f40893b30d6	core-row-edit
\\x97a3a1ff3af471c9a39888b41c3769ef157eee6437541d480188918688af83f2	<div>\n    <slot name="icon"></slot>\n    <span part="label" data-label="innerText"></span>\n</div>
\\x98a6c0dc5c5121aa84b39a2e2ddeddd6857e90641a7c5d20116428bbbc73d75e	let promise;\nconst names = new Map();\n\nasync function getPurpose(id) {\n    if (!promise) {\n        promise = db.schema('semantics').relation('column_purpose').rows()\n            .then(rows => {\n                const purposes = rows.map(i => i);\n                for (const purpose of purposes) {\n                    names.set(purpose.get('id'), purpose.get('purpose'));\n                }\n            })\n    }\n    await promise;\n    return names.get('id');\n}\n\nexport default function(row) {\n    const purpose = await getPurpose(row.get('id'));\n    const colId = row.get('column_id');\n    return `${colId.schema_name}.${colId.relation_name}:${colId.name} ${purpose}`\n}
\\x98eeece9e16cdf52db0935e703d456b021fbf58c542f722c17229a40891230cc	import { monaco, monacoVim } from '/org.aquameta.ui.editor/0.35.0/widget.module/monaco-editor.js'\nimport { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\n\nexport default define(\n    import.meta,\n    class CoreFieldEditor extends Widget.Element {\n        static $ = {\n            editor: '#editor',\n            vimStatusBar: '#vim-status-bar',\n        };\n        static field = Widget.Prop;\n        static useVim = Widget.Attr.initial(true);\n        static editorConfig = Widget.Prop.initial({});\n        static type = Widget.Attr;\n        static isActive = Widget.Attr;\n        static hasUnsavedChanges = Widget.Prop;\n\n        static change = Widget.Event;\n        static save = Widget.Event;\n        static nextTab = Widget.Event;\n        static previousTab = Widget.Event;\n\n        #observer = null;\n        #editor = null;\n\n        vimMode = null;\n\n        constructor() {\n            super();\n            // TODO: Window resize listener\n            // TODO: Avoid unnecessary layout() calls, can see some jank\n            this.#observer = new IntersectionObserver(this.#onVisibilityChange.bind(this));\n        }\n\n        onWidgetConnected() {\n            this.addListener(\n                window.matchMedia('(prefers-color-scheme: dark)'),\n                'change',\n                this.#destroyAndRebuildEditor\n            );\n            this.#observer.observe(this);\n        }\n\n        onWidgetDisconnected() {\n            this.#observer.unobserve(this);\n        }\n\n        onWidgetUpdate(prop) {\n            switch (prop) {\n                case 'field':\n                    this.#destroyAndRebuildEditor()\n                    this.value = this.field.get();\n                case 'useVim':\n                    this.#configureEditor();\n                    break;\n                case 'isActive':\n                    if (this.isActive) {\n                        this.#updateEditor();\n                    } else {\n                        this.#clearEditorConfig();\n                    }\n                    break;\n                case 'hasUnsavedChanges':\n                    this.change.dispatch();\n                    break;\n            }\n        }\n\n        #destroyAndRebuildEditor() {\n            this.#destroyEditor();\n            this.#updateEditor();\n        }\n\n        #onModelChange() {\n            this.value = this.#editor.getValue();\n            this.hasUnsavedChanges = this.value !== this.field.get();\n        }\n\n        #onVisibilityChange(entries) {\n            for (const entry of entries) {\n                if (entry.target === this) {\n                    if (entry.isIntersecting) {\n                        this.#updateEditor();\n                    } else {\n                        this.#clearEditorConfig();\n                    }\n                }\n            }\n        }\n\n        #updateEditor() {\n            if (!this.#editor) {\n                this.#editor = createEditor(\n                    this.$.editor,\n                    this.field.get(),\n                    this.type,\n                    {\n                        saveRow: this.save.dispatch,\n                        nextTab: this.nextTab.dispatch,\n                        previousTab: this.previousTab.dispatch,\n                    },\n                );\n                this.#editor.onDidChangeModelContent(this.#onModelChange.bind(this));\n            }\n            this.#configureEditor();\n        }\n\n        #configureEditor() {\n            this.#clearEditorConfig();\n            if (this.useVim) {\n                if (this.vimMode) {\n                    this.vimMode.dispose();\n                }\n                this.vimMode = monacoVim.initVimMode(\n                    this.#editor,\n                    this.$.vimStatusBar,\n                );\n                monacoVim.VimMode.Vim.defineEx('write', 'w', this.save.dispatch);\n                monacoVim.VimMode.Vim.defineEx('NextTab', 'NextTab', this.nextTab.dispatch);\n                monacoVim.VimMode.Vim.defineEx('PreviousTab', 'PreviousTab', this.previousTab.dispatch);\n                monacoVim.VimMode.Vim.map('gt', ':NextTab<Enter>', 'normal');\n                monacoVim.VimMode.Vim.map('gT', ':PreviousTab<Enter>', 'normal');\n            }\n            setTimeout(() => this.#editor.layout());\n            this.#editor.focus();\n        }\n\n        #clearEditorConfig() {\n            if (this.vimMode) {\n                this.vimMode.dispose();\n            }\n            this.vimMode = null;\n        }\n\n        #destroyEditor() {\n            this.#clearEditorConfig();\n            if (this.#editor) {\n                this.#editor.dispose();\n                this.#editor = null;\n            }\n        }\n\n        layout() {\n            this.#editor.layout();\n        }\n    }\n);\n\nfunction createEditor(element, value = '', language = 'text', callbacks) {\n    if (!element) {\n        console.error('could not find element when creating editor');\n        return;\n    }\n\n    const editor = monaco.editor.create(element, {\n        value,\n        language,\n        scrollBeyondLastLine: false,\n        theme: window.matchMedia('(prefers-color-scheme: dark)').matches\n            ? "vs-dark"\n            : "vs",\n    });\n\n    editor.addAction({\n        // An unique identifier of the contributed action.\n        id: "save-widget-action-id",\n        // A label of the action that will be presented to the user.\n        label: "Save the damn widget!",\n        // An optional array of keybindings for the action.\n        keybindings: [\n            monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS,\n            // chord\n            monaco.KeyMod.chord(\n                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyK,\n                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS,\n            ),\n        ],\n        precondition: null,\n        keybindingContext: null,\n        contextMenuGroupId: "navigation",\n        contextMenuOrder: 1.5,\n        run: callbacks.saveRow,\n    });\n\n\n    editor.addAction({\n        id: "next-tab-action-id",\n        label: "Next Tab",\n        keybindings: [\n            monaco.KeyMod.chord(\n                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyK,\n                monaco.KeyCode.RightArrow,\n            ),\n        ],\n        precondition: null,\n        keybindingContext: null,\n        contextMenuGroupId: "navigation",\n        contextMenuOrder: 1.5,\n        run: callbacks.nextTab,\n    });\n\n    editor.addAction({\n        id: "previous-tab-action-id",\n        label: "Previous Tab",\n        keybindings: [\n            monaco.KeyMod.chord(\n                monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyK,\n                monaco.KeyCode.LeftArrow,\n            ),\n        ],\n        precondition: null,\n        keybindingContext: null,\n        contextMenuGroupId: "navigation",\n        contextMenuOrder: 1.5,\n        run: callbacks.previousTab,\n    });\n\n    return editor;\n}\n\nfunction debounce(fn, t) {\n    let timerId = null;\n    return () => {\n        if (timerId !== null) {\n            clearInterval(timerId);\n        }\n        timerId = setTimeout(fn, t);\n    };\n}
\\x98f444962a1bdfab2086cff411e6188577d8bd944ba4f89ea235022b9c301fcb	import { Collection } from '/org.aquameta.core.widget/0.3.1/widget.module/widget-collection.js';\n\nexport class MetaComponentHelper {\n    #self;\n    #childTag;\n    #childAttr;\n    #children;\n    #childAttributes;\n    \n    constructor(component, childTag, childAttr) {\n        this.#self = component;\n        this.#childTag = childTag;\n        this.#childAttr = childAttr;\n    }\n\n    init(config = {}) {\n        this.#children = this.#getChildren(config);\n        this.#childAttributes = this.#getChildrenWithAttributes(config);\n    }\n\n    #getChildren(config) {\n        return Array.from(this.#self.querySelectorAll(this.#childTag))\n            .map(el => {\n                const node = {\n                    parent: new Collection(el.parentNode),\n                    element: el,\n                        attrs: config.attrs?.reduce((acc, attr) => {\n                            if (el.hasAttribute(attr)) {\n                                const value = el.getAttribute(attr).trim();\n                                acc[attr] = value;\n                            }\n                            return acc;\n                        }, {}),\n                };\n                if (config.remove) {\n                    el.remove();\n                }\n                return node;\n            })\n            .filter(Boolean);\n    }\n\n    #getChildrenWithAttributes(config) {\n        return Array.from(this.#self.querySelectorAll(`[${this.#childAttr}]`))\n            .map(element => {\n                const attrNode = {\n                    element,\n                    property: element.getAttribute(this.#childAttr),\n                };\n                if (config.remove) {\n                    element.removeAttribute(this.#childAttr);\n                }\n                return attrNode;\n            });\n    }\n\n    get children() {\n        return this.#children;\n    }\n\n    get childAttributes() {\n        return this.#childAttributes;\n    }\n}
\\x9a2a44d5366623d45fcc43bc4a3f16b950840e3c2af53dc0fc12f8bc468615f6	<div>\n    <jazzy-button id="first" color="magenta"></jazzy-button>\n    <jazzy-button id="second">\n        <span>super jazzy one</span>\n    </jazzy-button>\n</div>
\\x9a731472c819b601deee60470155fe19d6b6ec708eaf06f6a2fd1321f6ddd85a	<div id="editor"></div>\n<div id="vim-status-bar"></div>
\\x9a9e8923db819a5b491e6076cb4085b6c7c3ebd4bb8b5435780834c3573467d5	material-icon
\\x9adf13c6279a2fbe0841f06ebbf9f5ed8f0b46b3651c285f32c8eca881c030c5	\nimport { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\nimport db from '/org.aquameta.core.widget/0.3.1/widget.module/datum.js';\n\nexport default define(\n    import.meta,\n    class SemanticIdentifier extends Widget.LightElement {\n        static pattern = Widget.Attr;\n        static identifier = Widget.Prop;\n        static row = Widget.Prop;\n        static rowId = Widget.Prop;\n        static identifierChanged = Widget.Event.detail(this.identifier);\n\n        #promises;\n\n        onWidgetConnected() {\n            // Initialize promises immediately.\n        }\n\n        // TODO: It would be awesome if we could just query for all the reified rows in the bundle and the default metadata would have the bundle data (change_type, head_commit_id, etc.)\n        onWidgetUpdate(prop) {\n            switch (prop) {\n                case 'identifier':\n                    this.innerText = this.identifier;\n                    this.identifierChanged.dispatch();\n                    break;\n               case 'rowId':\n                    if (!this.#promises) {\n                        this.#promises = Promise.all([\n                            this.getIdentifierFunction(),\n                            this.getBundle(),\n                        ]);\n                    }\n                    db.rowIdToRow(this.rowId).then(row => {\n                        this.row = row;\n                    });\n                    break;\n                case 'row':\n                    if (!this.#promises) {\n                        this.#promises = Promise.all([\n                            this.getIdentifierFunction(),\n                            this.getBundle(),\n                        ]);\n                    }\n                    this.replacePattern();\n                    break;\n            }\n        }\n        async replacePattern() {\n            this.#promises.then(([semantics, bundle]) => {\n                const rowId = this.getRowId();\n                let relName, schemaName;\n                if ('pk_column_id' in rowId) {\n                    relName = rowId.pk_column_id.relation_id.name;\n                    schemaName = rowId.pk_column_id.relation_id.schema_id.name;\n                } else {\n                    relName = rowId.relation_name;\n                    schemaName = rowId.schema_name;\n                }\n                if (!this.row) {\n                    console.log(this.row, schemaName, relName, bundle);\n                }\n                this.identifier = this.pattern\n                    .replace('{id}', this.row ? semantics(this.row) : 'NULL')\n                    .replace('{relation}', `${schemaName}.${relName}`)\n                    .replace('{bundle}', bundle || 'untracked');\n            });\n        }\n        async getBundle() {\n            // TODO: Best situation would be if bundle meta data was returned with the row from endpoint\n            if (!this.pattern.includes('{bundle}')) {\n                return null;\n            }\n            try {\n                const trackedRow = await db.schema('bundle').relation('tracked_row').row('row_id', this.getRowId());\n                if (!trackedRow) {\n                    return null;\n                }\n                const bundleId = trackedRow.get('bundle_id');\n                if (bundles.has(bundleId)) {\n                    return bundles.get(bundleId);\n                }\n                const bundleNamePromise = db.schema('bundle').relation('bundle').row('id', bundleId)\n                    .then(bundle => bundle.get('name'))\n                    .catch(e => {\n                        console.error(e);\n                        return null;\n                    });\n                bundles.set(bundleId, bundleNamePromise);\n                return bundleNamePromise;\n            } catch (e) {\n                console.error(e);\n                return null;\n            }\n        }\n        getRowId() {\n            if (this.row) {\n                return this.row.id;\n            } else {\n                return this.rowId;\n            }\n        }\n        async getIdentifierFunction() {\n            const rowId = this.getRowId();\n            let relName, schemaName;\n            if ('pk_column_id' in rowId) {\n                relName = rowId.pk_column_id.relation_id.name;\n                schemaName = rowId.pk_column_id.relation_id.schema_id.name;\n            } else {\n                relName = rowId.relation_name;\n                schemaName = rowId.schema_name;\n            }\n            // TODO: Could hasIdentifier be a part of datum, so we don't have to get 404s in the console\n            // Don't need this round trip (even though its only once per table) if we have better metadata\n            try {\n                // TODO: with generated schema names, this would need to change to bundle.relation, not schema.relation\n                // This could be a far-reaching shift to bundle names instead of schema\n                const { default: semantics } = await import(\n                    `/semantics/${schemaName}.${relationName}/identifier.js`\n                );\n                return semantics;\n            } catch (e) {\n                return defaultSemanticsIdentifier;\n            }\n        }\n    }\n)\n\nfunction defaultSemanticsIdentifier(row) {\n    return row.get('name') || row.get(row.pk_column_name || 'id');\n}\n\n
\\x9b08747e5e6077da42a5cf30e541fc96a99b679ae7fdaa1639282a800e071b86	widget-fsm
\\x9d968ea75ef0fe7b50bd65851943439c95662c0fe12743393176263cce839c18	\nexport class Endpoint {\n  constructor(url, database, evented) {\n    this.url = url;\n    this.database = database;\n    this.evented = false;\n    this.cache = {};\n    this.sessionId = null; // = getPersistedSessionId();\n    this.socket = null;\n  }\n  connectSession(sessionId) {\n    this.sessionId = sessionId;\n    if (this.socket) {\n      this.socket.attach(sessionId);\n    }\n  }\n  handleEvent(event) {\n    const {\n      subscription_type: subscriptionType,\n      payload,\n      operation,\n      row_id: rowId,\n    } = event;\n    console.log({subscriptionType, payload, operation, rowId});\n\n    switch (subscriptionType) {\n      case 'table': {\n        console.log(subscriptionType + ':' + operation);\n        const rowsets = this.database.getTracked(\n          relationId(rowId.pk_column_id.relation_id).url()\n        );\n        for (const rowset of rowsets) {\n          rowset._triggerEvent(operation, payload, rowId);\n        }\n        break;\n      }\n      case 'column':\n        console.log(subscriptionType + ':' + operation);\n        break;\n      case 'row':\n        console.log(subscriptionType + ':' + operation);\n        break;\n      case 'field':\n        console.log(subscriptionType + ':' + operation);\n        break;\n      default:\n        break;\n    }\n    // TODO: Delete event\n  }\n  _resource(method, meta_id, args, data) {\n    args = args || {};\n\n    // Get use_cache from args or data\n    let use_cache = false;\n    if (!data && args.use_cache) {\n      use_cache = args.use_cache;\n      delete args.use_cache;\n    } else if (data?.use_cache) {\n      use_cache = data.use_cache;\n      delete data.use_cache;\n    }\n\n    // allow un-evented call by passing false for 'events'\n    const passed = Object.hasOwn(args, 'events');\n    const isTruthy = Boolean(args.events);\n    if (!passed || isTruthy) {\n      // If this connection is evented, get event_session_id\n      if (this.evented && this.sessionId) {\n        args.session_id = this.sessionId;\n      }\n    }\n    delete args.events;\n\n    // URLs\n    const id_url = meta_id.to_url(true); // ID part of the URL only\n    const url_without_query = this.url + id_url;\n    const url_with_query = url_without_query + buildQueryString(args);\n\n    // Check cache\n    if (use_cache && url_with_query in this.cache) {\n      return this.cache[url_with_query];\n    }\n\n    // If query string is too long, upgrade GET method to POST\n    if (method == 'GET' && (location.host + url_with_query).length > 1000) {\n      method = 'POST';\n    }\n\n    const headers = new Headers();\n    headers.append('Content-Type', 'application/json');\n\n    const init_obj = {\n      method: method,\n      headers: headers,\n      credentials: 'same-origin',\n    };\n\n    // Don't add data on GET requests\n    if (method !== 'GET') {\n      init_obj.body = JSON.stringify(data);\n    }\n\n    const request = fetch(\n      method === 'GET' ? url_with_query : url_without_query,\n      init_obj\n    )\n      .then(function (response) {\n        // this will never happen\n        // JSON was returned from WebSocket\n        if (typeof response.json == 'undefined') {\n          // TODO: ? Unfortunately this has no HTTP status like the result of fetch\n          return response;\n        }\n\n        // Request object was returned from fetch\n        // Read json stream\n        var json = response.json();\n\n        if (response.status >= 200 && response.status < 300) {\n          return json;\n        }\n\n        // If bad request (code 300 or higher), reject promise\n        return json.then(Promise.reject.bind(Promise));\n      })\n      .catch(function (server_error) {\n        // Construct real Error object\n        const err = new Error(server_error.message.message);\n        err.metadata = server_error.message || {};\n        err.metadata.status_code = server_error.status_code;\n        err.metadata.title = server_error.title;\n\n        // Log error in collapsed group\n        console.groupCollapsed(\n          method,\n          server_error.status_code,\n          server_error.title\n        );\n        // console.error(url_without_query);\n        if ('message' in server_error) {\n          console.error(method == 'GET' ? url_with_query : url_without_query);\n          console.error(server_error.message.message);\n          console.error(server_error.message.context);\n        }\n        console.groupEnd();\n\n        throw err;\n      });\n\n    // Check cache for GET/POST\n    if (use_cache && (method == 'GET' || method == 'POST')) {\n      this.cache[url_with_query] = request;\n    }\n\n    return request;\n  }\n\n  get(meta_id, args) {\n    return this._resource('GET', meta_id, args);\n  }\n\n  post(meta_id, data) {\n    return this._resource('POST', meta_id, {}, data);\n  }\n\n  patch(meta_id, data) {\n    return this._resource('PATCH', meta_id, {}, data);\n  }\n\n  delete(meta_id, args) {\n    return this._resource('DELETE', meta_id, args);\n  }\n}\n\nfunction buildQueryString(options) {\n  const keys = [];\n  if (typeof options != 'undefined') {\n    // Meta data defaults to true;\n    if (typeof options.meta_data == 'undefined') {\n      options.meta_data = true;\n    }\n\n    // Map the keys of the options object to an array of encoded url components\n    const params = Object.entries(options).sort(([a], [b]) =>\n      a.localeCompare(b)\n    );\n    for (let [key, value] of params) {\n      switch (key) {\n        case 'where':\n          // where: { name: 'column_name', op: '=', value: 'value' }\n          // where: [{ name: 'column_name', op: '=', value: 'value' }]\n          if (typeof value.length == 'undefined') value = [value];\n\n          keys.push(\n            value\n              .map(function (where) {\n                return 'where=' + encodeURIComponent(JSON.stringify(where));\n              })\n              .join('&')\n          );\n          break;\n\n        case 'order_by':\n          // So many possibilities...\n          // order_by: '-?column_name'\n          // order_by: ['-?column_name']\n          // order_by: { 'column_name': 'asc|desc' }\n          // order_by: [{ 'column_name': 'asc|desc' }]\n          // order_by: { column: 'column_name', direction: 'asc|desc' }\n          // order_by: [{ column: 'column_name', direction: 'asc|desc' }]\n          if (typeof value.length == 'undefined') value = [value];\n\n          keys.push(\n            key +\n              '=' +\n              encodeURIComponent(\n                value\n                  .map(function (o) {\n                    return (\n                      (typeof o.direction != 'undefined' &&\n                      o.direction != 'asc'\n                        ? '-'\n                        : '') + o.column\n                    );\n                  })\n                  .join(',')\n              )\n          );\n          break;\n\n        case 'limit':\n        // limit: number\n        /* eslint-disable-next-line no-fallthrough */\n        case 'offset':\n          // offset: number\n          var parsedNum = parseInt(value);\n          if (!isNaN(parsedNum)) {\n            keys.push(key + '=' + parsedNum);\n          }\n          break;\n\n        case 'session_id':\n          keys.push(\n            'session_id=' + encodeURIComponent(JSON.stringify(value))\n          );\n          break;\n\n        case 'meta_data':\n        case 'args':\n        case 'exclude':\n        case 'include':\n          keys.push(key + '=' + encodeURIComponent(JSON.stringify(value)));\n          break;\n        default:\n          console.log('query_options: could not find key', key, value);\n      }\n    }\n  }\n\n  // Return the query string by joining the array with &'s\n  return keys.length ? '?' + keys.join('&') : '?';\n}\n
\\xa0bf816ad90a330710aebf4399b19a8f00b8c5d895e6f244813a5d660a10d695	meta-row
\\xa169062879c4114a7d7c9b08454c2ad658b7204562436a974b06d947f0ad9f73	bundle-contents
\\xa3051855d8a60f842cc6291f9b7ab68883b0646c50284eb694fa4d2fdb4b0b02	bb855424-53c5-48fb-9cb3-390eb4c6d155
\\xa3c35b57eac810a4a42f5eb77dccd82e19ff1d2f98daa1d85c1dc18a530b38f0	widget/component
\\xa3c874653c6f634a42ad0085aaf5d1c7500fc5da9b575b7f0af112bc7fe6e967	import { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\nimport db from '/org.aquameta.core.widget/0.3.1/widget.module/datum.js';\n\nexport default define(\n    import.meta,\n    class SemanticWidget extends Widget.LightElement {\n        static purpose = Widget.Attr;\n        static bundle = Widget.Attr;\n        static rowId = Widget.Prop;\n        static row = Widget.Prop;\n        static fieldId = Widget.Prop;\n        static field = Widget.Prop;\n        static bundles = Widget.Prop;\n\n        onWidgetConnected() {\n            // TODO: Best case would be to have these widgets stored on the row object\n            //  but then datum would need to subscribe to semantics so we don't use old mappings\n\n            // TODO: Another option would be to load all semantics ahead of time for quicklookups\n            //  then with events, the cache can be busted when semantics change\n            const bundles = [];\n            if (this.bundle) {\n                bundles.push(this.bundle);      }\n            const parent = this.widgetMetadata.parent;\n            if (parent) {\n                bundles.push(parent.widgetMetadata.bundleName);\n            }\n            bundles.push('org.aquameta.ui.bundle');\n            this.bundles = bundles;\n        }\n\n        onWidgetUpdate(prop, _oldValue, newValue) {\n            switch (prop) {\n                case 'rowId': {\n                    const relationId = {\n                      name: newValue.relation_name,\n                      schema_name: newValue.schema_name,\n                    };\n                    Promise.all([\n                        db.rowIdToRow(newValue),\n                        this.getRelationWidget(relationId, this.purpose),\n                    ])\n                        .then(([row, widget]) => {\n                            this._row = row;\n                            this.createWidget(widget);\n                        });\n                    break;\n                }\n                case 'row': {\n                    this._row = newValue;\n                    const relationId = newValue.relation.id;\n                    this.getRelationWidget(relationId, this.purpose)\n                        .then(widget => {\n                            this.createWidget(widget);\n                        });\n                    break;\n                }\n                case 'fieldId': {\n                    const columnId = newValue.column_id;\n                    Promise.all([\n                        db.rowIdToRow(newValue.id.row_id),\n                        this.getColumnWidget(columnId, this.purpose),\n                    ])\n                        .then(([row, widget]) => {\n                            // TODO: This should be row.field(columnId.name) - so we can use field metadata\n                            this._field = row.get(columnId.name);\n                            this.createWidget(widget);\n                        });\n                    break;\n                }\n                case 'field': {\n                    this._field = newValue;\n                    const columnId = newValu.column.id;\n                    this.getColumnWidget(columnId, this.purpose)\n                        .then(widget => {\n                            this.createWidget(widget);\n                        });\n                    break;\n                }\n            }\n        }\n\n        async getRelationWidget(relationId, purpose) {\n            let widget = null;\n            if (this.bundles.length) {\n                // TODO: semantic.relation_widget should return bundleName and widgetName so browser can import them\n                // TODO: it should also 404 when the widget does not exist, we can create fallback on client side\n                try {\n                    const rowWidget = await db.schema('semantics').function({\n                        name: 'row_component',\n                        parameters: ['meta.relation_id', 'text', 'pg_catalog._text'],\n                    },\n                        {\n                            relation_id: relationId,\n                            purpose: purpose,\n                            bundles: `{${this.bundles.join(',')}}`,\n                            // bundles, // ?\n                            // bundles: JSON.stringify(bundles), // ?\n                        },\n                        {\n                            use_cache: true,\n                            meta_data: false\n                        });\n                    if (rowWidget) {\n                        widget = rowWidget.get('row_component');\n                    }\n                } catch (e) {} // It's okay if there's no semantics configured\n            }\n            if (!widget) {\n                // TODO: core component library bundle\n                widget = {\n                    bundleName: 'org.aquameta.ui.bundle',\n                    name: `core-row-${purpose}`,\n                };\n            }\n            this.bundle = widget.bundleName;\n            await import(`/${widget.bundleName}/widget.component/${widget.name}.js`);\n            return widget;\n        }\n\n        async getColumnWidget(columnId, purpose) {\n            let widget = null;\n            if (this.bundles.length) {\n                try {\n                    const fieldWidget = await db.schema('semantics').function({\n                        name: 'field_widget',\n                        parameters: ['meta.column_id', 'text', 'pg_catalog._text'],\n                    },\n                        {\n                            column_id: columnId,\n                            purpose: purpose,\n                            bundles: this.bundles,\n                        },\n                        {\n                            use_cache: true,\n                            meta_data: false\n                        });\n                    if (fieldWidget) {\n                        widget = fieldWidget.get('field_widget');\n                    }\n                } catch (e) {} // It's okay if there's no semantics configured\n            }\n            if (!widget) {\n                widget = {\n                    bundleName: 'org.aquameta.ui.bundle',\n                    name: `core-field-${purpose}`,\n                };\n            }\n            this.bundle = widget.bundleName;\n            await import(`/${widget.bundleName}/widget.component/${widget.name}.js`)\n            return widget;\n        }\n        \n        createWidget(widget) {\n            const element = document.createElement(widget.name);\n            this.appendChild(element);\n            if (this._row) {\n                element.row = this._row;\n            } else if (this._field) {\n                element.field = this._field;\n            }\n        }\n    }\n);\n
\\xa42e4dc6df3d5cdd8426269e69872016057284f89a650977e8bd205b4d2d7757	pill-form
\\xa603cb247bed1c6bb88138ce1b29d65a3217b02759d429f8910991957e71d9d3	:host {\n    display: flex;\n    flex-direction: column;\n}\n\n#tab-contents {\n    height: 0;\n    flex: 1;\n}\n
\\xa6a19429f2f40bd7e20c9026e45c02b7b1211a605cd3c6fe8fb505afe6921b7d	/modules
\\xa6c93d57c8a83c6128739a307cdd6fcb6065092bfe366ac9b493d12a7840a54a	ea854990-9dcc-4496-bd0d-c414a49a1154
\\xa6db6250c7077349914efe33cc4404e3a543626d20f4801ac063b1a35a955b1a	widget/dependency_js
\\xa7ea5ef51c07e04145d9fefa387310b450c99d6cd01ec3e494efb0d65b9a71b2	endpoint/resource
\\xa8520ec1f2e06e7e127ee4b22ca269f9ed21954f91cbd2349e6bef015f7bb914	@import url(/com.mickey.ui/widget.module/material-icons.css);\n\n/* hide until the material-icons module is loaded */\n.material-icons {\n    display: none;\n    font-size: inherit;\n    vertical-align: middle;\n}
\\xa8ae5aa90a94d908fc7ab35b18702a301e9378f83386f49d4b1dc63c0502a34f	<div id="{{= id }}" class="{{= name }}">\n</div>
\\xa9140a7db5a1bdc64b5062c0cff5aec9c8fa00118506d00621c0013d7a99b357	import { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\n\nexport default define(\n    import.meta,\n    class StaticEventTabs extends Widget.Element {\n        static activated = Widget.Event;\n\n        onWidgetConnected() {\n            for (const tab of this.querySelectorAll('static-event-tab')) {\n                this.addListener(tab.activated, this.activated.dispatch);\n            }\n        }\n    }\n)
\\xaaf6ee124d60f7ebb7a5cf73bb73b7c78a69c849d096919ad08dfd4b2324ba81	semantics/relation_component
\\xaca3221c80313b53c2c948ec79feb75339ed81b8277d0da7234986162e7b682e	meta-field
\\xad44929be243235f26fe1f9ece07575fc54942d19d849ca864d3677e36d86e48	ca248b74-815c-440a-b216-716df835b269
\\xad9f58e39d308a448c033f2eb4bb8f14b1bdbdef415ada02159e7211539559cc	widget/get_component/{text,text,text}
\\xadd9a7d05a638d88163162117d572d69725fbd67f96abb2c8daf72a6ffdd09a1	3d905ea7-1e9e-4ea7-9b0b-5e30dd5dd2ec
\\xaeafc0275bc64bd883e673b8bd2b825409dd725924b01b0cea825af5e1ee8d4c	widget-element
\\xaec2438939df9f1a98deb985f6eb299914e53d8bccb802b5a258ab1955d156e2	import db from '/org.aquameta.core.widget/0.3.1/widget.module/datum.js';\n\nlet promise;\nconst names = new Map();\n\nasync function getPurpose(id) {\n    if (!promise) {\n        promise = db.schema('semantics').relation('column_purpose').rows()\n            .then(rows => {\n                const purposes = rows.map(i => i);\n                for (const purpose of purposes) {\n                    names.set(purpose.get('id'), purpose.get('purpose'));\n                }\n            })\n    }\n    await promise;\n    return names.get('id');\n}\n\nexport default async function(row) {\n    const purpose = await getPurpose(row.get('purpose_id'));\n    const colId = row.get('column_id');\n    return `${purpose} ${colId.schema_name}.${colId.relation_name}:${colId.name}`\n}
\\xaf0d11dcf9cfeccd00f1e003d033b176b8c02cd0e4e5160290ac7674c9aea141	import {Row} from './row.js';\nimport {Column} from './column.js';\nimport {Field} from './field.js';\nimport {Callbacks} from './util.js';\n\nfunction rowId(relId, pkValue) {\n    return {\n        url() {\n            return (\n                '/row/' + relId.schema_id.name + '/' + relId.name + '/' + pkValue\n            );\n        },\n    };\n}\n\nexport class Rowset {\n    constructor(relation, response, server_arguments) {\n        this.relation = relation;\n        this.schema = relation.schema;\n        this.columns = response.columns || null;\n        this.pk_column_name = response.pk || null;\n        this.rows = response.result;\n        this.length = response.result.length;\n        this.server_arguments = server_arguments || {};\n        this.callbacks = new Callbacks();\n    }\n    map(fn) {\n        return this.rows\n            .map(\n                function (row) {\n                    return new Row(this.relation, {\n                        columns: this.columns,\n                        pk: this.pk_column_name,\n                        result: [row],\n                    });\n                }.bind(this)\n            )\n            .map(fn);\n    }\n    forEach(fn) {\n        const newRow = (row) => {\n            return new Row(this.relation, {\n                columns: this.columns,\n                pk: this.pk_column_name,\n                result: [row],\n            });\n        };\n        this.onInsert(fn);\n        this.rows.map(newRow).forEach(fn);\n        return this;\n    }\n    reload() {\n        return this.relation.rows(this.server_arguments);\n    }\n    _triggerEvent(eventType, payload, newRowId) {\n        const relId = this.relation.id;\n        const pkColumn = this.pk_column_name;\n        const rowIdStr = rowId(\n            newRowId.pk_column_id.relation_id,\n            newRowId.pk_value\n        ).url();\n        // TODO: need a rewrite on datum to fix this\n        // imitate api response to create row\n        const newRow = (row, pk) => {\n            return new Row(this.relation, {\n                columns: this.columns,\n                pk: pk || this.pk_column_name,\n                result: [row],\n            });\n        };\n        switch (eventType) {\n            case 'insert': {\n                const completeRow = { row: payload };\n                this.rows.push(completeRow);\n                payload = newRow(completeRow);\n                break;\n            }\n            case 'update': {\n                // TODO: I think payload is only the update fields, may need to reconstruct real row\n                let index = this.rows.findIndex(\n                    ({ row }) => rowId(relId, row[pkColumn]).url() === rowIdStr\n                );\n                if (index < 0) {\n                    console.error(\n                        'Rowset: trying to trigger update on nonexistant row'\n                    );\n                    break;\n                }\n                const completeRow = { row: { ...this.rows[index].row, ...payload } };\n                this.rows[index] = completeRow;\n                payload = newRow(completeRow, pkColumn);\n                break;\n            }\n            case 'delete': {\n                // TODO: I think payload is only the row_id, may need to reconstruct real row\n                let index = this.rows.findIndex(\n                    (row) => rowId(relId, row[pkColumn]).url() === rowIdStr\n                );\n                if (!index) {\n                    console.error(\n                        'Rowset: trying to trigger delete on nonexistant row'\n                    );\n                    break;\n                }\n                this.rows.splice(index, 1);\n                payload = rowIdStr;\n                break;\n            }\n        }\n        this.callbacks.call(eventType, payload);\n    }\n    onInsert(fn) {\n        // TODO: maybe get rid of string\n        this.callbacks.add('insert', fn);\n    }\n    onUpdate(fn) {\n        // TODO: can you update a rowset?\n        this.callbacks.add('update', fn);\n    }\n    onDelete(fn) {\n        this.callbacks.add('delete', fn);\n    }\n\n    /**\n      * Call Rowset.where with (where_obj) or use shorthand notation (field, value) - filter results programmatically\n      *\n      * @param {Object} where_obj\n      * @param {[Boolean]} return_first\n      * @param {[Boolean]} async\n      *\n      * OR\n      *\n      * @param {String} field\n      * @param {Any} value\n      * @param {[Boolean]} return_first\n      * @param {[Boolean]} async\n      *\n      * @returns {Promise}\n      */\n    where() {\n        var first = false,\n            async = true,\n            where_obj = {};\n        if (typeof arguments[0] == 'object') {\n            // Rowset.where(where_obj [, return_first] [, async]);\n            where_obj = arguments[0];\n            var field = where_obj.field;\n            var value = where_obj.value;\n            if (arguments.length > 1) first = arguments[1];\n            if (arguments.length > 2) async = arguments[2];\n        } else if (typeof arguments[0] == 'string' && arguments.length > 1) {\n            // Rowset.where(field, value [, return_first] [, async]);\n            var field = arguments[0];\n            var value = arguments[1];\n            if (arguments.length > 2) first = arguments[2];\n            if (arguments.length > 3) async = arguments[3];\n        }\n\n        return new Promise(\n            function (resolve, reject) {\n                // TODO lots of logic here\n                // The new rowset that is returned must be in the same format as the response from the server\n\n                if (first) {\n                    for (var i = 0; i < this.rows.length; i++) {\n                        if (this.rows[i].row[field] == value) {\n                            resolve(\n                                new Row(this.relation, {\n                                    columns: this.columns,\n                                    result: [this.rows[i]],\n                                })\n                            );\n                        }\n                    }\n                    reject('could not find ' + field + ' ' + value);\n                } else {\n                    var return_rowset = [];\n                    for (var i = 0; i < this.rows.length; i++) {\n                        if (this.rows[i].row[field] == value) {\n                            return_rowset.push(this.rows[i]);\n                        }\n                    }\n                    resolve(\n                        new Rowset(this.relation, {\n                            columns: this.columns,\n                            result: return_rowset,\n                        })\n                    );\n                }\n\n                // 2\n\n                // maybe we don't need to search the entire row and instead we return the first item found\n                /*\n                    var new_rowset = _.filter(this.rows, function(el) {\n                        //return equals.call(this, el[field], val);\n                    });\n          */\n                if (new_rowset.length == 1) {\n                    return new Row(this.relation, new_rowset);\n                } else if (new_rowset.length > 1) {\n                    throw 'Multiple Rows Returned';\n                }\n\n                // if row does not exist\n                return null;\n            }.bind(this)\n        );\n    }\n    order_by(column, direction) {\n        /*\n            var ordered = _.sortBy(this.rows, function(el) {\n                return el.row[column];\n            });\n      */\n        if (direction !== 'asc') {\n            ordered.reverse();\n        }\n        return new Rowset(this.relation, {\n            columns: this.columns,\n            result: ordered,\n        });\n    }\n    limit(lim) {\n        if (lim <= 0) {\n            throw 'Bad limit';\n        }\n        return new Rowset(this.relation, {\n            columns: this.columns,\n            result: this.rows.slice(0, lim),\n        });\n    }\n    related_rows(\n        self_column_name,\n        related_relation_name,\n        related_column_name,\n        options\n    ) {\n        var relation_parts = related_relation_name.split('.');\n        if (relation_parts.length < 2) {\n            console.error(\n                'Related relation name must be schema qualified (schema_name.relation_name)'\n            );\n            // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n        }\n\n        var schema_name = relation_parts[0];\n        var relation_name = relation_parts[1];\n        var db = this.relation.schema.database;\n\n        var values = this.map(function (row) {\n            return row.get(self_column_name);\n        });\n\n        options = options || {};\n        options.where =\n            options.where instanceof Array\n                ? options.where\n                : typeof options.where == 'undefined'\n                    ? []\n                    : [options.where];\n        options.where.push({\n            name: related_column_name,\n            op: 'in',\n            value: values,\n        });\n\n        return db.schema(schema_name).relation(relation_name).rows(options);\n    }\n    related_row(\n        self_column_name,\n        related_relation_name,\n        related_column_name,\n        options\n    ) {\n        var relation_parts = related_relation_name.split('.');\n        if (relation_parts.length < 2) {\n            console.error(\n                'Related relation name must be schema qualified (schema_name.relation_name)'\n            );\n            // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n        }\n\n        var schema_name = relation_parts[0];\n        var relation_name = relation_parts[1];\n        var db = this.relation.schema.database;\n\n        var values = this.map(function (row) {\n            return row.get(self_column_name);\n        });\n\n        options = options || {};\n        options.where =\n            options.where instanceof Array\n                ? options.where\n                : typeof options.where == 'undefined'\n                    ? []\n                    : [options.where];\n        options.where.push({\n            name: related_column_name,\n            op: 'in',\n            value: values,\n        });\n\n        return db.schema(schema_name).relation(relation_name).row(options);\n    }\n}\n
\\xaf93afe8678566fba05a114e422bf6db9392bd80eb8f7c6207f5c92d7f8ddba6	ad4a5a8b-769e-4da1-8c80-d0db2327ff8f
\\xaf9987354098fdaf28fcd5ce3d4588e1137e5876fefc8ab79ba6c2a1e0290e94	8daa7039-0132-40ae-a247-d3ad7d682228
\\xb0696e208b298a6ab66d259fcdb67e839fd0e0266962e65cee300b3b827038a3	import { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\nimport db from '/org.aquameta.core.widget/0.3.1/widget.module/datum.js';\n\nexport default define(\n    import.meta,\n    class SemanticIdentifier extends Widget.LightElement {\n        static pattern = Widget.Attr;\n        static identifier = Widget.Prop;\n        static row = Widget.Prop;\n        static rowId = Widget.Prop;\n        static identifierChanged = Widget.Event.detail(this.identifier);\n\n        #promises;\n\n        onWidgetConnected() {\n            // Initialize promises immediately.\n        }\n\n        // TODO: It would be awesome if we could just query for all the reified rows in the bundle and the default metadata would have the bundle data (change_type, head_commit_id, etc.)\n        onWidgetUpdate(prop) {\n            switch (prop) {\n                case 'identifier':\n                    this.innerText = this.identifier;\n                    this.identifierChanged.dispatch();\n                    break;\n                case 'rowId':\n                    if (!this.#promises) {\n                        this.#promises = Promise.all([\n                            this.getIdentifierFunction(),\n                            this.getBundle(),\n                        ]);\n                    }\n                    db.rowIdToRow(this.rowId).then(row => {\n                        this.row = row;\n                    });\n                    break;\n                case 'row':\n                    if (!this.#promises) {\n                        this.#promises = Promise.all([\n                            this.getIdentifierFunction(),\n                            this.getBundle(),\n                        ]);\n                    }\n                    this.replacePattern();\n                    break;\n            }\n        }\n        async replacePattern() {\n            this.#promises.then(([semantics, bundle]) => {\n                const relId = this.getRowId().pk_column_id.relation_id;\n                this.identifier = this.pattern\n                    .replace('{id}', this.row ? semantics(this.row) : 'NULL')\n                    .replace('{relation}', `${relId.schema_id.name}.${relId.name}`)\n                    .replace('{bundle}', bundle || 'untracked');\n            });\n        }\n        async getBundle() {\n            // TODO: Best situation would be if bundle meta data was returned with the row from endpoint\n            if (!this.pattern.includes('{bundle}')) {\n                return null;\n            }\n            try {\n                const trackedRow = await db.schema('bundle').relation('tracked_row').row('row_id', this.getRowId());\n                if (!trackedRow) {\n                    return null;\n                }\n                const bundleId = trackedRow.get('bundle_id');\n                if (bundles.has(bundleId)) {\n                    return bundles.get(bundleId);\n                }\n                const bundleNamePromise = db.schema('bundle').relation('bundle').row('id', bundleId)\n                    .then(bundle => bundle.get('name'))\n                    .catch(e => {\n                        console.error(e);\n                        return null;\n                    });\n                bundles.set(bundleId, bundleNamePromise);\n                return bundleNamePromise;\n            } catch (e) {\n                console.error(e);\n                return null;\n            }\n        }\n        getRowId() {\n            if (this.row) {\n                return this.row.id;\n            } else {\n                return this.rowId;\n            }\n        }\n        async getIdentifierFunction() {\n            const rowId = this.getRowId();\n            const schema = rowId.pk_column_id.relation_id.schema_id.name;\n            const relation = rowId.pk_column_id.relation_id.name;\n            // TODO: Could hasIdentifier be a part of datum, so we don't have to get 404s in the console\n            // Don't need this round trip (even though its only once per table) if we have better metadata\n            try {\n                // TODO: with generated schema names, this would need to change to bundle.relation, not schema.relation\n                // This could be a far-reaching shift to bundle names instead of schema\n                const { default: semantics } = await import(\n                    `/semantics/${schema}.${relation}/identifier.js`\n                );\n                return semantics;\n            } catch (e) {\n                return defaultSemanticsIdentifier;\n            }\n        }\n    }\n)\n\nfunction defaultSemanticsIdentifier(row) {\n    return row.get('name') || row.get(row.pk_column_name || 'id');\n}
\\xb0d67086078866a6fe4e1570cf0ff8bba7b9bb80cac1b3ee1f3ebd743984923d	:host {\n  cursor: pointer;\n  display: inline-block;\n  padding: 5px;\n  margin-inline-end: 10px;\n}\n\n:host([is-active]) {\n  border-bottom: 1px solid red;\n}\n
\\xb0ee2b4dd42189fac4d7720b9897564015ead6a48badf9e52e31156863f28cc4	semantics/unique_identifier
\\xb107f8a64f337139abe1a6c7f6d908dd59819a1118b94ba1144bb19a68f4b564	2650a0b5-3b77-4cbf-b391-a25cb08d73a8
\\xb171e2f9bc648cfb258eb12d744cab50d40b3236804548722cf6dcbec6786ea1	a75f9f0e-790a-4bc0-8057-68ec2b980ae8
\\xb1d80b1ff06fc30078c7c66d2f8c4fe01dc08dec38a253ac3b188b4c494f1973	9e2e11cd-66e3-4220-88b6-8011d9d000b0
\\xb26695b490c72c5712725ed85e3d66e950776005c17245bfbb6191e57c7f2ced	<span></span>
\\xb34c9ee559c0e464d5ec32ca089bec29548e34eb1f1c6da9d6b24828890d3429	13aa89ca-03b6-44af-90b1-7d1541b8d1b1
\\xb3a296c965fa8afc1ccc063983867796977d5b9482836763a76397a4a0832486	9da9fc82-ab31-46bc-94ab-08bb1d49b5dd
\\xb49670424b05e7c107bee9820fe2866b1e8142177a7a0170e9552b4fd219a910	/resources
\\xb50b979d574af572d15d2c7b7f63b4472242f86194edf4bb8bb61f6455443389	core-row-display
\\xb5bea41b6c623f7c09f1bf24dcae58ebab3c0cdd90ad966bc43a45b44867e12b	true
\\xb5ef7237f6938814be371eeb0c433ecd488b461b69355638d456336dcceda99d	c1c6e912-4e51-4f7a-8ebf-fc2a26245b58
\\xb64f694f4f2bfbf71f8d186043d546fff8194e1209b07cf3198880cdf6a61af3	/${2}/widget.module/${3}.js
\\xb66f2eacff4e8d0ff18224150c28e6555557483acaf044b6aa26fdf0887f200c	import { register, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\n\nexport default register(\n    class CoreFieldEditable extends Widget.Element(import.meta) {\n        static row = Widget.Prop;\n    }\n);
\\xb6bf7bc8d96f3ea9d132c83b3da8e7760e420138485657372db4d6a981d3fd9e	endpoint
\\xb7dc7e92f56631ec73784e0cf393d155b98bfe12a8c1bce6156aa70fea0041d3	f7386353-9fbc-49ed-ac3d-0b0aee040887
\\xb8920dc566f46bf365f605d3b47a30e60e5e628a875c1dbf868df3eaab1cfac0	<code-code data-row="row"></core-code>
\\xb8b063a4ee774b43cccbf8d41232ec45f3b2f08ce67bb4b210fe50ca4e997e09	export function track(widgetName, instance) {\n  // console.log('track');\n}\n\nexport function untrack(instance) {\n  // console.log('untrack');\n}\n
\\xb8bdaf96dc5937c4127b21f6385e5af2bfa8ea167ce42f751e970be68446f5fa	semantics/unique_identifier/{text,text}
\\xb9004b82cbddeb262ff78bf37b5d1514f6cb971e303bbe2d34927cb82b5e593e	6facd62a-0402-4fb4-a0d3-445e9c84de67
\\xb96309c7ea67afd031350492c785a7b01c3c57e0673ff4f49b5e0a86b365dd82	677774e1-d51e-40d1-b239-7cea65bef1e2
\\xb96825034344112d407b9adbbcdad94b2c2e39252eb51d077218a984e39d6134	import { Relation, Table, View } from './relation.js';\nimport { Function, FunctionResult, FunctionResultSet } from './function.js';\n\nexport class Schema {\n    constructor(database, name) {\n        this.database = database;\n        this.name = name;\n        this.id = { name: this.name };\n    }\n    relation(name) {\n        return new Relation(this, name);\n    }\n    table(name) {\n        return new Table(this, name);\n    }\n    view(name) {\n        return new View(this, name);\n    }\n    function(identifier, args, options) {\n        /* Function identifier (name and parameter list) */\n        if (typeof identifier == 'object') {\n            var name = identifier.name;\n            var parameter_type_list = identifier.parameters;\n        }\n        /* Selecting a function without specifying the parameters */\n        else {\n            var name = identifier;\n        }\n\n        options = options || {};\n\n         /* Arguments */\n        options.args = {};\n\n        /* `args = undefined` will pass no arguments into the server-side function */\n        if (typeof args != 'undefined') {\n            /* some_function?args={ kwargs: {} } -- Key/value object */\n            if (!(args instanceof Array) && args instanceof Object) {\n                options.args.kwargs = args;\n            }\n            /* some_function?args={ vals: [] } -- Array */\n            else {\n                if (!(args instanceof Array)) {\n                    /* Regular value is placed into array */\n                    args = [args];\n                }\n                options.args.vals = args;\n            }\n        }\n\n        var fn = new Function(this, name, parameter_type_list);\n\n        return this.database.endpoint\n            .get(fn, options)\n            .then(\n                function (response) {\n                    if (!response) {\n                        throw 'Empty response';\n                    } else if (!response.result.length) {\n                      // it may be okay for result to be empty in some scenarios\n                      throw 'Result set empty';\n                    }\n                    if (response.result.length != 1) {\n                        return new FunctionResultSet(fn, response);\n                    }\n                    const fr = new FunctionResult(fn, response);\n                  return fr;\n                }\n            )\n            .catch(function (err) {\n                throw err;\n            });\n    }\n}\n
\\xbbd0d86b8d634598b9155946b3032a11bd94c7435c79fb2462d935e750d75570	858ef709-9aca-4c69-a715-04bb49726b67
\\xbcf9ade3917d640437ca5f581308ef2f5ea57d636ba99490b69a8dcdec0c65ca	import { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\nimport db from '/org.aquameta.core.widget/0.3.1/widget.module/datum.js';\nimport coreFieldEditCode from './core-field-edit-code.js';\nimport staticTabs from './static-tabs.js';\nimport { ComponentStorage } from '../widget.module/component-storage.js';\n\nexport default define(\n    import.meta,\n    class CoreCode extends Widget.Element {\n        static $ = {\n            editor: Widget.Deferred('#editor-container'),\n            tabs: Widget.Deferred('#tabs-container'),\n            useVim: '#use-vim',\n        };\n\n        static activeTab = Widget.Prop.initial(0);\n        static status = Widget.Attr.initial('init');\n        static hasUnsavedChanges = Widget.Attr.initial(false);\n\n        static lastSaved = Widget.Prop.initial(null);\n        static observer = Widget.Prop;\n        static request = Widget.Prop;\n        static row = Widget.Prop;\n        static useVim = Widget.Prop.initial(true);\n\n        #editorConfig = {};\n        #storage = new ComponentStorage(this);\n\n        onWidgetConnected() {\n            this.addListener(this.$.useVim, 'change', this.#toggleVim);\n            this.addListener(this.#storage, 'storage', this.#onStorageChange);\n            this.#onStorageChange();\n        }\n\n        #onStorageChange(data) {\n            const useVim = this.#storage.get('useVim');\n            this.useVim = typeof useVim === 'undefined' ? true : useVim;\n        }\n\n        onWidgetDisconnected() {\n            if (this.hasUnsavedChanges) {\n                const answer = confirm('This row has unsaved changes. Would you like to save before closing?\\n\\nSelect cancel to discard changes.');\n                if (answer) {\n                    // TODO: unfortunately, nowhere to put the error message if this fails\n                    this.saveRow();\n                }\n            }\n        }\n\n        onWidgetUpdate(prop) {\n            switch (prop) {\n                case 'row':\n                    this.#destroyEditors();\n                    this.#createEditors(getDefaultColumns(this.row));\n                    break;\n                case 'request':\n                    this.request.then(row => {\n                        this.row = row;\n                    })\n                    break;\n                case 'useVim':\n                    if (this.$.editor) {\n                        this.$.editor.useVim = this.useVim;\n                    }\n                    if (this.$.tabs) {\n                        for (const editor of this.$.tabs.tabContents) {\n                            editor.useVim = this.useVim;\n                        }\n                    }\n                    this.#storage.set('useVim', this.useVim);\n                    break;\n                case 'activeTab':\n                    if (this.$.tabs) {\n                        this.$.tabs.activeTab = this.activeTab;\n                    }\n                    break;\n                case 'hasUnsavedChanges':\n                    if (this.hasUnsavedChanges) {\n                        this.addListener(window, 'beforeunload', this.onBeforeUnload);\n                    } else {\n                        this.removeListener(window, 'beforeunload');\n                    }\n                    break;\n            }\n        }\n\n        onBeforeUnload(e) {\n            if (this.hasUnsavedChanges) {\n                e.preventDefault();\n            }\n        }\n\n        #toggleVim(e) {\n            this.useVim = this.$.useVim.checked;\n        }\n\n        #createEditors(columns) {\n            if (columns.length === 1) {\n                this.$.editor = this.#createEditor(columns[0]);\n            } else {\n                const tabs = [];\n                for (const column of columns) {\n                    const editor = this.#createEditor(column, true);\n                    tabs.push({\n                        label: column,\n                        content: editor,\n                    });\n                }\n                this.$.tabs = this.#createStaticTabs(tabs);\n            }\n        }\n\n        #createEditor(column, tabs = false) {\n            const editor = coreFieldEditCode({\n                field: this.row.field(column),\n                type: negotiateFileType(this.row, column),\n                useVim: this.useVim,\n            });\n            this.addListener(editor.change, this.fieldChanged);\n            this.addListener(editor.save, this.saveRow);\n            if (tabs) {\n                this.addListener(editor.nextTab, this.nextTab);\n                this.addListener(editor.previousTab, this.previousTab);\n            }\n            return editor;\n        }\n\n        #createStaticTabs(tabs) {\n            const staticTabEl = staticTabs({ tabs, activeTab: this.activeTab })\n            this.addListener(staticTabEl.tabActivated, this.tabActivated);\n            return staticTabEl;\n        }\n\n        #destroyEditors() {\n            this.$.editor = null;\n            this.$.tabs = null;\n        }\n\n        tabActivated(e) {\n            this.activeTab = e.detail.tabIndex;\n         }\n\n        fieldChanged() {\n            // this.$.editor is defined since this event callback is called from the editor\n            if (this.$.editor) {\n                this.hasUnsavedChanges = this.$.editor.hasUnsavedChanges;\n            }\n            if (this.$.tabs) {\n                for (const editor of this.$.tabs.tabContents) {\n                    if (editor.hasUnsavedChanges) {\n                        this.hasUnsavedChanges = true;\n                        return;\n                    }\n                }\n                this.hasUnsavedChanges = false;\n            }\n        }\n\n        async saveRow() {\n            // core-field-edit-code should call this.field.set instead\n            if (this.$.editor) {\n                this.row.set(this.$.editor.field.name, this.$.editor.value);\n            } else if (this.$.tabs) {\n                for (const editor of this.$.tabs.tabContents) {\n                    this.row.set(editor.field.name, editor.value);\n                }\n            }\n            try {\n                if (this.row) {\n                    await this.row.update();\n                } else if (this.field) {\n                    await this.field.update();\n                }\n                this.status = 'saved';\n                this.lastSaved = new Date().toLocaleString();\n                this.hasUnsavedChanges = false;\n            } catch (e) {\n                this.status = 'error';\n                console.error(e);\n            }\n        }\n\n        nextTab() {\n            this.activeTab = Math.min(this.activeTab + 1, this.$.tabs.tabContents.length - 1);\n        }\n\n        previousTab() {\n            this.activeTab = Math.max(0, this.activeTab - 1);\n        }\n    }\n);\n\nfunction negotiateFileType(row, column) {\n    const relation = `${row.schema.name}.${row.relation.name}`;\n    if (column === 'content' && relation === 'endpoint.resource') {\n        const resourcePath = row.get('path');\n        if (resourcePath && resourcePath.includes('.')) {\n            if (resourcePath.endsWith('.js.map')) {\n                return 'json';\n            }\n            if (resourcePath.endsWith('.sql')) {\n                return 'pgsql';\n            }\n        }\n        const mimetype = getMimetype(row, column);\n        switch (mimetype) {\n            case null:\n                break;\n            case 'text/html':\n                return 'html';\n            case 'text/css':\n                return 'css';\n            case 'application/javascript':\n            case 'text/javascript':\n                return 'javascript';\n            case 'text/plain':\n            case 'text/richtext':\n                return 'text';\n        }\n    } else if (column === 'content' && relation === 'documentation.bundle_doc') {\n        return 'markdown';\n    } else if (column === 'content' && relation === 'widget.dependency_js') {\n        return 'javascript';\n    } else if (column === 'content' && relation === 'widget.dependency_css') {\n        return 'css';\n    } else if (column === 'content' && relation === 'widget.module') {\n        const rowType = row.get('type');\n        if (rowType === 'js') {\n            return 'javascript';\n        }\n        return rowType;\n    }\n    switch (column) {\n        case 'html':\n        case 'css':\n            return column;\n        case 'post_js':\n        case 'js':\n            return 'javascript';\n        case 'sql':\n        case 'pgsql':\n            return 'pgsql';\n        case 'md':\n        case 'markdown':\n            return 'markdown';\n        case 'text':\n            return 'text';\n        case 'help':\n            return 'markdown';\n    }\n    return 'text';\n}\n\n// TODO: load mimetypes in more robust way\nlet mimetypes = [];\ndb.schema('endpoint').table('mimetype').rows().then(rows => mimetypes = rows.map(i => i));\nfunction getMimetype(row, column) {\n    const mimetypeId = row.get('mimetype_id');\n    if (mimetypeId) {\n        const mimetypeRow = mimetypes.find(m => m.get('id') === mimetypeId);\n        if (mimetypeRow) {\n            return mimetypeRow.get('mimetype');\n        }\n    }\n    return null;\n}\n\n// TODO: Remove this by dropping extra widget columns\nfunction getDefaultColumns(row) {\n    const rel = row.relation;\n    const cols = row.columns.map(c => c.name);\n    const relName = `${rel.schema.name}.${rel.name}`;\n    switch (relName) {\n        case 'widget.widget':\n            return ['html', 'css', 'post_js', 'help'];\n        case 'endpoint.resource':\n            return ['path', 'content'];\n        case 'widget.dependency_js':\n        case 'widget.dependency_css':\n            return ['version', 'content'];\n        case 'widget.component':\n            return ['html', 'css', 'js', 'help'];\n        case 'widget.module':\n            return ['content'];\n        case 'documentation.bundle_doc':\n            return ['title', 'content'];\n    }\n    return cols;\n}
\\xbdb77a323ada929a15dcc8402a846ca0b083f024f9b2062e995d72cad6aa4854	import { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\nimport { MetaComponentHelper } from '/com.mickey.ui/1.0.0/widget.module/meta-component-helper.js';\n\nexport default define(\n    import.meta,\n    class MetaField extends Widget.LightElement {\n        // static html = Widget.Prop;\n        static hasContent = Widget.Prop;\n        static column = Widget.Attr;\n        static columns = Widget.Attr;\n        static field = Widget.Prop;\n        static fields = Widget.Prop;\n\n        meta = new MetaComponentHelper(this, null, 'meta-field');\n\n        onWidgetConnected() {\n            this.meta.init({ remove: false });\n            this.hasContent = this.innerHTML.trim() !== '';\n        }\n\n        onWidgetUpdate(prop, _oldValue, newValue) {\n            if (prop === 'field') {\n                if (!this.hasContent) {\n                    this.innerText = newValue;\n                }\n                /*\n                if (this.html) {\n                    if (!this.column) {\n                        // this will never happen because meta-row will never pass a field to this element\n                        console.error('meta-field must have `column` attribute')\n                        return;\n                    }\n                    const column = this.column.trim();\n                    if (this.html.includes(`{${column}}`)) {\n                        this.innerHTML = this.html.replaceAll(`{${column}}`, newValue);\n                    }\n                } else {\n                    // meta-field with one column can also be a self-closing tag with no inner html\n                    this.innerText = newValue;\n                }\n                */\n\n                this.meta.childAttributes.forEach(node => {\n                    node.element[node.property] = newValue;\n                });\n            } else if (prop === 'fields') {\n                if (!this.hasContent) {\n                    console.error('meta-field with multiple columns must have inner html');\n                    return;\n                }\n\n                if (!this.columns) {\n                    // this will never happen because meta-row will never pass a  field to this element\n                    console.error('meta-field must have `columns` attribute')\n                    return;\n                }\n\n                const columns = this.columns.split(',').map(i => i.trim());\n                /*\n                let html = this.html;\n                for (const column of columns) {\n                    html = html.replaceAll(`{${column}}`, values[column]);\n                }\n                this.innerHTML = html;\n                */\n\n                const fieldData = columns.map(col => newValue[col]);\n                this.meta.childAttributes.forEach(node => {\n                    node.element[node.property] = fieldData;\n                });\n            }\n        }\n    }\n);
\\xbdfdc6c4431320b1089ddbd943b6a468556443e33cc4d7b98d7275a7b2905b0d	6c7eca8c-92bf-4274-9a24-9dea6be4b989
\\xbeecded4f623ef59c53b5b4c9e7efefc9ce150b95aa4be24a011ea15ee143a8e	/${2}/widget.component/${3}.js
\\xc00f32d87b6aa9aa90eaed5eded194f9862653ae1e23236c2b3d4f176ba71f55	import { Endpoint } from './endpoint.js';\nimport { Schema } from './schema.js';\n\nexport class Database {\n    constructor(url, settings) {\n        this.settings = settings;\n\n        if (typeof this.settings.evented === 'string') {\n            console.warn(\n                'Database: `evented` setting has been deprecated. Use `events=true|false` instead'\n            );\n            delete this.settings.evented;\n        }\n\n        this.settings.events = Object.hasOwn(this.settings, 'events')\n            ? this.settings.events\n            : false;\n        this.endpoint = new Endpoint(url, this, this.settings.events);\n        this.tracked = { relation: {}, row: {}, field: {} };\n\n        if (this.settings.events) {\n            this.schema('event')\n                .function('session_create')\n                .then(\n                    function (result) {\n                        const sessionId = result.get('session_create');\n                        if (sessionId) {\n                            this.endpoint.connectSession(sessionId);\n                            persistSessionId(sessionId);\n                        } else {\n                            console.log('got a null sessionId', sessionId);\n                        }\n                    }.bind(this)\n                );\n        }\n    }\n    schema(name) {\n        return new Schema(this, name);\n    }\n    rowIdToRow(rowId) {\n        const schema = rowId.pk_column_id.relation_id.schema_id.name;\n        const relation = rowId.pk_column_id.relation_id.name;\n        const pkColumn = rowId.pk_column_id.name;\n        const pkValue = rowId.pk_value;\n        if (!schema || !relation || !pkColumn || !pkValue) {\n            throw new Error('Database - rowIdToRow: invalid rowId')\n        }\n        return this.schema(schema).relation(relation).row(pkColumn, pkValue);\n    }\n    getTracked(id) {\n        let idType;\n        if (id.startsWith('/relation/')) {\n            idType = 'relation';\n        } else if (id.startsWith('/row/')) {\n            idType = 'row';\n        } else if (id.startsWith('/field/')) {\n            idType = 'field';\n        }\n        const tracked = this.tracked[idType][id];\n        if (!tracked) {\n            return [];\n        }\n        return tracked;\n    }\n    track(id, obj) {\n        // TODO: db.track should only be called when events are set up on this query\n        let idType;\n        if (id.startsWith('/relation/')) {\n            idType = 'relation';\n        } else if (id.startsWith('/row/')) {\n            idType = 'row';\n        } else if (id.startsWith('/field/')) {\n            idType = 'field';\n        }\n\n        // columns are supposed to have events, but what does that mean?\n        // functions do not have events\n        // schema do not have events\n\n        switch (idType) {\n            case 'relation':\n                this.tracked.relation[id] = this.tracked.relation[id] || [];\n                this.tracked.relation[id].push(obj);\n                break;\n            case 'row':\n                this.tracked.row[id] = obj;\n                break;\n            case 'field':\n                this.tracked.field[id] = obj;\n                break;\n        }\n    }\n}
\\xc05c0938c1ce9e546ff6a47bc29763fcc287f0b695a7f5734f749b2eed0ecf5e	core-field-editable
\\xc0d2856b74d0df05b9d4456b177950351bd88e98b77f12574dfb7a911acee0d0	field
\\xc137192c4bbb1a624aa69b06fe3ae10a0fb0e67aa0035fee0f7eff84494d4429	widget-collection
\\xc197f1244993f524f2553ae1622cf33d0164c872999ba22478127890a29caf92	/${2}/widget.component/${3}.css
\\xc34751dfc7132253880332c42c7b8d80f635afcdb5d3166960add466b334ace0	2e1dc3c8-752e-418c-8665-e737067db90f
\\xc357d46e099057aeb162c86d2c8f95b8e02cb717cc475339a60442efc8e8cbfa	/${2}/widget.component/${3}.html
\\xc379ea436f4b3171e5318a2754d362a93aabe631ac10f4678087a9c126b3b3e7	meta-rows
\\xc606297029857aa40ce4943b02645485071333ceea9f8e4fdb8bcea5845c34a7	1d0e9ab8-66c0-4ec9-b9c5-9788afdadabf
\\xc71a84214bfffb5b0d2d4ab7311d58cf44f5684f39e6525e22153c6004d7f1a1	416c2aa6-0d57-4660-af86-f6e9ede53735
\\xc7796a9bf59271be540140d056bfda02681dd59aaf10185d0b45e16fa94672ce	48594bf5-fe82-4aa9-9007-0850c4e0b3af
\\xc8631a70b4791775cba17dd1510a503863b56fc752f4e5871f3743305f5fe77c	c1fd1771-c8df-4c8a-8700-7d979db571f9
\\xc8a78362918b62597d293daddc42378e0546e029b61d2ec2b40edcf262638cbd	material-icons
\\xc986aec3c362cdaf32801b180355bd6007cf09778901e783a4e56e4a23fe4975	documentation/bundle_doc
\\xca42cdf8dfdeb425c37c70b8ad20291e3d1516e3e22a4ed84fcc6270e1a990a5	\nimport {Field} from './field.js';\nimport {Callbacks} from './util.js';\n\nexport class Row {\n    constructor(relation, response) {\n        this.relation = relation;\n        this.schema = relation.schema;\n        this.row_data = response.result[0].row;\n\n        this.callbacks = new Callbacks();\n        this.cached_fields = {};\n        this.columns = response.columns || null;\n        this.pk_column_name = null;\n        this.pk_value = null;\n        this.id = null;\n        this.to_url = function () {\n            console.error(\n                'You must call a row with "meta_data: true" in order to use the to_url function'\n            );\n            throw 'Datum.js: Programming Error';\n        };\n\n        if (typeof response.pk != 'undefined') {\n            this.pk_column_name = response.pk;\n            this.pk_value = this.get(this.pk_column_name);\n            // this.id = {"pk_column_id":{"relation_id":{"schema_id":{"name":this.schema.name},"name":this.relation.name},"name":this.pk_column_name},"pk_value": this.pk_value}\n            this.id = {\n                pk_column_id: {\n                    relation_id: this.relation.id,\n                    name: this.pk_column_name,\n                },\n                pk_value: this.pk_value,\n            };\n\n            this.to_url = function (id_only) {\n                return id_only\n                    ? '/row/' +\n                    this.relation.schema.name +\n                    '/' +\n                    this.relation.name +\n                    '/' +\n                    this.pk_column_name +\n                    '/' +\n            /*JSON.stringify(this.pk_value)*/ this.pk_value\n                    : this.relation.schema.database.endpoint.url +\n                    '/row/' +\n                    this.relation.schema.name +\n                    '/' +\n                    this.relation.name +\n                    '/' +\n                    this.pk_column_name +\n                    '/' +\n            /*JSON.stringify(this.pk_value)*/ this.pk_value;\n            };\n        }\n    }\n    get(name) {\n        return this.row_data[name];\n    }\n    set(name, value) {\n        this.row_data[name] = value;\n        return this;\n    }\n    to_string() {\n        return JSON.stringify(this.row_data);\n    }\n    clone() {\n        return new Row(this.relation, {\n            columns: this.columns,\n            pk: this.pk_column_name,\n            result: [{ row: this.row_data }],\n        });\n    }\n    field(name) {\n        if (typeof this.cached_fields[name] == 'undefined') {\n            this.cached_fields[name] = new Field(\n                this,\n                name,\n                name === this.pk_column_name\n            );\n        }\n        return this.cached_fields[name];\n    }\n    fields() {\n        if (this.columns != null) {\n            return this.columns.map(\n                function (c) {\n                    return this.field(c.name);\n                }.bind(this)\n            );\n        }\n        return null;\n    }\n    _triggerEvent(eventType, payload) {\n        switch (eventType) {\n            case 'update': {\n                // TODO: update fields\n                break;\n            }\n        }\n        this.callbacks.call(eventType, payload);\n    }\n    onUpdate(fn) {\n        this.callbacks.add('update', fn);\n    }\n    onDelete(fn) {\n        this.callbacks.add('delete', fn);\n    }\n    update() {\n        return this.relation.schema.database.endpoint\n            .patch(this, this.row_data)\n            .then(\n                function (response) {\n                    if (response == null) {\n                        throw 'Empty response';\n                    }\n                    return this;\n                }.bind(this)\n            )\n            .catch(function (err) {\n                throw 'Update failed: ' + err;\n            });\n    }\n    delete() {\n        return this.relation.schema.database.endpoint\n            .delete(this)\n            .then(function (response) {\n                if (response == null) {\n                    throw 'Empty response';\n                }\n            })\n            .catch(function (err) {\n                throw 'Delete failed: ' + err;\n            });\n    }\n    related_rows(\n        self_column_name,\n        related_relation_name,\n        related_column_name,\n        options\n    ) {\n        var relation_parts = related_relation_name.split('.');\n        if (relation_parts.length < 2) {\n            console.error(\n                'Related relation name must be schema qualified (schema_name.relation_name)'\n            );\n            // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n        }\n\n        var schema_name = relation_parts[0];\n        var relation_name = relation_parts[1];\n        var db = this.relation.schema.database;\n\n        options = options || {};\n        options.where =\n            options.where instanceof Array\n                ? options.where\n                : typeof options.where == 'undefined'\n                    ? []\n                    : [options.where];\n        options.where.push({\n            name: related_column_name,\n            op: '=',\n            value: this.get(self_column_name),\n        });\n\n        return db.schema(schema_name).relation(relation_name).rows(options);\n    }\n    related_row(\n        self_column_name,\n        related_relation_name,\n        related_column_name,\n        options\n    ) {\n        var relation_parts = related_relation_name.split('.');\n        if (relation_parts.length < 2) {\n            console.error(\n                'Related relation name must be schema qualified (schema_name.relation_name)'\n            );\n            // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n        }\n\n        var schema_name = relation_parts[0];\n        var relation_name = relation_parts[1];\n        var db = this.relation.schema.database;\n\n        options = options || {};\n        options.where =\n            options.where instanceof Array\n                ? options.where\n                : typeof options.where == 'undefined'\n                    ? []\n                    : [options.where];\n        options.where.push({\n            name: related_column_name,\n            op: '=',\n            value: this.get(self_column_name),\n        });\n\n        return db.schema(schema_name).relation(relation_name).row(options);\n    }\n}\n
\\xcab2c93ed3721b7e26b9f810d90088a84c2e7f090b0f3d92bb31dd40ac81cd8a	96650940-d145-472f-acd4-4b582c305144
\\xcb00f8f82d9ef6e1819431eb7ee500c942cc9a1549accdf7d91790d718df7b6a	<span id="container">\n    <span id="name" data-tab-name="innerText"></span>\n    <material-icon id="close" icon="close"></material-icon>\n</span>
\\xcb14ea7e22ad8fd9f459cc7a9d3c8a67fd10054bd71d3bab505ec300997256ea	export default function(row) {\\n\\treturn row.get("id");\\n}
\\xcb2c0b5c2b5e0323769c3add2b363016a5fad245e002a2c758304e333afdd95c	<!doctype html>\n<html>\n    <head>\n        <title>resource editor</title>\n        <base href="/com.mickey.ui/" />\n        <style>\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body>\n        <meta-relation $relation="endpoint.resource" $order="path">\n            <editor-app meta-relation="rows" table="endpoint.resource"></editor-app>\n        </meta-relation>\n    </body>\n    <script type="module" src="widget.component/editor-app.js"></script>\n    <script type="module" src="widget.component/meta-relation.js"></script>\n</html>
\\xcb870141b69350f7281cc13683201dd31efcf1fd39c3e3975eb9e34f95168cba	import { Rowset } from './rowset.js';\nimport { Row } from './row.js';\nimport { Column } from './column.js';\n\nfunction relationId(id) {\n    return {\n        url() {\n            return '/relation/' + id.schema_id.name + '/' + id.name;\n        },\n    };\n}\n\nexport class Relation {\n    constructor(schema, name) {\n        this.schema = schema;\n        this.name = name;\n        this.id = { schema_id: this.schema.id, name: this.name };\n    }\n    to_url(id_only) {\n        return id_only\n            ? '/relation/' + this.schema.name + '/' + this.name\n            : this.schema.database.endpoint.url +\n            '/relation/' +\n            this.schema.name +\n            '/' +\n            this.name;\n    }\n    column(name) {\n        return new Column(this, name);\n    }\n    // TODO: [idea] if order_by is used, maintain this in rowset.\n    //  - then we will redo the sort client side and ensure events are put in the right place by diffing the ordered rowset\n    rows(options) {\n        return this.schema.database.endpoint\n            .get(this, options)\n            .then(\n                function (rows) {\n                    if (rows == null) {\n                        throw 'Empty response';\n                    } /*\n              else if (rows.result.length < 1) {\n                  throw 'No rows returned';\n              }*/\n                    const rowset = new Rowset(this, rows, options);\n                    this.schema.database.track(this.to_url(true), rowset);\n                    return rowset;\n                }.bind(this)\n            )\n            .catch(function (err) {\n                throw 'Rows request failed: ' + err;\n            });\n    }\n    row() {\n        // TODO: minimize the number of ways to call row. this code is strange and complicated\n        //  - maybe it gets better with ide type definitions\n\n        // Multiple different ways to call 'row' function\n\n        // 1. Calling with Options object\n        if (typeof arguments[0] == 'object') {\n            var obj = arguments[0];\n            var args = arguments[1] || {};\n\n            // Relation.row({ where: { column_name: 'column_name', op: '=', value: 'value' } })\n            // Maybe it should be this one: Relation.row({ where: { column_name: value } })\n            if (typeof obj.where != 'undefined') {\n                args.where = obj.where;\n            }\n            // Relation.row({ column_name: 'column_name', op: '=', value: 'value' })\n            // Maybe it should be this one: Relation.row({ column_name: value })\n            else {\n                args.where = obj;\n            }\n        }\n        // 2. Calling with column_name and value\n        else if (typeof arguments[0] == 'string') {\n            // Relation.row(column_name, value [, options_obj])\n            var name = arguments[0];\n            var value = arguments[1];\n            var args = arguments[2] || {};\n\n            args.where = { name: name, op: '=', value: value };\n        }\n        // 3. Calling Relation.row() without arguments\n        else {\n            var args = {};\n        }\n\n        return this.schema.database.endpoint\n            .get(this, args)\n            .then(\n                function (row) {\n                    if (row == null) {\n                        throw 'Empty response';\n                    } else if (row.result.length == 0) {\n                        return null; // throw 'No row returned';\n                    } else if (row.result.length > 1) {\n                        throw 'Multiple rows returned';\n                    }\n                    const aqRow = new Row(this, row);\n                    this.schema.database.track(aqRow.to_url(true), aqRow);\n                    return aqRow;\n                }.bind(this)\n            )\n            .catch(function (err) {\n                throw 'Row request failed: ' + err;\n            });\n    }\n}\n\nexport class Table extends Relation {\n    insert(data) {\n        if (typeof data == 'undefined') {\n            // table.insert({}) is equivalent to table.insert()\n            // both will insert default values\n            data = {};\n        }\n\n        // Return inserted row promise\n        return this.schema.database.endpoint\n            .patch(this, data)\n            .then(\n                function (inserted_row) {\n                    if (inserted_row == null) {\n                        throw 'Empty response';\n                    }\n                    if (typeof data.length != 'undefined' && data.length > 1) {\n                        return new Rowset(this, inserted_row, null);\n                    }\n                    return new Row(this, inserted_row);\n                }.bind(this)\n            )\n            .catch(function (err) {\n                throw 'Insert failed: ' + err;\n            });\n    }\n}\n\nexport class View extends Relation {}\n
\\xcbdbf2271daefd7835248829e27d8cb35328729e8b449db57e7509e0db56ba48	\nimport { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\nimport db from '/org.aquameta.core.widget/0.3.1/widget.module/datum.js';\n\nexport default define(\n    import.meta,\n    class SemanticIdentifier extends Widget.LightElement {\n        static pattern = Widget.Attr;\n        static identifier = Widget.Prop;\n        static row = Widget.Prop;\n        static rowId = Widget.Prop;\n        static identifierChanged = Widget.Event.detail(this.identifier);\n\n        #promises;\n\n        onWidgetConnected() {\n            // Initialize promises immediately.\n        }\n\n        // TODO: It would be awesome if we could just query for all the reified rows in the bundle and the default metadata would have the bundle data (change_type, head_commit_id, etc.)\n        onWidgetUpdate(prop) {\n            switch (prop) {\n                case 'identifier':\n                    this.innerText = this.identifier;\n                    this.identifierChanged.dispatch();\n                    break;\n               case 'rowId':\n                    if (!this.#promises) {\n                        this.#promises = Promise.all([\n                            this.getIdentifierFunction(),\n                            this.getBundle(),\n                        ]);\n                    }\n                    db.rowIdToRow(this.rowId).then(row => {\n                        this.row = row;\n                    });\n                    break;\n                case 'row':\n                    if (!this.#promises) {\n                        this.#promises = Promise.all([\n                            this.getIdentifierFunction(),\n                            this.getBundle(),\n                        ]);\n                    }\n                    this.replacePattern();\n                    break;\n            }\n        }\n        async replacePattern() {\n            const [semantics, bundle] = await this.#promises;\n            const rowId = this.getRowId();\n            let relName, schemaName;\n            if ('pk_column_id' in rowId) {\n                relName = rowId.pk_column_id.relation_id.name;\n                schemaName = rowId.pk_column_id.relation_id.schema_id.name;\n            } else {\n                relName = rowId.relation_name;\n                schemaName = rowId.schema_name;\n            }\n            const id = await (this.row ? semantics(this.row) : 'NULL');\n            this.identifier = this.pattern\n                .replace('{id}', id)\n                .replace('{relation}', `${schemaName}.${relName}`)\n                .replace('{bundle}', bundle || 'untracked');\n        }\n        async getBundle() {\n            // TODO: Best situation would be if bundle meta data was returned with the row from endpoint\n            if (!this.pattern.includes('{bundle}')) {\n                return null;\n            }\n            try {\n                const trackedRow = await db.schema('bundle').relation('tracked_row').row('row_id', this.getRowId());\n                if (!trackedRow) {\n                    return null;\n                }\n                const bundleId = trackedRow.get('bundle_id');\n                if (bundles.has(bundleId)) {\n                    return bundles.get(bundleId);\n                }\n                const bundleNamePromise = db.schema('bundle').relation('bundle').row('id', bundleId)\n                    .then(bundle => bundle.get('name'))\n                    .catch(e => {\n                        console.error(e);\n                        return null;\n                    });\n                bundles.set(bundleId, bundleNamePromise);\n                return bundleNamePromise;\n            } catch (e) {\n                console.error(e);\n                return null;\n            }\n        }\n        getRowId() {\n            if (this.row) {\n                return this.row.id;\n            } else {\n                return this.rowId;\n            }\n        }\n        async getIdentifierFunction() {\n            const rowId = this.getRowId();\n            let relName, schemaName;\n            if ('pk_column_id' in rowId) {\n                relName = rowId.pk_column_id.relation_id.name;\n                schemaName = rowId.pk_column_id.relation_id.schema_id.name;\n            } else {\n                relName = rowId.relation_name;\n                schemaName = rowId.schema_name;\n            }\n            // TODO: Could hasIdentifier be a part of datum, so we don't have to get 404s in the console\n            // Don't need this round trip (even though its only once per table) if we have better metadata\n            try {\n                // TODO: with generated schema names, this would need to change to bundle.relation, not schema.relation\n                // This could be a far-reaching shift to bundle names instead of schema\n                const { default: semantics } = await import(\n                    `/semantics/${schemaName}/${relName}/identifier.js`\n                );\n                return semantics;\n            } catch (e) {\n                return defaultSemanticsIdentifier;\n            }\n        }\n    }\n)\n\nfunction defaultSemanticsIdentifier(row) {\n    return row.get('name') || row.get(row.pk_column_name || 'id');\n}\n\n
\\xcff807a48ccc35a0529b88ec739a19fd067463fcd35d95e2862a68f6c9a29fe6	:host {\n  display: flex;\n  flex-direction: column;\n}\n\n#tab-contents {\n  height: 0;\n  flex: 1;\n}\n\n#tab-contents static-tab-content {\n  height: 100%;\n}\n\n#tab-contents static-tab-content > * {\n  height: 100%;\n}
\\xd190c7b14c73d7db64c81da3ff7c41ae7803f8a342e192f4a513df4689963105	import { define, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\nimport { MetaComponentHelper } from '/com.mickey.ui/1.0.0/widget.module/meta-component-helper.js';\n\n// TODO: what about `bundle.bundle -> bundle.head_db_stage`\n// queries different endpoint function that automatically finds out the related column and does a left/right/outer/inner join (e.g. <-, ->, <->, >-<)\n// $join="<-" $related="bundle.bundle"\n\nlet idCounter = 0;\n\nexport default define(\n    import.meta,\n    class MetaRows extends Widget.LightElement {\n        // Not able to use Widget.Attr for everything because the names are dynamic\n        static metaRows = Widget.Prop;\n        static rows = Widget.Prop;\n        static added = Widget.Event;\n        static rowsHaveIdentifiers = Widget.Event;\n\n        /**\n         * TODO\n         * maybe we need a Widget.Collection here so we can keep track of meta-row for later\n         * such as when we call sort, we want to move them around\n         */ \n\n        meta = new MetaComponentHelper(this, 'meta-row', 'meta-rows');\n        #needsId = new Set;\n\n        onWidgetConnected() {\n            this.meta.init({ remove: true });\n        }\n\n        onWidgetUpdate(prop) {\n            if (prop === 'rows' && this.rows) {\n                this.meta.children.forEach(node => {\n                    node.parent.clear();\n                    for (const row of this.rows) {\n                        const clone = node.element.cloneNode(true);\n                        clone.row = row;\n                        let id = row.get('id');\n                        if (typeof id === 'undefined') {\n                            id = ++idCounter;\n                        }\n                        row.artificialId = id;\n                        this.#needsId.add(id);\n                        node.parent.set(id, clone);\n                        this.added.dispatch({ element: clone, row });\n                        this.addListener(clone.identifierSet, this.onRowIdentifierSet);\n                    }\n                });\n\n                this.meta.childAttributes.forEach(node => {\n                    node.element[node.property] = this.rows;\n                });\n            }\n        }\n\n        onRowIdentifierSet(e) {\n            this.#needsId.delete(e.detail.row.artificialId);\n            if (!this.#needsId.size) {\n                this.rowsHaveIdentifiers.dispatch();\n            }\n        }\n\n        // callback passed to events\n        onRowAdded(row) {\n            this.dispatchEvent(new CustomEvent('meta-row-added', {\n                detail: {\n                    metaRow,\n                    row,\n                },\n            }));\n        }\n        // callback passed to events\n        onRowUpdated(row) {\n            this.dispatchEvent(new CustomEvent('meta-row-updated', {\n                detail: {\n                    metaRow,\n                    row\n                },\n            }));\n        }\n        // callback passed to events\n        onRowDeleted(row) {\n            this.dispatchEvent(new CustomEvent('meta-row-deleted', {\n                detail: {\n                    metaRow,\n                    row\n                },\n            }));\n        }\n        // public api\n        reload() {\n            // request rows again\n        }\n        // public api\n        filter() {\n            // filter in-memory rows\n        }\n        sort(fn) {\n            // TODO: This meta component API is clunky. We should never allow multiple meta-row inside a meta-rows\n            this.meta.children.forEach(node => {\n                const rowIdMap = new Map();\n                const container = node.parent.container;\n                const sorted = Array.from(node.parent.entries())\n                    .map(([id, metaRowEl]) => {\n                        const rowIdentifier = metaRowEl.rowIdentifier\n                        rowIdMap.set(rowIdentifier, id);\n                        return rowIdentifier;\n                    })\n                    .sort(fn)\n                    .map(rowIdentifier => {\n                        const id = rowIdMap.get(rowIdentifier);\n                        return node.parent.get(id);\n                    });\n                for (const el of sorted) {\n                    el.remove();\n                    container.appendChild(el);\n                }\n            });\n        }\n        // public api\n        reset() {\n            // reset in-memory filters\n        }\n    }\n);
\\xd25b2117abe53a3224841608dbddfc49ff60c78dd6d6bd43a42da8181d72eac9	let promise;\nconst names = new Map();\n\nasync function getPurpose(id) {\n    if (!promise) {\n        promise = db.schema('semantics').relation('relation_purpose').rows()\n            .then(rows => {\n                const purposes = rows.map(i => i);\n                for (const purpose of purposes) {\n                    names.set(purpose.get('id'), purpose.get('purpose'));\n                }\n            })\n    }\n    await promise;\n    return names.get(id);\n}\n\nexport default function(row) {\n    const purpose = await getPurpose(row.get('id'));\n    const relId = row.get('relation_id');\n    return `${relId.schema_name}.${relId.name} ${purpose}`\n}
\\xd2eea6ade6712007ce5f2798ab15b249cb1bf647ec7cd42d3fb2ec714d6acaac	802a422c-4874-4e7e-9b0a-8741b499a493
\\xd3db2678462532a44d841c35d1acbb254b1f64f82acb491252f52e71d28346b1	editor-app
\\xd4996be13249a462521b4d0ee4f083837f442ed58efdff84b5207fd74c34c4a7	import { register, Widget } from '/org.aquameta.core.widget/widget.module/widget-element.js';\nimport '/com.mickey.ui/widget.component/core-code.js';\n\nexport default register(\n    class CoreRowEditCode extends Widget.Element(import.meta) {\n        static row = Widget.Prop;\n    }\n);
\\xd50a37066b1348aaf9623ab7341876f42016d2cbaa6c17c29531935080cbbf65	widget-util
\\xd61273174ec77b0e2b41ac4c399443b04f1e9757a6860d1fc508b925e55e3ed4	6f79a1e1-75e0-4e3c-b05c-b2a57c5b64aa
\\xd6e9aee47337114c004a158c68fd86d10903479d3daa042c35ed980217ff5f86	e5027848-8566-4ed3-ad21-1f54de68be34
\\xd78bcbe4c782aed9cda68c319f363c833c4449fc8f29e019d41c514b1be522b6	b1a9cccc-e3ba-4524-80d7-b88dde8139dd
\\xd878e447b5403dee94261936853abbb2deb10f78df7896f17cde535f5dfed472	e09abd4c-dafd-452c-b04f-1305d8051363
\\xd97cb7a47aee6e9554b865a35857bad1937d07b3f65af15d02818d391acb4582	import { register, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\n\nexport default register(\n    class CoreFieldView extends Widget.Element(import.meta) {\n        static $ = {\n            pre: 'pre',\n        };\n        static field = Widget.Prop;\n\n        onWidgetUpdate(prop) {\n            if (prop === 'field') {\n                this.$.pre.innerText = this.serialize(this.field.value);\n            }\n        }\n\n        serialize(field) {\n            if (Array.isArray(field)) {\n                return `[${field.map(item => this.serialize(item)).join(', ')}]`;\n            } else if (typeof field === 'object') {\n                return JSON.stringify(field, null, 2);\n            } else {\n                return field;\n            }\n        }\n    }\n);
\\xd99a8c886c2482c0c2a6d7b546b74842b3733d83abedb664e200c26d116e8c0e	<!doctype html>\n<html>\n\n<head>\n    <title>widget proof of concept</title>\n    <base href="/com.mickey.ui/" />\n    <style>\n        html,\n        body {\n            height: 100%;\n            margin: 0;\n        }\n    </style>\n    <link rel="stylesheet" href="widget.component/meta-rows.css" />\n</head>\n<!-- things to test\n* multiple meta-rows parents - maybe this is overkill. these components are for simple use cases. use endpoint api for complex situations.\n* automatated test framework for browser\n* if using nested meta-rows components, a shadow dom should separate them\n* how compatible are these components with other rendering methods. can you even render them from a WidgetElement?\n-->\n\n<body>\n    <meta-relation $relation="bundle.bundle" $order="name" name-like="org.%">\n        <meta-rows>\n            <div class="loading">Loading!</div>\n            <!-- meta-rows: pass as property -->\n            <test-logger meta-rows="rows"></test-logger>\n            <ul id="container">\n                <nav>\n                    <!-- meta-rows: iterate over rows, copying meta-row content for each. each template instance is scoped to one row. -->\n                    <meta-row>\n                        <!-- meta-row: scope a field to a meta-field template -->\n                        <meta-field column="name">\n                            <!-- meta-field: pass as property -->\n                            <test-logger meta-field="field"></test-logger>\n                            <!-- meta-field: interpolate field data into template content -->\n                            <a href="/bundle#{name}">{name}</a>\n                        </meta-field>\n                    </meta-row>\n                </nav>\n                <meta-row>\n                    <!-- meta-row: pass as property -->\n                    <test-logger meta-row="row"></test-logger>\n                    <meta-field columns="head_commit_id,name">\n                        <!-- meta-row: pass multiple fields as properties -->\n                        <test-logger meta-field="fields"></test-logger>\n                        <li>\n                            <span>{name} - {head_commit_id}</span>\n                        </li>\n                    </meta-field>\n                    <!-- meta-field: replace tag with field data -->\n                    <meta-field column="checkout_commit_id" />\n                </meta-row>\n            </ul>\n        </meta-rows>\n    </meta-relation>\n</body>\n<script type="module" src="widget.component/meta-relation.js"></script>\n<script type="module" src="widget.component/meta-rows.js"></script>\n<script type="module" src="widget.component/meta-row.js"></script>\n<script type="module" src="widget.component/meta-field.js"></script>\n\n</html>
\\xd9c1e0ca570d97aa198e61cff994c8fde2c5d54bb2ecfb4c5702ef92d7663305	/bundles
\\xda04c6e707fa703c482cc65c5d4d2ba18d42a894517be5e463327991184e6501	02306927-9bab-4543-9b6d-a23c3ac6430b
\\xdd2741e2734916143a6dbf1d1939cbc04396f10356faf54aba282066cec41b5f	944b5a05-be70-45a1-a549-1301d38799e4
\\xdedb16a60830326ba5923ef3c5dd741cd1585c1776b1ec98b7e221ba4eef679a	static-event-tab
\\xdf0ad6e43880f09c90ebf95f19110178aba6890df0010ebda7485029e2b543b4	schema
\\xdfbb889cf19bda82ed8deadf82de232979aa4ecc83238625c6453dc4c597b43a	display
\\xe0571e916ca1bd02f969a6623a4060b1206936dc70bf5dd8a26870441a1d5a97	b62e91cc-26be-4379-9812-de8888b1bd2e
\\xe0be4f04e5d37b33329628b330b4195af4d8a723084aadc802eea93ea6a3899c	<slot></slot>
\\xe18cdf40f4b6d6f0faf268dcef628865296f2ae2cd58015c9672c1d5657e089d	4e4590ba-32ce-43e3-8628-39cdf66f6216
\\xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855	
\\xe49bf947a6ccbb550004245e02b3f0ac92b4890abc9b3186e40058a6563c78dd	/components
\\xe4a5c10be5aed0f4350aff0652378766f5cb5a9a13eca23ce38647ec5a06c774	{css}
\\xe64f56703d9ffb470877ee25ee0c7686219a369ca65244430539d0da4e435a5e	import { register, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\nimport db, { DatumMachine } from '/org.aquameta.core.widget/0.3.1/widget.module/datum.js';\nimport { MetaComponentHelper } from '/com.mickey.ui/1.0.0/widget.module/meta-component-helper.js';\n\nlet idCounter = 0;\n\nexport default register(\n    import.meta,\n    class MetaRelation extends Widget.LightElement {\n        static metaRows = Widget.Prop;\n        static metaRelationAttrs = Widget.Prop;\n        static state = Widget.Fsm(DatumMachine);\n        \n        meta = new MetaComponentHelper(this, 'meta-rows', 'meta-relation');\n\n        async onWidgetConnected() {\n            this.meta.init({ remove: true });\n\n            const relationAttr = this.getAttribute('$relation')\n            if (!relationAttr && relationAttr.includes('.')) {\n                console.error('meta-relation must be passed a schema-qualified `$relation` attr');\n                return;\n            }\n            const [schema, relation] = relationAttr.split('.');\n\n            this.state.dispatch(\n                DatumMachine.request,\n                db.schema(schema).table(relation).rows(\n                    this.parseAttributes()\n                ),\n            );\n        }\n\n        onWidgetStateChange(_context, transition) {\n            if (transition.current === 'success') {\n                this.meta.children.forEach(node => {\n                    node.parent.clear();\n                    for (const row of this.state.context.data) {\n                        const clone = node.content.cloneNode(true);\n                        clone.row = row;\n                        let id = row.get('id');\n                        if (typeof id === 'undefined') {\n                            id = ++idCounter;\n                        }\n                        row.artificialId = id;\n                        node.parent.set(id, clone);\n                    }\n                });\n\n                this.meta.childAttributes.forEach(node => {\n                    node.element[node.property] = this.state.context.data;\n                });\n            }\n        }\n        \n        parseAttributes() {\n            const config = {};\n            const attrs = new Set(this.getAttributeNames());\n            const where = [];\n\n            // TODO: path-in="a,b,c"\n            for (const attr of attrs) {\n                if (attr === 'init' || attr === 'slot') {\n                    continue;\n                } else if (attr.startsWith('$')) {\n                    switch (attr) {\n                        case '$order':\n                            const order = this.getAttribute(attr).split(',').map(sort => {\n                                const desc = sort.startsWith('-');\n                                const column = desc ? sort.replace(/^-/, '') : sort;\n                                const direction = desc ? 'desc' : 'asc';\n                                return { direction, column };\n                            });\n                            config.order_by = order;\n                            break;\n                        case '$offset':\n                            config.offset = parseInt(this.getAttribute(attr));\n                            break;\n                        case '$limit':\n                            config.limit = parseInt(this.getAttribute(attr));\n                            break;\n                        case '$events':\n                            // TODO\n                            config.events = true;\n                            break\n                    }\n                } else {\n                    if (attr.endsWith('-like')) {\n                        where.push({\n                            name: attr.replace(/-like$/, ''),\n                            op: 'like',\n                            value: this.getAttribute(attr),\n                        });\n                    } else {\n                        where.push({\n                            name: attr,\n                            op: '=',\n                            value: this.getAttribute(attr),\n                        });\n                    }\n                }\n            }\n            if (where.length > 0) {\n                config.where = where;\n            }\n            return config;\n        }\n    }\n);
\\xe6e9be1b3faf42f95e74778baecf49e083fd1be6a563476273539301ffedc722	dd85390e-9fb2-48ff-9b82-f332093443a9
\\xe77b1202280510dfd6c6322981d097a9ec902d703d362f86c2e5586e63606fd8	import { define, Widget } from '/org.aquameta.core.widget/widget.module/widget.js';\nimport staticTab from './static-tab.js';\nimport staticTabContent from './static-tab-content.js';\n\nexport default define(\n  import.meta,\n  class StaticTabs extends Widget.Element {\n    static $ = {\n      tabs: Widget.Collection('#tabs'),\n      tabContents: Widget.Collection('#tab-contents'),\n    };\n\n    static tabs = Widget.Prop;\n    static activeTab = Widget.Prop;\n    static tabActivated = Widget.Event;\n\n    onWidgetUpdate(prop, oldValue) {\n      if (prop === 'tabs') {\n        for (let i = 0; i < this.tabs.length; i++) {\n          this.#addTabToCollection(i);\n        }\n      } else if (prop === 'activeTab') {\n        this.$.tabs.setProp(oldValue, { isActive: false });\n        this.$.tabContents.setProp(oldValue, { isActive: false });\n\n        this.$.tabs.setProp(this.activeTab, { isActive: true });\n        this.$.tabContents.setProp(this.activeTab, { isActive: true });\n      }\n    }\n\n    get tabContents() {\n      if (this.$.tabContents) {\n        return Array.from(\n          this.$.tabContents.values())\n          .map(tabContent => tabContent.children[0]\n          );\n      }\n      return [];\n    }\n\n    #addTabToCollection(index) {\n      this.$.tabs.set(index, this.#createTab(index));\n      this.$.tabContents.set(index, this.#createTabContent(index));\n    }\n\n    #createTab(index) {\n      const tabEl = staticTab({\n        label: this.tabs[index].label,\n        tabIndex: index,\n      })\n      this.addListener(tabEl.activated, this.#onTabActivated);\n      return tabEl;\n    }\n\n    #createTabContent(index) {\n      const tabContent = staticTabContent();\n      tabContent.appendChild(this.tabs[index].content);\n      return tabContent;\n    }\n\n    #onTabActivated(e) {\n      const { tabIndex } = e.detail;\n      this.tabActivated.dispatch({ tabIndex });\n    }\n  }\n);\n
\\xe812e4695d71f0d94b8bfeb3919197ac5dcfa4ec80fa4da6a9391353e455799b	semantic-widget
\\xe87156a66c503f69e97ee8f7026005b7e76c0c2fa6dddde3217238f3abaa7a09	rowset
\\xe93e8286b03966c72dd914f625ced0f323b6e3748f2d922dcf75087c276655fa	div {\n    border: 1px solid black;\n    border-radius: 5px;\n    cursor: pointer;\n    display: inline-block;\n    padding: 5px 10px;\n}\n\ndiv:hover {\n    background-color: gray;\n}\n\ndiv:active {\n    background-color: lightgray;\n}\n
\\xea7a348eba014da2f0175b4bf9f85e8d453ee96c4ac475beaa2eac1a2c4c86ff	100d121a-9f31-4e38-b696-ae30a7fe31b6
\\xea8aea1bd5985ce3cf6002eda0a2f2cff47eb5cf9821e42b7d773ed3d4ee023b	jazzy-button
\\xeaca85d33bb74d740a6ef37fa0aac08fe65c37741d41a30a7ec81cbe6a1368e7	core-code
\\xec051e316013ca5d252f3d3bcaf226662ad030866f9e36608a910d7cc0a4f09a	<div id="vertical">\n    <div id="header">\n        <h1 data-bundle-name="textContent"></h1>\n        <a id="link" target="_blank">\n            <material-icon icon="open_in_new"></material-icon>\n        </a>\n    </div>\n    <nav>\n        <static-event-tabs>\n            <static-event-tab event="docs" label="Docs" widget="bundle-docs-editor">\n                <material-icon slot="icon" icon="description"></material-icon>\n            </static-event-tab>\n            <static-event-tab event="stage" label="Stage">\n                <material-icon slot="icon" icon="desktop_windows"></material-icon>\n            </static-event-tab>\n            <static-event-tab event="commit" label="Commits">\n                <material-icon slot="icon" icon="checklist"></material-icon>\n            </static-event-tab>\n            <static-event-tab event="untracked" label="Untracked">\n                <material-icon slot="icon" icon="question_mark"></material-icon>\n            </static-event-tab>\n            <static-event-tab event="remotes" label="Remotes">\n                <material-icon slot="icon" icon="sync_alt"></material-icon>\n            </static-event-tab>\n            <static-event-tab event="semantics" label="Semantics">\n                <material-icon slot="icon" icon="language"></material-icon>\n            </static-event-tab>\n            <static-event-tab event="export" label="Export">\n                <material-icon slot="icon" icon="save"></material-icon>\n            </static-event-tab>\n            <static-event-tab event="config" label="Config">\n                <material-icon slot="icon" icon="settings"></material-icon>\n            </static-event-tab>\n        </static-event-tabs>\n        <pill-form input-placeholder="Search" button-text="Submit" />\n            <material-icon slot="icon" icon="search"></material-icon>\n        </pill-form>\n    </nav>\n    <div id="horizontal">\n        <section id="contents">\n            <bundle-contents data-bundle-name="bundleName"></bundle-contents>\n        </section>\n        <section id="details">\n            <dynamic-tabs></dynamic-tabs>\n        </section>\n    </div>\n</div>
\\xede53e6a1b4df425520ee0f58ed8cfc64a52e1f920e43691650ac96a6e6ee77e	widget/module
\\xee2c0094c5a93697de2526e64b5c4c48e4906a10c3a505d1edda28bf8eed6f4c	widget/dependency_css
\\xee37308ededeb5e16a058f822fa3aa00d11ceecb2bc650d1865495a7691ab4d0	semantics/column_component
\\xeefc08998e04baa3f1ac34a20ea954950b90d906f09f88b32cccffdf22ba9deb	import { register, Widget } from '/org.aquameta.core.widget/0.3.1/widget.module/widget.js';\nimport './meta-row.js';\n\nexport default register(\n    class CoreRowView extends Widget.Element(import.meta) {\n        onWidgetConnected() {\n            this.$ = {\n                table: this.shadowRoot.querySelector('table'),\n            };\n            if (this._row) {\n                this.createTable();\n            }\n        }\n        set row(value) {\n            this._row = value;\n            if (this.$) {\n                this.createTable();\n            }\n        }\n        createTable() {\n            for (const col of this._row.columns) {\n                this.$.table.appendChild(this.createRow(col.name, this._row.field(col.name)));\n            }\n        }\n        createRow(column, field) {\n            const tr = document.createElement('tr');\n            tr.appendChild(this.createCell(column));\n\n            const semanticWidget = document.createElement('semantic-widget');\n            semanticWidget.setAttribute('purpose', 'view');\n            semanticWidget.field = field;\n            tr.appendChild(this.createCell(semanticWidget));\n\n            return tr;\n        }\n        createCell(value) {\n            const td = document.createElement('td');\n            if (value instanceof HTMLElement) {\n                td.appendChild(value);\n            } else {\n                td.innerText = value;\n            }\n            return td;\n        }\n    }\n);
\\xef0f5d2e6ba6142dce243fb68d9d23206f203f56bae494981d7ee22be114a75a	import {Column} from './column.js';\n\nexport class Field {\n    constructor(row, name, pk) {\n        this.row = row;\n        this.column = new Column(row.relation, name);\n        this.is_primary_key = pk;\n        this.name = name;\n        this.value = row.get(name);\n        this.id = { row_id: this.row.id, column_id: this.column.id };\n        this.to_url = function (id_only) {\n            if (this.row.pk_value == null) {\n                console.error(\n                    'You must call a row with "meta_data: true" in order to use the to_url function'\n                );\n                throw 'Datum.js: Programming Error';\n            }\n            return id_only\n                ? '/field/' +\n                this.row.relation.schema.name +\n                '/' +\n                this.row.relation.name +\n                '/' +\n          /*JSON.stringify(this.row.pk_value)*/ this.row.pk_value +\n                '/' +\n                this.column.name\n                : this.row.relation.schema.database.endpoint.url +\n                '/field/' +\n                this.row.relation.schema.name +\n                '/' +\n                this.row.relation.name +\n                '/' +\n          /*JSON.stringify(this.row.pk_value)*/ this.row.pk_value +\n                '/' +\n                this.column.name;\n        };\n    }\n    get() {\n        return this.row.get(this.name);\n    }\n    set(value) {\n        this.value = value;\n        return this.row.set(this.name, value);\n    }\n    update() {\n        // TODO: This is wrong\n        return this.row.update();\n    }\n}\n
\\xef546b8bb0182f52fa462950a18db0e3c4b38b06ebe2f7527bd35f50f1a39800	<pre></pre>
\\xf23657b2fe98dc9747448549dd875a4c7275654fb8a282d94023fbdb5d7fe943	static-tab-content
\\xf46df1e87f9e4c832bc950fe6d8f8c7874f78238203a2f144778799aab763759	a95c1253-ef52-46fa-a1df-d2c2843f4a57
\\xf50c10335d5e3442b5453f8663785283448ffa2000ad00aa3e9ad13305630856	5b38b313-e597-4a5d-878d-d0d91956dbf4
\\xf5259fbfbce9732c4b7628a3244a5ae14e95460b33f80222fcf5dd4fdc21784e	datum
\\xf689a2032ebc32c3f7c9ba811e62f04ffec5b1b4dcd0d2d0743cb1ea324cce49	c4691e07-e6e6-4884-b7f6-fee3cc4b29ca
\\xf6a797e5e816d8b87eedc6db805207a9566cc1f266693fba104cd3e0c4b9245b	1084d2ef-59a7-4126-b98f-fa5e640fecd6
\\xf7fd8ea69744e80d4350e1c8c69b8d1853722209e39dfbabfd6937a27e08df1d	core-field-view-boolean
\\xfacfa9e11451d3c5111017270e509f80eee7c3cc78b80482b4d7439be1fd44b9	import {Field} from './field.js';\nimport {Callbacks} from './util.js';\n\nexport class Row {\n    constructor(relation, response) {\n        this.relation = relation;\n        this.schema = relation.schema;\n        this.row_data = response.result[0].row;\n\n        this.callbacks = new Callbacks();\n        this.cached_fields = {};\n        this.columns = response.columns || null;\n        this.pk_column_name = null;\n        this.pk_value = null;\n        this.id = null;\n        this.to_url = function () {\n            console.error(\n                'You must call a row with "meta_data: true" in order to use the to_url function'\n            );\n            throw 'Datum.js: Programming Error';\n        };\n\n        if (typeof response.pk != 'undefined') {\n            this.pk_column_name = response.pk;\n            this.pk_value = this.get(this.pk_column_name);\n            // this.id = {"pk_column_id":{"relation_id":{"schema_id":{"name":this.schema.name},"name":this.relation.name},"name":this.pk_column_name},"pk_value": this.pk_value}\n            this.id = {\n                pk_column_id: {\n                    relation_id: this.relation.id,\n                    name: this.pk_column_name,\n                },\n                pk_value: this.pk_value,\n            };\n\n            this.to_url = function (id_only) {\n                return id_only\n                    ? '/row/' +\n                    this.relation.schema.name +\n                    '/' +\n                    this.relation.name +\n                    '/' +\n            /*JSON.stringify(this.pk_value)*/ this.pk_value\n                    : this.relation.schema.database.endpoint.url +\n                    '/row/' +\n                    this.relation.schema.name +\n                    '/' +\n                    this.relation.name +\n                    '/' +\n            /*JSON.stringify(this.pk_value)*/ this.pk_value;\n            };\n        }\n    }\n    get(name) {\n        return this.row_data[name];\n    }\n    set(name, value) {\n        this.row_data[name] = value;\n        return this;\n    }\n    to_string() {\n        return JSON.stringify(this.row_data);\n    }\n    clone() {\n        return new Row(this.relation, {\n            columns: this.columns,\n            pk: this.pk_column_name,\n            result: [{ row: this.row_data }],\n        });\n    }\n    field(name) {\n        if (typeof this.cached_fields[name] == 'undefined') {\n            this.cached_fields[name] = new Field(\n                this,\n                name,\n                name === this.pk_column_name\n            );\n        }\n        return this.cached_fields[name];\n    }\n    fields() {\n        if (this.columns != null) {\n            return this.columns.map(\n                function (c) {\n                    return this.field(c.name);\n                }.bind(this)\n            );\n        }\n        return null;\n    }\n    _triggerEvent(eventType, payload) {\n        switch (eventType) {\n            case 'update': {\n                // TODO: update fields\n                break;\n            }\n        }\n        this.callbacks.call(eventType, payload);\n    }\n    onUpdate(fn) {\n        this.callbacks.add('update', fn);\n    }\n    onDelete(fn) {\n        this.callbacks.add('delete', fn);\n    }\n    update() {\n        return this.relation.schema.database.endpoint\n            .patch(this, this.row_data)\n            .then(\n                function (response) {\n                    if (response == null) {\n                        throw 'Empty response';\n                    }\n                    return this;\n                }.bind(this)\n            )\n            .catch(function (err) {\n                throw 'Update failed: ' + err;\n            });\n    }\n    delete() {\n        return this.relation.schema.database.endpoint\n            .delete(this)\n            .then(function (response) {\n                if (response == null) {\n                    throw 'Empty response';\n                }\n            })\n            .catch(function (err) {\n                throw 'Delete failed: ' + err;\n            });\n    }\n    related_rows(\n        self_column_name,\n        related_relation_name,\n        related_column_name,\n        options\n    ) {\n        var relation_parts = related_relation_name.split('.');\n        if (relation_parts.length < 2) {\n            console.error(\n                'Related relation name must be schema qualified (schema_name.relation_name)'\n            );\n            // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n        }\n\n        var schema_name = relation_parts[0];\n        var relation_name = relation_parts[1];\n        var db = this.relation.schema.database;\n\n        options = options || {};\n        options.where =\n            options.where instanceof Array\n                ? options.where\n                : typeof options.where == 'undefined'\n                    ? []\n                    : [options.where];\n        options.where.push({\n            name: related_column_name,\n            op: '=',\n            value: this.get(self_column_name),\n        });\n\n        return db.schema(schema_name).relation(relation_name).rows(options);\n    }\n    related_row(\n        self_column_name,\n        related_relation_name,\n        related_column_name,\n        options\n    ) {\n        var relation_parts = related_relation_name.split('.');\n        if (relation_parts.length < 2) {\n            console.error(\n                'Related relation name must be schema qualified (schema_name.relation_name)'\n            );\n            // throw "Related relation name must be schema qualified (schema_name.relation_name)";\n        }\n\n        var schema_name = relation_parts[0];\n        var relation_name = relation_parts[1];\n        var db = this.relation.schema.database;\n\n        options = options || {};\n        options.where =\n            options.where instanceof Array\n                ? options.where\n                : typeof options.where == 'undefined'\n                    ? []\n                    : [options.where];\n        options.where.push({\n            name: related_column_name,\n            op: '=',\n            value: this.get(self_column_name),\n        });\n\n        return db.schema(schema_name).relation(relation_name).row(options);\n    }\n}\n
\\xfc8fbb48a3a16bfdd85345d0b6aa543ebd805c370e5b763ed75207185093fca3	relation
\\xfcbcf165908dd18a9e49f7ff27810176db8e9f63b4352213741664245224f8aa	false
\\xfcd14c379ac7a1e74dd1359de597e6e11949d108a1a80ba4b5b1fd4e4fabd45e	const logPrefix = '[widget-fsm]';\nconst fsmSymbol = Symbol.for('WidgetFsm');\nconst stateOrTransitionSymbol = Symbol('StateOrTransition');\n\nexport function isFsmClass(cl) {\n    return fsmSymbol in cl;\n}\n\nfunction isStateOrTransition(type) {\n    return type instanceof Object\n        && stateOrTransitionSymbol in type;\n}\n\nfunction isTransition(type) {\n    return type instanceof Object\n        && stateOrTransitionSymbol in type\n        && type.type === Transition;\n}\n\nexport class Fsm {\n    static [fsmSymbol];\n\n    #machine;\n\n    constructor(machine, onStateUpdate) {\n        this.#machine = new machine();\n        this.#machine.checkContext();\n        this.#machine.onStateUpdate = onStateUpdate;\n    }\n\n    get context() {\n        return this.#machine.context;\n    }\n\n    get current() {\n        return this.#machine.current.name;\n    }\n\n    get previous() {\n        return this.#machine?.previous.name;\n    }\n\n    dispatch(event, payload) {\n        this.#machine.dispatch(event, payload);\n    }\n\n    static get State() {\n        return {\n            [stateOrTransitionSymbol]: true,\n            type: State,\n            get initial() {\n                this.type = InitialState;\n                return this;\n            }\n        };\n    }\n\n    static Transition(fromState, toState) {\n        return {\n            [stateOrTransitionSymbol]: true,\n            type: Transition,\n            from: fromState,\n            to: toState,\n        };\n    }\n}\n\nexport class Machine {\n    #transitions = new Map();\n    // #contextNames = new Set();\n    #context = {};\n    #onStateUpdate;\n    #initialState = null;\n    #currentState = null;\n    #previousState = null;\n    #stateMap = new Map();\n    #transitionMap = new Map();\n\n    constructor() {\n        const states = [];\n        const transitions = [];\n\n        // Initialize context values. Queue state and transitions.\n        for (const [name, type] of Object.entries(this.constructor)) {\n            if (type instanceof Object && isStateOrTransition(type)) {\n                if (type.type === InitialState || type.type === State) {\n                    states.push([name, type]);\n                } else if (type.type === Transition) {\n                    transitions.push([name, type]);\n                }\n            } else {\n                /*\n                don't know about context values yet\n                this.#contextNames.add(name);\n                this[name] = type;\n                */\n            }\n        }\n\n        // Initialize states.\n        for (const [name, type] of states) {\n            if (type.type === InitialState) {\n                if (this.#initialState) {\n                    throw new Error(`${logPrefix} Initial state can only be set once`);\n                }\n                const state = new State(name);\n                this[name] = state;\n                this.#initialState = state;\n                this.#currentState = state;\n                this.#stateMap.set(type, state);\n            } else {\n                const state = new State(name);\n                this[name] = state;\n                this.#stateMap.set(type, state);\n            }\n        }\n\n        if (!this.#initialState) {\n            throw new Error(`${logPrefix} Fsm must have initial state.`)\n        }\n\n        // Initialize transitions.\n        for (const [name, type] of transitions) {\n            const fromState = this.#stateMap.get(type.from);\n            const toState = this.#stateMap.get(type.to);\n            const callback = name in this && typeof this[name] === 'function'\n                ? this[name].bind(this)\n                : null;\n\n            const validTransitions = this.#transitions.get(fromState) || new Set();\n            const transition = new Transition(name, fromState, toState, callback);\n            validTransitions.add(transition);\n            this.#transitions.set(fromState, validTransitions);\n            this.#transitionMap.set(type, transition);\n        }\n\n        // TODO:\n        // Generate CSS\n    }\n\n    get current() {\n        return this.#currentState;\n    }\n\n    get previous() {\n        return this.#previousState;\n    }\n\n    get context() {\n        return this.#context;\n    }\n\n    set onStateUpdate(val) {\n        this.#onStateUpdate = val;\n    }\n\n    /*\n    validateContext(context, setContext) {\n        // Make a Set of context on the widget.\n        const widgetContext = new Set(context.map(ctx => ctx.name));\n\n        for (const ctx of this.#contextNames) {\n            // Fail if a context for this machine is not supplied from the widget.\n            if (!widgetContext.has(ctx)) {\n                throw new Error(`${logPrefix} not enough context supplied to fsm`);\n            }\n        }\n\n        this.#setContext = setContext;\n    }\n    */\n    checkContext() {\n        if (!(this.context instanceof Object)) {\n            throw new Error (`${logPrefix} Machine instance context must be an object`)\n        }\n    }\n\n    dispatch(event, payload) {\n        if (!isTransition(event)) {\n            throw new Error(`${logPrefix} dispatched event is not a Fsm.Transition`);\n        }\n\n        const validTransitions = this.#transitions.get(this.#currentState);\n        const transition = this.#transitionMap.get(event);\n\n        if (validTransitions.has(transition)) {\n            this.#previousState = this.#currentState;\n            this.#currentState = transition.to;\n            // TODO: This is not enough. Need to check that transition has callback before to find out if its valid\n            // Also need a way to say that private callbacks are still valid transitions. Different entrypoints for public/private calls?\n            const updates = transition.callback ? transition.callback(payload) : {};\n            for (const [name, data] of Object.entries(updates)) {\n                this.context[name] = data;\n            }\n            const transitionData = {\n                previous: this.#previousState.name,\n                current: this.#currentState.name,\n                event: transition.name,\n            }\n            // Send bulk updates so widget can handle calling onWidgetStateChange().\n            this.#onStateUpdate(updates, transitionData);\n        } else {\n            throw new Error(`${logPrefix} "${transition.name}" transition is not valid from "${this.#currentState.name}" state`);\n        }\n    }\n}\n\nclass State {\n    #name;\n\n    static get initial() {\n        return InitialState;\n    }\n\n    constructor(name) {\n        this.#name = name;\n    }\n\n    get name() {\n        return this.#name;\n    }\n}\nclass InitialState extends State {}\n\nexport class Transition {\n    #name;\n    #fromState;\n    #toState;\n    #callback;\n\n    constructor(name, fromState, toState, callback) {\n        this.#name = name;\n        this.#fromState = fromState;\n        this.#toState = toState;\n        this.#callback = callback;\n    }\n\n    get name() {\n        return this.#name;\n    }\n\n    get from() {\n        return this.#fromState;\n    }\n\n    get to() {\n        return this.#toState;\n    }\n\n    get callback() {\n        return this.#callback;\n    }\n}
\\xfd00ca01628f705498f8a83bb77c9ea4b4879b2d1bcb6ef7838f4a271c902d9c	8d7b18a0-35b6-43a8-91ac-e9467b582b7b
\\xfd176e034a66f8ce418f2af9765ca0c15d70ae3510345551ffeaa478168a5afc	import { define, Widget } from '/org.aquameta.core.widget/widget.module/widget.js';\n\nexport default define(\n    import.meta,\n    class MyWidget extends Widget.Element {\n        static icon = Widget.Attr;\n        constructor() {\n            super();\n            if (!document.head.querySelector('#material-icons')) {\n                const link = document.createElement('link');\n                link.rel = 'stylesheet';\n                link.href = '/com.mickey.ui/widget.module/material-icons.css';\n                document.head.appendChild(link);\n            }\n        }\n    }\n);
\\xfd9484c59f1ae3a4d03500dbef82da2ca684a8323153097cac34e11595995900	8d505d41-035b-4aeb-9d24-adfdf82b6fba
\\xfdc3473d07ecab8735d5bc718154ff1b414961a0b28a755f489a320d9fde1814	fdb137e8-c66d-4fa0-8494-a46c0e83e4d2
\\xfe86d10979a0411b70e74e274ba463555b5c9d42f498fe469fdbf688316dd9a0	<div data-label="innerText"></div>
\\xff604b54e72a1eb717f900742bd4a9e3ae6491a2cc08b4f3feb02d066d791030	import { define, Widget } from '/org.aquameta.core.widget/widget.module/widget.js';\nimport db from '/org.aquameta.core.endpoint/widget.module/datum.js';\nimport jazzyButton from './jazzy-button.js';\n\nexport default define(\n    import.meta,\n    class JazzyForm extends Widget.Element {\n        static $ = {\n            second: '#second',\n        };\n        static rows = Widget.Prop;\n\n        onWidgetConnected() {\n            db.schema('widget').table('widget').rows().then(rows => {\n                this.rows = rows;\n            })\n        }\n\n        buttonClick(e) {\n            console.log(e.detail.name);\n        }\n\n        onWidgetUpdate(prop) {\n            if (prop === 'rows') {\n                for (const row of this.rows.map(i => i)) {\n                    const button = jazzyButton({ row, name: row.get('name') })\n                    this.addListener(button.click, this.buttonClick);\n                    this.shadowRoot.appendChild(button);\n                }\n            }\n        }\n    }\n);
